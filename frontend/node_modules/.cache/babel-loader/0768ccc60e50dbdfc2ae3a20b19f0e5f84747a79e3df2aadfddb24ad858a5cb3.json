{"ast":null,"code":"import axios from \"axios\";\nconst API_URL = \"http://localhost:8080/services/ws\";\nconst createSoapEnvelope = (method, params) => `\n  <soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" \n                    xmlns:ser=\"http://controller.hotelgestion.example.com/\">\n    <soapenv:Header/>\n    <soapenv:Body>\n      <ser:${method}>${params}</ser:${method}>\n    </soapenv:Body>\n  </soapenv:Envelope>\n`;\nexport const reservationService = {\n  // Ajout de la gestion des erreurs SOAP\n  handleSoapResponse(xmlDoc) {\n    const faultElement = xmlDoc.querySelector(\"soap\\\\:Fault, Fault\");\n    if (faultElement) {\n      var _faultElement$querySe;\n      const faultString = (_faultElement$querySe = faultElement.querySelector(\"faultstring\")) === null || _faultElement$querySe === void 0 ? void 0 : _faultElement$querySe.textContent;\n      throw new Error(faultString || \"Erreur SOAP inconnue\");\n    }\n    return xmlDoc;\n  },\n  async getReservations() {\n    try {\n      const response = await axios.post(API_URL, createSoapEnvelope(\"getAllReservations\", \"\"), {\n        headers: {\n          \"Content-Type\": \"text/xml\",\n          SOAPAction: \"\" // Ajout du header SOAPAction\n        }\n      });\n      const parser = new DOMParser();\n      const xmlDoc = parser.parseFromString(response.data, \"text/xml\");\n      this.handleSoapResponse(xmlDoc); // Vérification des erreurs SOAP\n\n      // Ajout de logging pour le débogage\n      console.log(\"Parsed XML Document:\", xmlDoc);\n      const reservations = this.transformReservations(xmlDoc);\n      console.log(\"Transformed Reservations:\", reservations);\n      return reservations;\n    } catch (error) {\n      var _error$response, _error$response2;\n      console.error(\"Détails de l'erreur:\", {\n        message: error.message,\n        response: (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.data,\n        status: (_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.status\n      });\n      throw new Error(`Erreur lors de la récupération des réservations: ${error.message}`);\n    }\n  },\n  async createReservation(formData) {\n    try {\n      if (!formData.clientName) {\n        throw new Error(\"Le nom du client est requis\");\n      }\n      const [firstName, ...lastNameParts] = formData.clientName.split(\" \");\n      const params = `\n        <arg0>${this.formatDate(formData.startDate)}</arg0>\n        <arg1>${this.formatDate(formData.endDate)}</arg1>\n        <arg2>\n          <nom>${lastNameParts.join(\" \").trim()}</nom>\n          <prenom>${firstName.trim()}</prenom>\n          <email>${formData.email}</email>\n          <telephone>${formData.phone}</telephone>\n        </arg2>\n        <arg3>\n          <type>${formData.roomType}</type>\n          <disponible>true</disponible>\n          <prix>0.0</prix>\n        </arg3>\n      `;\n      const soapEnvelope = createSoapEnvelope(\"createReservation\", params);\n      console.log(\"Request SOAP:\", soapEnvelope);\n      const response = await axios.post(API_URL, soapEnvelope, {\n        headers: {\n          \"Content-Type\": \"text/xml\",\n          SOAPAction: \"\"\n        }\n      });\n      const parser = new DOMParser();\n      const xmlDoc = parser.parseFromString(response.data, \"text/xml\");\n      this.handleSoapResponse(xmlDoc);\n      const result = this.transformReservation(xmlDoc.querySelector(\"return\"));\n      console.log(\"Résultat de la création:\", result);\n      return result;\n    } catch (error) {\n      var _error$response3;\n      console.error(\"Détails de l'erreur de création:\", {\n        message: error.message,\n        response: (_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.data,\n        formData\n      });\n      throw new Error(`Erreur lors de la création de la réservation: ${error.message}`);\n    }\n  },\n  // Utilitaire pour formater les dates\n  formatDate(date) {\n    if (!date) return \"\";\n    if (typeof date === \"string\") {\n      return date;\n    }\n    return date.toISOString().split(\"T\")[0];\n  },\n  transformReservation(node) {\n    if (!node) {\n      console.warn(\"Node is null in transformReservation\");\n      return null;\n    }\n    const getNodeValue = path => {\n      const element = node.querySelector(path);\n      if (!element) {\n        console.warn(`Element not found for path: ${path}`);\n        return \"\";\n      }\n      return element.textContent;\n    };\n    const reservation = {\n      id: getNodeValue(\"id\"),\n      clientName: `${getNodeValue(\"client/prenom\")} ${getNodeValue(\"client/nom\")}`.trim(),\n      email: getNodeValue(\"client/email\"),\n      phone: getNodeValue(\"client/telephone\"),\n      roomType: getNodeValue(\"chambre/type\"),\n      startDate: getNodeValue(\"dateDebut\"),\n      endDate: getNodeValue(\"dateFin\"),\n      preferences: getNodeValue(\"preferences\") || \"\"\n    };\n    console.log(\"Transformed reservation:\", reservation);\n    return reservation;\n  },\n  transformReservations(xmlDoc) {\n    const returns = xmlDoc.querySelectorAll(\"return\");\n    console.log(`Found ${returns.length} return elements`);\n    const reservations = Array.from(returns).map(res => this.transformReservation(res)).filter(res => res !== null);\n    console.log(`Transformed ${reservations.length} valid reservations`);\n    return reservations;\n  }\n};","map":{"version":3,"names":["axios","API_URL","createSoapEnvelope","method","params","reservationService","handleSoapResponse","xmlDoc","faultElement","querySelector","_faultElement$querySe","faultString","textContent","Error","getReservations","response","post","headers","SOAPAction","parser","DOMParser","parseFromString","data","console","log","reservations","transformReservations","error","_error$response","_error$response2","message","status","createReservation","formData","clientName","firstName","lastNameParts","split","formatDate","startDate","endDate","join","trim","email","phone","roomType","soapEnvelope","result","transformReservation","_error$response3","date","toISOString","node","warn","getNodeValue","path","element","reservation","id","preferences","returns","querySelectorAll","length","Array","from","map","res","filter"],"sources":["/Users/soukaina/Desktop/hotel-reservation-management-soap/frontend-soapt/src/services/reservationService.js"],"sourcesContent":["import axios from \"axios\";\n\nconst API_URL = \"http://localhost:8080/services/ws\";\n\nconst createSoapEnvelope = (method, params) => `\n  <soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" \n                    xmlns:ser=\"http://controller.hotelgestion.example.com/\">\n    <soapenv:Header/>\n    <soapenv:Body>\n      <ser:${method}>${params}</ser:${method}>\n    </soapenv:Body>\n  </soapenv:Envelope>\n`;\n\nexport const reservationService = {\n  // Ajout de la gestion des erreurs SOAP\n  handleSoapResponse(xmlDoc) {\n    const faultElement = xmlDoc.querySelector(\"soap\\\\:Fault, Fault\");\n    if (faultElement) {\n      const faultString =\n        faultElement.querySelector(\"faultstring\")?.textContent;\n      throw new Error(faultString || \"Erreur SOAP inconnue\");\n    }\n    return xmlDoc;\n  },\n\n  async getReservations() {\n    try {\n      const response = await axios.post(\n        API_URL,\n        createSoapEnvelope(\"getAllReservations\", \"\"),\n        {\n          headers: {\n            \"Content-Type\": \"text/xml\",\n            SOAPAction: \"\", // Ajout du header SOAPAction\n          },\n        }\n      );\n\n      const parser = new DOMParser();\n      const xmlDoc = parser.parseFromString(response.data, \"text/xml\");\n      this.handleSoapResponse(xmlDoc); // Vérification des erreurs SOAP\n\n      // Ajout de logging pour le débogage\n      console.log(\"Parsed XML Document:\", xmlDoc);\n      const reservations = this.transformReservations(xmlDoc);\n      console.log(\"Transformed Reservations:\", reservations);\n\n      return reservations;\n    } catch (error) {\n      console.error(\"Détails de l'erreur:\", {\n        message: error.message,\n        response: error.response?.data,\n        status: error.response?.status,\n      });\n      throw new Error(\n        `Erreur lors de la récupération des réservations: ${error.message}`\n      );\n    }\n  },\n\n  async createReservation(formData) {\n    try {\n      if (!formData.clientName) {\n        throw new Error(\"Le nom du client est requis\");\n      }\n\n      const [firstName, ...lastNameParts] = formData.clientName.split(\" \");\n      const params = `\n        <arg0>${this.formatDate(formData.startDate)}</arg0>\n        <arg1>${this.formatDate(formData.endDate)}</arg1>\n        <arg2>\n          <nom>${lastNameParts.join(\" \").trim()}</nom>\n          <prenom>${firstName.trim()}</prenom>\n          <email>${formData.email}</email>\n          <telephone>${formData.phone}</telephone>\n        </arg2>\n        <arg3>\n          <type>${formData.roomType}</type>\n          <disponible>true</disponible>\n          <prix>0.0</prix>\n        </arg3>\n      `;\n\n      const soapEnvelope = createSoapEnvelope(\"createReservation\", params);\n      console.log(\"Request SOAP:\", soapEnvelope);\n\n      const response = await axios.post(API_URL, soapEnvelope, {\n        headers: {\n          \"Content-Type\": \"text/xml\",\n          SOAPAction: \"\",\n        },\n      });\n\n      const parser = new DOMParser();\n      const xmlDoc = parser.parseFromString(response.data, \"text/xml\");\n      this.handleSoapResponse(xmlDoc);\n\n      const result = this.transformReservation(xmlDoc.querySelector(\"return\"));\n      console.log(\"Résultat de la création:\", result);\n      return result;\n    } catch (error) {\n      console.error(\"Détails de l'erreur de création:\", {\n        message: error.message,\n        response: error.response?.data,\n        formData,\n      });\n      throw new Error(\n        `Erreur lors de la création de la réservation: ${error.message}`\n      );\n    }\n  },\n\n  // Utilitaire pour formater les dates\n  formatDate(date) {\n    if (!date) return \"\";\n    if (typeof date === \"string\") {\n      return date;\n    }\n    return date.toISOString().split(\"T\")[0];\n  },\n\n  transformReservation(node) {\n    if (!node) {\n      console.warn(\"Node is null in transformReservation\");\n      return null;\n    }\n\n    const getNodeValue = (path) => {\n      const element = node.querySelector(path);\n      if (!element) {\n        console.warn(`Element not found for path: ${path}`);\n        return \"\";\n      }\n      return element.textContent;\n    };\n\n    const reservation = {\n      id: getNodeValue(\"id\"),\n      clientName: `${getNodeValue(\"client/prenom\")} ${getNodeValue(\n        \"client/nom\"\n      )}`.trim(),\n      email: getNodeValue(\"client/email\"),\n      phone: getNodeValue(\"client/telephone\"),\n      roomType: getNodeValue(\"chambre/type\"),\n      startDate: getNodeValue(\"dateDebut\"),\n      endDate: getNodeValue(\"dateFin\"),\n      preferences: getNodeValue(\"preferences\") || \"\",\n    };\n\n    console.log(\"Transformed reservation:\", reservation);\n    return reservation;\n  },\n\n  transformReservations(xmlDoc) {\n    const returns = xmlDoc.querySelectorAll(\"return\");\n    console.log(`Found ${returns.length} return elements`);\n\n    const reservations = Array.from(returns)\n      .map((res) => this.transformReservation(res))\n      .filter((res) => res !== null);\n\n    console.log(`Transformed ${reservations.length} valid reservations`);\n    return reservations;\n  },\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}