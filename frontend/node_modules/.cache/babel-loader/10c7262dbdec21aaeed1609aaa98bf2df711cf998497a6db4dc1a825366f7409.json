{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SignedXml = void 0;\nconst xpath = require(\"xpath\");\nconst xmldom = require(\"@xmldom/xmldom\");\nconst utils = require(\"./utils\");\nconst c14n = require(\"./c14n-canonicalization\");\nconst execC14n = require(\"./exclusive-canonicalization\");\nconst envelopedSignatures = require(\"./enveloped-signature\");\nconst hashAlgorithms = require(\"./hash-algorithms\");\nconst signatureAlgorithms = require(\"./signature-algorithms\");\nconst isDomNode = require(\"@xmldom/is-dom-node\");\nclass SignedXml {\n  /**\n   * The SignedXml constructor provides an abstraction for sign and verify xml documents. The object is constructed using\n   * @param options {@link SignedXmlOptions}\n   */\n  constructor(options = {}) {\n    /**\n     * One of the supported signature algorithms.\n     * @see {@link SignatureAlgorithmType}\n     */\n    this.signatureAlgorithm = undefined;\n    /**\n     * Rules used to convert an XML document into its canonical form.\n     */\n    this.canonicalizationAlgorithm = undefined;\n    /**\n     * It specifies a list of namespace prefixes that should be considered \"inclusive\" during the canonicalization process.\n     */\n    this.inclusiveNamespacesPrefixList = [];\n    this.namespaceResolver = {\n      lookupNamespaceURI: function /* prefix */\n      () {\n        throw new Error(\"Not implemented\");\n      }\n    };\n    this.implicitTransforms = [];\n    this.keyInfoAttributes = {};\n    this.getKeyInfoContent = SignedXml.getKeyInfoContent;\n    this.getCertFromKeyInfo = SignedXml.getCertFromKeyInfo;\n    // Internal state\n    this.id = 0;\n    this.signedXml = \"\";\n    this.signatureXml = \"\";\n    this.signatureNode = null;\n    this.signatureValue = \"\";\n    this.originalXmlWithIds = \"\";\n    this.keyInfo = null;\n    /**\n     * Contains the references that were signed.\n     * @see {@link Reference}\n     */\n    this.references = [];\n    /**\n     *  To add a new transformation algorithm create a new class that implements the {@link TransformationAlgorithm} interface, and register it here. More info: {@link https://github.com/node-saml/xml-crypto#customizing-algorithms|Customizing Algorithms}\n     */\n    this.CanonicalizationAlgorithms = {\n      \"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\": c14n.C14nCanonicalization,\n      \"http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments\": c14n.C14nCanonicalizationWithComments,\n      \"http://www.w3.org/2001/10/xml-exc-c14n#\": execC14n.ExclusiveCanonicalization,\n      \"http://www.w3.org/2001/10/xml-exc-c14n#WithComments\": execC14n.ExclusiveCanonicalizationWithComments,\n      \"http://www.w3.org/2000/09/xmldsig#enveloped-signature\": envelopedSignatures.EnvelopedSignature\n    };\n    /**\n     * To add a new hash algorithm create a new class that implements the {@link HashAlgorithm} interface, and register it here. More info: {@link https://github.com/node-saml/xml-crypto#customizing-algorithms|Customizing Algorithms}\n     */\n    this.HashAlgorithms = {\n      \"http://www.w3.org/2000/09/xmldsig#sha1\": hashAlgorithms.Sha1,\n      \"http://www.w3.org/2001/04/xmlenc#sha256\": hashAlgorithms.Sha256,\n      \"http://www.w3.org/2001/04/xmlenc#sha512\": hashAlgorithms.Sha512\n    };\n    /**\n     * To add a new signature algorithm create a new class that implements the {@link SignatureAlgorithm} interface, and register it here. More info: {@link https://github.com/node-saml/xml-crypto#customizing-algorithms|Customizing Algorithms}\n     */\n    this.SignatureAlgorithms = {\n      \"http://www.w3.org/2000/09/xmldsig#rsa-sha1\": signatureAlgorithms.RsaSha1,\n      \"http://www.w3.org/2001/04/xmldsig-more#rsa-sha256\": signatureAlgorithms.RsaSha256,\n      \"http://www.w3.org/2001/04/xmldsig-more#rsa-sha512\": signatureAlgorithms.RsaSha512\n      // Disabled by default due to key confusion concerns.\n      // 'http://www.w3.org/2000/09/xmldsig#hmac-sha1': SignatureAlgorithms.HmacSha1\n    };\n    const {\n      idMode,\n      idAttribute,\n      privateKey,\n      publicCert,\n      signatureAlgorithm,\n      canonicalizationAlgorithm,\n      inclusiveNamespacesPrefixList,\n      implicitTransforms,\n      keyInfoAttributes,\n      getKeyInfoContent,\n      getCertFromKeyInfo\n    } = options;\n    // Options\n    this.idMode = idMode;\n    this.idAttributes = [\"Id\", \"ID\", \"id\"];\n    if (idAttribute) {\n      this.idAttributes.unshift(idAttribute);\n    }\n    this.privateKey = privateKey;\n    this.publicCert = publicCert;\n    this.signatureAlgorithm = signatureAlgorithm ?? this.signatureAlgorithm;\n    this.canonicalizationAlgorithm = canonicalizationAlgorithm;\n    if (typeof inclusiveNamespacesPrefixList === \"string\") {\n      this.inclusiveNamespacesPrefixList = inclusiveNamespacesPrefixList.split(\" \");\n    } else if (utils.isArrayHasLength(inclusiveNamespacesPrefixList)) {\n      this.inclusiveNamespacesPrefixList = inclusiveNamespacesPrefixList;\n    }\n    this.implicitTransforms = implicitTransforms ?? this.implicitTransforms;\n    this.keyInfoAttributes = keyInfoAttributes ?? this.keyInfoAttributes;\n    this.getKeyInfoContent = getKeyInfoContent ?? this.getKeyInfoContent;\n    this.getCertFromKeyInfo = getCertFromKeyInfo ?? SignedXml.noop;\n    this.CanonicalizationAlgorithms;\n    this.HashAlgorithms;\n    this.SignatureAlgorithms;\n  }\n  /**\n   * Due to key-confusion issues, it's risky to have both hmac\n   * and digital signature algorithms enabled at the same time.\n   * This enables HMAC and disables other signing algorithms.\n   */\n  enableHMAC() {\n    this.SignatureAlgorithms = {\n      \"http://www.w3.org/2000/09/xmldsig#hmac-sha1\": signatureAlgorithms.HmacSha1\n    };\n    this.getKeyInfoContent = SignedXml.noop;\n  }\n  /**\n   * Builds the contents of a KeyInfo element as an XML string.\n   *\n   * For example, if the value of the prefix argument is 'foo', then\n   * the resultant XML string will be \"<foo:X509Data></foo:X509Data>\"\n   *\n   * @return an XML string representation of the contents of a KeyInfo element, or `null` if no `KeyInfo` element should be included\n   */\n  static getKeyInfoContent({\n    publicCert,\n    prefix\n  }) {\n    if (publicCert == null) {\n      return null;\n    }\n    prefix = prefix ? `${prefix}:` : \"\";\n    let x509Certs = \"\";\n    if (Buffer.isBuffer(publicCert)) {\n      publicCert = publicCert.toString(\"latin1\");\n    }\n    let publicCertMatches = [];\n    if (typeof publicCert === \"string\") {\n      publicCertMatches = publicCert.match(utils.EXTRACT_X509_CERTS) || [];\n    }\n    if (publicCertMatches.length > 0) {\n      x509Certs = publicCertMatches.map(c => `<${prefix}X509Certificate>${utils.pemToDer(c).toString(\"base64\")}</${prefix}X509Certificate>`).join(\"\");\n    }\n    return `<${prefix}X509Data>${x509Certs}</${prefix}X509Data>`;\n  }\n  /**\n   * Returns the value of the signing certificate based on the contents of the\n   * specified KeyInfo.\n   *\n   * @param keyInfo KeyInfo element (@see https://www.w3.org/TR/2008/REC-xmldsig-core-20080610/#sec-X509Data)\n   * @return the signing certificate as a string in PEM format\n   */\n  static getCertFromKeyInfo(keyInfo) {\n    if (keyInfo != null) {\n      const cert = xpath.select1(\".//*[local-name(.)='X509Certificate']\", keyInfo);\n      if (isDomNode.isNodeLike(cert)) {\n        return utils.derToPem(cert.textContent ?? \"\", \"CERTIFICATE\");\n      }\n    }\n    return null;\n  }\n  checkSignature(xml, callback) {\n    if (callback != null && typeof callback !== \"function\") {\n      throw new Error(\"Last parameter must be a callback function\");\n    }\n    this.signedXml = xml;\n    const doc = new xmldom.DOMParser().parseFromString(xml);\n    if (!this.getReferences().every(ref => this.validateReference(ref, doc))) {\n      if (callback) {\n        callback(new Error(\"Could not validate all references\"));\n        return;\n      }\n      return false;\n    }\n    const signedInfoCanon = this.getCanonSignedInfoXml(doc);\n    const signer = this.findSignatureAlgorithm(this.signatureAlgorithm);\n    const key = this.getCertFromKeyInfo(this.keyInfo) || this.publicCert || this.privateKey;\n    if (key == null) {\n      throw new Error(\"KeyInfo or publicCert or privateKey is required to validate signature\");\n    }\n    if (callback) {\n      signer.verifySignature(signedInfoCanon, key, this.signatureValue, callback);\n    } else {\n      const verified = signer.verifySignature(signedInfoCanon, key, this.signatureValue);\n      if (verified === false) {\n        throw new Error(`invalid signature: the signature value ${this.signatureValue} is incorrect`);\n      }\n      return true;\n    }\n  }\n  getCanonSignedInfoXml(doc) {\n    if (this.signatureNode == null) {\n      throw new Error(\"No signature found.\");\n    }\n    if (typeof this.canonicalizationAlgorithm !== \"string\") {\n      throw new Error(\"Missing canonicalizationAlgorithm when trying to get signed info for XML\");\n    }\n    const signedInfo = utils.findChildren(this.signatureNode, \"SignedInfo\");\n    if (signedInfo.length === 0) {\n      throw new Error(\"could not find SignedInfo element in the message\");\n    }\n    if (this.canonicalizationAlgorithm === \"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\" || this.canonicalizationAlgorithm === \"http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments\") {\n      if (!doc || typeof doc !== \"object\") {\n        throw new Error(\"When canonicalization method is non-exclusive, whole xml dom must be provided as an argument\");\n      }\n    }\n    /**\n     * Search for ancestor namespaces before canonicalization.\n     */\n    const ancestorNamespaces = utils.findAncestorNs(doc, \"//*[local-name()='SignedInfo']\");\n    const c14nOptions = {\n      ancestorNamespaces: ancestorNamespaces\n    };\n    return this.getCanonXml([this.canonicalizationAlgorithm], signedInfo[0], c14nOptions);\n  }\n  getCanonReferenceXml(doc, ref, node) {\n    /**\n     * Search for ancestor namespaces before canonicalization.\n     */\n    if (Array.isArray(ref.transforms)) {\n      ref.ancestorNamespaces = utils.findAncestorNs(doc, ref.xpath, this.namespaceResolver);\n    }\n    const c14nOptions = {\n      inclusiveNamespacesPrefixList: ref.inclusiveNamespacesPrefixList,\n      ancestorNamespaces: ref.ancestorNamespaces\n    };\n    return this.getCanonXml(ref.transforms, node, c14nOptions);\n  }\n  calculateSignatureValue(doc, callback) {\n    const signedInfoCanon = this.getCanonSignedInfoXml(doc);\n    const signer = this.findSignatureAlgorithm(this.signatureAlgorithm);\n    if (this.privateKey == null) {\n      throw new Error(\"Private key is required to compute signature\");\n    }\n    if (typeof callback === \"function\") {\n      signer.getSignature(signedInfoCanon, this.privateKey, callback);\n    } else {\n      this.signatureValue = signer.getSignature(signedInfoCanon, this.privateKey);\n    }\n  }\n  findSignatureAlgorithm(name) {\n    if (name == null) {\n      throw new Error(\"signatureAlgorithm is required\");\n    }\n    const algo = this.SignatureAlgorithms[name];\n    if (algo) {\n      return new algo();\n    } else {\n      throw new Error(`signature algorithm '${name}' is not supported`);\n    }\n  }\n  findCanonicalizationAlgorithm(name) {\n    if (name != null) {\n      const algo = this.CanonicalizationAlgorithms[name];\n      if (algo) {\n        return new algo();\n      }\n    }\n    throw new Error(`canonicalization algorithm '${name}' is not supported`);\n  }\n  findHashAlgorithm(name) {\n    const algo = this.HashAlgorithms[name];\n    if (algo) {\n      return new algo();\n    } else {\n      throw new Error(`hash algorithm '${name}' is not supported`);\n    }\n  }\n  validateElementAgainstReferences(elemOrXpath, doc) {\n    let elem;\n    if (typeof elemOrXpath === \"string\") {\n      const firstElem = xpath.select1(elemOrXpath, doc);\n      isDomNode.assertIsElementNode(firstElem);\n      elem = firstElem;\n    } else {\n      elem = elemOrXpath;\n    }\n    for (const ref of this.getReferences()) {\n      const uri = ref.uri?.[0] === \"#\" ? ref.uri.substring(1) : ref.uri;\n      for (const attr of this.idAttributes) {\n        const elemId = elem.getAttribute(attr);\n        if (uri === elemId) {\n          ref.xpath = `//*[@*[local-name(.)='${attr}']='${uri}']`;\n          break; // found the correct element, no need to check further\n        }\n      }\n      const canonXml = this.getCanonReferenceXml(doc, ref, elem);\n      const hash = this.findHashAlgorithm(ref.digestAlgorithm);\n      const digest = hash.getHash(canonXml);\n      if (utils.validateDigestValue(digest, ref.digestValue)) {\n        return ref;\n      }\n    }\n    throw new Error(\"No references passed validation\");\n  }\n  validateReference(ref, doc) {\n    const uri = ref.uri?.[0] === \"#\" ? ref.uri.substring(1) : ref.uri;\n    let elem = null;\n    if (uri === \"\") {\n      elem = xpath.select1(\"//*\", doc);\n    } else if (uri?.indexOf(\"'\") !== -1) {\n      // xpath injection\n      throw new Error(\"Cannot validate a uri with quotes inside it\");\n    } else {\n      let num_elements_for_id = 0;\n      for (const attr of this.idAttributes) {\n        const tmp_elemXpath = `//*[@*[local-name(.)='${attr}']='${uri}']`;\n        const tmp_elem = xpath.select(tmp_elemXpath, doc);\n        if (utils.isArrayHasLength(tmp_elem)) {\n          num_elements_for_id += tmp_elem.length;\n          if (num_elements_for_id > 1) {\n            throw new Error(\"Cannot validate a document which contains multiple elements with the \" + \"same value for the ID / Id / Id attributes, in order to prevent \" + \"signature wrapping attack.\");\n          }\n          elem = tmp_elem[0];\n          ref.xpath = tmp_elemXpath;\n        }\n      }\n    }\n    ref.getValidatedNode = xpathSelector => {\n      xpathSelector = xpathSelector || ref.xpath;\n      if (typeof xpathSelector !== \"string\" || ref.validationError != null) {\n        return null;\n      }\n      const selectedValue = xpath.select1(xpathSelector, doc);\n      return isDomNode.isNodeLike(selectedValue) ? selectedValue : null;\n    };\n    if (!isDomNode.isNodeLike(elem)) {\n      const validationError = new Error(`invalid signature: the signature references an element with uri ${ref.uri} but could not find such element in the xml`);\n      ref.validationError = validationError;\n      return false;\n    }\n    const canonXml = this.getCanonReferenceXml(doc, ref, elem);\n    const hash = this.findHashAlgorithm(ref.digestAlgorithm);\n    const digest = hash.getHash(canonXml);\n    if (!utils.validateDigestValue(digest, ref.digestValue)) {\n      const validationError = new Error(`invalid signature: for uri ${ref.uri} calculated digest is ${digest} but the xml to validate supplies digest ${ref.digestValue}`);\n      ref.validationError = validationError;\n      return false;\n    }\n    return true;\n  }\n  findSignatures(doc) {\n    const nodes = xpath.select(\"//*[local-name(.)='Signature' and namespace-uri(.)='http://www.w3.org/2000/09/xmldsig#']\", doc);\n    return isDomNode.isArrayOfNodes(nodes) ? nodes : [];\n  }\n  /**\n   * Loads the signature information from the provided XML node or string.\n   *\n   * @param signatureNode The XML node or string representing the signature.\n   */\n  loadSignature(signatureNode) {\n    if (typeof signatureNode === \"string\") {\n      this.signatureNode = signatureNode = new xmldom.DOMParser().parseFromString(signatureNode);\n    } else {\n      this.signatureNode = signatureNode;\n    }\n    this.signatureXml = signatureNode.toString();\n    const node = xpath.select1(\".//*[local-name(.)='CanonicalizationMethod']/@Algorithm\", signatureNode);\n    if (!isDomNode.isNodeLike(node)) {\n      throw new Error(\"could not find CanonicalizationMethod/@Algorithm element\");\n    }\n    if (isDomNode.isAttributeNode(node)) {\n      this.canonicalizationAlgorithm = node.value;\n    }\n    const signatureAlgorithm = xpath.select1(\".//*[local-name(.)='SignatureMethod']/@Algorithm\", signatureNode);\n    if (isDomNode.isAttributeNode(signatureAlgorithm)) {\n      this.signatureAlgorithm = signatureAlgorithm.value;\n    }\n    this.references = [];\n    const references = xpath.select(\".//*[local-name(.)='SignedInfo']/*[local-name(.)='Reference']\", signatureNode);\n    if (!utils.isArrayHasLength(references)) {\n      throw new Error(\"could not find any Reference elements\");\n    }\n    for (const reference of references) {\n      this.loadReference(reference);\n    }\n    const signatureValue = xpath.select1(\".//*[local-name(.)='SignatureValue']/text()\", signatureNode);\n    if (isDomNode.isTextNode(signatureValue)) {\n      this.signatureValue = signatureValue.data.replace(/\\r?\\n/g, \"\");\n    }\n    const keyInfo = xpath.select1(\".//*[local-name(.)='KeyInfo']\", signatureNode);\n    if (isDomNode.isNodeLike(keyInfo)) {\n      this.keyInfo = keyInfo;\n    }\n  }\n  /**\n   * Load the reference xml node to a model\n   *\n   */\n  loadReference(refNode) {\n    let nodes = utils.findChildren(refNode, \"DigestMethod\");\n    if (nodes.length === 0) {\n      throw new Error(`could not find DigestMethod in reference ${refNode.toString()}`);\n    }\n    const digestAlgoNode = nodes[0];\n    const attr = utils.findAttr(digestAlgoNode, \"Algorithm\");\n    if (!attr) {\n      throw new Error(`could not find Algorithm attribute in node ${digestAlgoNode.toString()}`);\n    }\n    const digestAlgo = attr.value;\n    nodes = utils.findChildren(refNode, \"DigestValue\");\n    if (nodes.length === 0) {\n      throw new Error(`could not find DigestValue node in reference ${refNode.toString()}`);\n    }\n    const firstChild = nodes[0].firstChild;\n    if (!firstChild || !(\"data\" in firstChild)) {\n      throw new Error(`could not find the value of DigestValue in ${nodes[0].toString()}`);\n    }\n    const digestValue = firstChild.data;\n    const transforms = [];\n    let inclusiveNamespacesPrefixList = [];\n    nodes = utils.findChildren(refNode, \"Transforms\");\n    if (nodes.length !== 0) {\n      const transformsNode = nodes[0];\n      const transformsAll = utils.findChildren(transformsNode, \"Transform\");\n      for (const transform of transformsAll) {\n        const transformAttr = utils.findAttr(transform, \"Algorithm\");\n        if (transformAttr) {\n          transforms.push(transformAttr.value);\n        }\n      }\n      // This is a little strange, we are looking for children of the last child of `transformsNode`\n      const inclusiveNamespaces = utils.findChildren(transformsAll[transformsAll.length - 1], \"InclusiveNamespaces\");\n      if (utils.isArrayHasLength(inclusiveNamespaces)) {\n        // Should really only be one prefix list, but maybe there's some circumstances where more than one to let's handle it\n        inclusiveNamespacesPrefixList = inclusiveNamespaces.flatMap(namespace => (namespace.getAttribute(\"PrefixList\") ?? \"\").split(\" \")).filter(value => value.length > 0);\n      }\n    }\n    if (utils.isArrayHasLength(this.implicitTransforms)) {\n      this.implicitTransforms.forEach(function (t) {\n        transforms.push(t);\n      });\n    }\n    /**\n     * DigestMethods take an octet stream rather than a node set. If the output of the last transform is a node set, we\n     * need to canonicalize the node set to an octet stream using non-exclusive canonicalization. If there are no\n     * transforms, we need to canonicalize because URI dereferencing for a same-document reference will return a node-set.\n     * @see:\n     * https://www.w3.org/TR/xmldsig-core1/#sec-DigestMethod\n     * https://www.w3.org/TR/xmldsig-core1/#sec-ReferenceProcessingModel\n     * https://www.w3.org/TR/xmldsig-core1/#sec-Same-Document\n     */\n    if (transforms.length === 0 || transforms[transforms.length - 1] === \"http://www.w3.org/2000/09/xmldsig#enveloped-signature\") {\n      transforms.push(\"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\");\n    }\n    this.addReference({\n      transforms,\n      digestAlgorithm: digestAlgo,\n      uri: isDomNode.isElementNode(refNode) ? utils.findAttr(refNode, \"URI\")?.value : undefined,\n      digestValue,\n      inclusiveNamespacesPrefixList,\n      isEmptyUri: false\n    });\n  }\n  /**\n   * Adds a reference to the signature.\n   *\n   * @param xpath The XPath expression to select the XML nodes to be referenced.\n   * @param transforms An array of transform algorithms to be applied to the selected nodes.\n   * @param digestAlgorithm The digest algorithm to use for computing the digest value.\n   * @param uri The URI identifier for the reference. If empty, an empty URI will be used.\n   * @param digestValue The expected digest value for the reference.\n   * @param inclusiveNamespacesPrefixList The prefix list for inclusive namespace canonicalization.\n   * @param isEmptyUri Indicates whether the URI is empty. Defaults to `false`.\n   */\n  addReference({\n    xpath,\n    transforms,\n    digestAlgorithm,\n    uri = \"\",\n    digestValue,\n    inclusiveNamespacesPrefixList = [],\n    isEmptyUri = false\n  }) {\n    if (digestAlgorithm == null) {\n      throw new Error(\"digestAlgorithm is required\");\n    }\n    if (!utils.isArrayHasLength(transforms)) {\n      throw new Error(\"transforms must contain at least one transform algorithm\");\n    }\n    this.references.push({\n      xpath,\n      transforms,\n      digestAlgorithm,\n      uri,\n      digestValue,\n      inclusiveNamespacesPrefixList,\n      isEmptyUri,\n      getValidatedNode: () => {\n        throw new Error(\"Reference has not been validated yet; Did you call `sig.checkSignature()`?\");\n      }\n    });\n  }\n  getReferences() {\n    return this.references;\n  }\n  computeSignature(xml, options, callbackParam) {\n    let callback;\n    if (typeof options === \"function\" && callbackParam == null) {\n      callback = options;\n      options = {};\n    } else {\n      callback = callbackParam;\n      options = options ?? {};\n    }\n    const doc = new xmldom.DOMParser().parseFromString(xml);\n    let xmlNsAttr = \"xmlns\";\n    const signatureAttrs = [];\n    let currentPrefix;\n    const validActions = [\"append\", \"prepend\", \"before\", \"after\"];\n    const prefix = options.prefix;\n    const attrs = options.attrs || {};\n    const location = options.location || {};\n    const existingPrefixes = options.existingPrefixes || {};\n    this.namespaceResolver = {\n      lookupNamespaceURI: function (prefix) {\n        return prefix ? existingPrefixes[prefix] : null;\n      }\n    };\n    // defaults to the root node\n    location.reference = location.reference || \"/*\";\n    // defaults to append action\n    location.action = location.action || \"append\";\n    if (validActions.indexOf(location.action) === -1) {\n      const err = new Error(`location.action option has an invalid action: ${location.action}, must be any of the following values: ${validActions.join(\", \")}`);\n      if (!callback) {\n        throw err;\n      } else {\n        callback(err);\n        return;\n      }\n    }\n    // automatic insertion of `:`\n    if (prefix) {\n      xmlNsAttr += `:${prefix}`;\n      currentPrefix = `${prefix}:`;\n    } else {\n      currentPrefix = \"\";\n    }\n    Object.keys(attrs).forEach(function (name) {\n      if (name !== \"xmlns\" && name !== xmlNsAttr) {\n        signatureAttrs.push(`${name}=\"${attrs[name]}\"`);\n      }\n    });\n    // add the xml namespace attribute\n    signatureAttrs.push(`${xmlNsAttr}=\"http://www.w3.org/2000/09/xmldsig#\"`);\n    let signatureXml = `<${currentPrefix}Signature ${signatureAttrs.join(\" \")}>`;\n    signatureXml += this.createSignedInfo(doc, prefix);\n    signatureXml += this.getKeyInfo(prefix);\n    signatureXml += `</${currentPrefix}Signature>`;\n    this.originalXmlWithIds = doc.toString();\n    let existingPrefixesString = \"\";\n    Object.keys(existingPrefixes).forEach(function (key) {\n      existingPrefixesString += `xmlns:${key}=\"${existingPrefixes[key]}\" `;\n    });\n    // A trick to remove the namespaces that already exist in the xml\n    // This only works if the prefix and namespace match with those in the xml\n    const dummySignatureWrapper = `<Dummy ${existingPrefixesString}>${signatureXml}</Dummy>`;\n    const nodeXml = new xmldom.DOMParser().parseFromString(dummySignatureWrapper);\n    // Because we are using a dummy wrapper hack described above, we know there will be a `firstChild`\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const signatureDoc = nodeXml.documentElement.firstChild;\n    const referenceNode = xpath.select1(location.reference, doc);\n    if (!isDomNode.isNodeLike(referenceNode)) {\n      const err2 = new Error(`the following xpath cannot be used because it was not found: ${location.reference}`);\n      if (!callback) {\n        throw err2;\n      } else {\n        callback(err2);\n        return;\n      }\n    }\n    if (location.action === \"append\") {\n      referenceNode.appendChild(signatureDoc);\n    } else if (location.action === \"prepend\") {\n      referenceNode.insertBefore(signatureDoc, referenceNode.firstChild);\n    } else if (location.action === \"before\") {\n      if (referenceNode.parentNode == null) {\n        throw new Error(\"`location.reference` refers to the root node (by default), so we can't insert `before`\");\n      }\n      referenceNode.parentNode.insertBefore(signatureDoc, referenceNode);\n    } else if (location.action === \"after\") {\n      if (referenceNode.parentNode == null) {\n        throw new Error(\"`location.reference` refers to the root node (by default), so we can't insert `after`\");\n      }\n      referenceNode.parentNode.insertBefore(signatureDoc, referenceNode.nextSibling);\n    }\n    this.signatureNode = signatureDoc;\n    const signedInfoNodes = utils.findChildren(this.signatureNode, \"SignedInfo\");\n    if (signedInfoNodes.length === 0) {\n      const err3 = new Error(\"could not find SignedInfo element in the message\");\n      if (!callback) {\n        throw err3;\n      } else {\n        callback(err3);\n        return;\n      }\n    }\n    const signedInfoNode = signedInfoNodes[0];\n    if (typeof callback === \"function\") {\n      // Asynchronous flow\n      this.calculateSignatureValue(doc, (err, signature) => {\n        if (err) {\n          callback(err);\n        } else {\n          this.signatureValue = signature || \"\";\n          signatureDoc.insertBefore(this.createSignature(prefix), signedInfoNode.nextSibling);\n          this.signatureXml = signatureDoc.toString();\n          this.signedXml = doc.toString();\n          callback(null, this);\n        }\n      });\n    } else {\n      // Synchronous flow\n      this.calculateSignatureValue(doc);\n      signatureDoc.insertBefore(this.createSignature(prefix), signedInfoNode.nextSibling);\n      this.signatureXml = signatureDoc.toString();\n      this.signedXml = doc.toString();\n    }\n  }\n  getKeyInfo(prefix) {\n    const currentPrefix = prefix ? `${prefix}:` : \"\";\n    let keyInfoAttrs = \"\";\n    if (this.keyInfoAttributes) {\n      Object.keys(this.keyInfoAttributes).forEach(name => {\n        keyInfoAttrs += ` ${name}=\"${this.keyInfoAttributes[name]}\"`;\n      });\n    }\n    const keyInfoContent = this.getKeyInfoContent({\n      publicCert: this.publicCert,\n      prefix\n    });\n    if (keyInfoAttrs || keyInfoContent) {\n      return `<${currentPrefix}KeyInfo${keyInfoAttrs}>${keyInfoContent}</${currentPrefix}KeyInfo>`;\n    }\n    return \"\";\n  }\n  /**\n   * Generate the Reference nodes (as part of the signature process)\n   *\n   */\n  createReferences(doc, prefix) {\n    let res = \"\";\n    prefix = prefix || \"\";\n    prefix = prefix ? `${prefix}:` : prefix;\n    for (const ref of this.getReferences()) {\n      const nodes = xpath.selectWithResolver(ref.xpath ?? \"\", doc, this.namespaceResolver);\n      if (!utils.isArrayHasLength(nodes)) {\n        throw new Error(`the following xpath cannot be signed because it was not found: ${ref.xpath}`);\n      }\n      for (const node of nodes) {\n        if (ref.isEmptyUri) {\n          res += `<${prefix}Reference URI=\"\">`;\n        } else {\n          const id = this.ensureHasId(node);\n          ref.uri = id;\n          res += `<${prefix}Reference URI=\"#${id}\">`;\n        }\n        res += `<${prefix}Transforms>`;\n        for (const trans of ref.transforms || []) {\n          const transform = this.findCanonicalizationAlgorithm(trans);\n          res += `<${prefix}Transform Algorithm=\"${transform.getAlgorithmName()}\"`;\n          if (utils.isArrayHasLength(ref.inclusiveNamespacesPrefixList)) {\n            res += \">\";\n            res += `<InclusiveNamespaces PrefixList=\"${ref.inclusiveNamespacesPrefixList.join(\" \")}\" xmlns=\"${transform.getAlgorithmName()}\"/>`;\n            res += `</${prefix}Transform>`;\n          } else {\n            res += \" />\";\n          }\n        }\n        const canonXml = this.getCanonReferenceXml(doc, ref, node);\n        const digestAlgorithm = this.findHashAlgorithm(ref.digestAlgorithm);\n        res += `</${prefix}Transforms>` + `<${prefix}DigestMethod Algorithm=\"${digestAlgorithm.getAlgorithmName()}\" />` + `<${prefix}DigestValue>${digestAlgorithm.getHash(canonXml)}</${prefix}DigestValue>` + `</${prefix}Reference>`;\n      }\n    }\n    return res;\n  }\n  getCanonXml(transforms, node, options = {}) {\n    options.defaultNsForPrefix = options.defaultNsForPrefix ?? SignedXml.defaultNsForPrefix;\n    options.signatureNode = this.signatureNode;\n    const canonXml = node.cloneNode(true); // Deep clone\n    let transformedXml = canonXml;\n    transforms.forEach(transformName => {\n      if (isDomNode.isNodeLike(transformedXml)) {\n        // If, after processing, `transformedNode` is a string, we can't do anymore transforms on it\n        const transform = this.findCanonicalizationAlgorithm(transformName);\n        transformedXml = transform.process(transformedXml, options);\n      }\n      //TODO: currently transform.process may return either Node or String value (enveloped transformation returns Node, exclusive-canonicalization returns String).\n      //This either needs to be more explicit in the API, or all should return the same.\n      //exclusive-canonicalization returns String since it builds the Xml by hand. If it had used xmldom it would incorrectly minimize empty tags\n      //to <x/> instead of <x></x> and also incorrectly handle some delicate line break issues.\n      //enveloped transformation returns Node since if it would return String consider this case:\n      //<x xmlns:p='ns'><p:y/></x>\n      //if only y is the node to sign then a string would be <p:y/> without the definition of the p namespace. probably xmldom toString() should have added it.\n    });\n    return transformedXml.toString();\n  }\n  /**\n   * Ensure an element has Id attribute. If not create it with unique value.\n   * Work with both normal and wssecurity Id flavour\n   */\n  ensureHasId(node) {\n    let attr;\n    if (this.idMode === \"wssecurity\") {\n      attr = utils.findAttr(node, \"Id\", \"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\");\n    } else {\n      this.idAttributes.some(idAttribute => {\n        attr = utils.findAttr(node, idAttribute);\n        return !!attr; // This will break the loop as soon as a truthy attr is found.\n      });\n    }\n    if (attr) {\n      return attr.value;\n    }\n    //add the attribute\n    const id = `_${this.id++}`;\n    if (this.idMode === \"wssecurity\") {\n      node.setAttributeNS(\"http://www.w3.org/2000/xmlns/\", \"xmlns:wsu\", \"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\");\n      node.setAttributeNS(\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\", \"wsu:Id\", id);\n    } else {\n      node.setAttribute(\"Id\", id);\n    }\n    return id;\n  }\n  /**\n   * Create the SignedInfo element\n   *\n   */\n  createSignedInfo(doc, prefix) {\n    if (typeof this.canonicalizationAlgorithm !== \"string\") {\n      throw new Error(\"Missing canonicalizationAlgorithm when trying to create signed info for XML\");\n    }\n    const transform = this.findCanonicalizationAlgorithm(this.canonicalizationAlgorithm);\n    const algo = this.findSignatureAlgorithm(this.signatureAlgorithm);\n    let currentPrefix;\n    currentPrefix = prefix || \"\";\n    currentPrefix = currentPrefix ? `${currentPrefix}:` : currentPrefix;\n    let res = `<${currentPrefix}SignedInfo>`;\n    res += `<${currentPrefix}CanonicalizationMethod Algorithm=\"${transform.getAlgorithmName()}\"`;\n    if (utils.isArrayHasLength(this.inclusiveNamespacesPrefixList)) {\n      res += \">\";\n      res += `<InclusiveNamespaces PrefixList=\"${this.inclusiveNamespacesPrefixList.join(\" \")}\" xmlns=\"${transform.getAlgorithmName()}\"/>`;\n      res += `</${currentPrefix}CanonicalizationMethod>`;\n    } else {\n      res += \" />\";\n    }\n    res += `<${currentPrefix}SignatureMethod Algorithm=\"${algo.getAlgorithmName()}\" />`;\n    res += this.createReferences(doc, prefix);\n    res += `</${currentPrefix}SignedInfo>`;\n    return res;\n  }\n  /**\n   * Create the Signature element\n   *\n   */\n  createSignature(prefix) {\n    let xmlNsAttr = \"xmlns\";\n    if (prefix) {\n      xmlNsAttr += `:${prefix}`;\n      prefix += \":\";\n    } else {\n      prefix = \"\";\n    }\n    const signatureValueXml = `<${prefix}SignatureValue>${this.signatureValue}</${prefix}SignatureValue>`;\n    //the canonicalization requires to get a valid xml node.\n    //we need to wrap the info in a dummy signature since it contains the default namespace.\n    const dummySignatureWrapper = `<${prefix}Signature ${xmlNsAttr}=\"http://www.w3.org/2000/09/xmldsig#\">${signatureValueXml}</${prefix}Signature>`;\n    const doc = new xmldom.DOMParser().parseFromString(dummySignatureWrapper);\n    // Because we are using a dummy wrapper hack described above, we know there will be a `firstChild`\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return doc.documentElement.firstChild;\n  }\n  /**\n   * Returns just the signature part, must be called only after {@link computeSignature}\n   *\n   * @returns The signature XML.\n   */\n  getSignatureXml() {\n    return this.signatureXml;\n  }\n  /**\n   * Returns the original xml with Id attributes added on relevant elements (required for validation), must be called only after {@link computeSignature}\n   *\n   * @returns The original XML with IDs.\n   */\n  getOriginalXmlWithIds() {\n    return this.originalXmlWithIds;\n  }\n  /**\n   * Returns the original xml document with the signature in it, must be called only after {@link computeSignature}\n   *\n   * @returns The signed XML.\n   */\n  getSignedXml() {\n    return this.signedXml;\n  }\n}\nexports.SignedXml = SignedXml;\nSignedXml.defaultNsForPrefix = {\n  ds: \"http://www.w3.org/2000/09/xmldsig#\"\n};\nSignedXml.noop = () => null;","map":{"version":3,"names":["xpath","require","xmldom","utils","c14n","execC14n","envelopedSignatures","hashAlgorithms","signatureAlgorithms","isDomNode","SignedXml","constructor","options","signatureAlgorithm","undefined","canonicalizationAlgorithm","inclusiveNamespacesPrefixList","namespaceResolver","lookupNamespaceURI","Error","implicitTransforms","keyInfoAttributes","getKeyInfoContent","getCertFromKeyInfo","id","signedXml","signatureXml","signatureNode","signatureValue","originalXmlWithIds","keyInfo","references","CanonicalizationAlgorithms","C14nCanonicalization","C14nCanonicalizationWithComments","ExclusiveCanonicalization","ExclusiveCanonicalizationWithComments","EnvelopedSignature","HashAlgorithms","Sha1","Sha256","Sha512","SignatureAlgorithms","RsaSha1","RsaSha256","RsaSha512","idMode","idAttribute","privateKey","publicCert","idAttributes","unshift","split","isArrayHasLength","noop","enableHMAC","HmacSha1","prefix","x509Certs","Buffer","isBuffer","toString","publicCertMatches","match","EXTRACT_X509_CERTS","length","map","c","pemToDer","join","cert","select1","isNodeLike","derToPem","textContent","checkSignature","xml","callback","doc","DOMParser","parseFromString","getReferences","every","ref","validateReference","signedInfoCanon","getCanonSignedInfoXml","signer","findSignatureAlgorithm","key","verifySignature","verified","signedInfo","findChildren","ancestorNamespaces","findAncestorNs","c14nOptions","getCanonXml","getCanonReferenceXml","node","Array","isArray","transforms","calculateSignatureValue","getSignature","name","algo","findCanonicalizationAlgorithm","findHashAlgorithm","validateElementAgainstReferences","elemOrXpath","elem","firstElem","assertIsElementNode","uri","substring","attr","elemId","getAttribute","canonXml","hash","digestAlgorithm","digest","getHash","validateDigestValue","digestValue","indexOf","num_elements_for_id","tmp_elemXpath","tmp_elem","select","getValidatedNode","xpathSelector","validationError","selectedValue","findSignatures","nodes","isArrayOfNodes","loadSignature","isAttributeNode","value","reference","loadReference","isTextNode","data","replace","refNode","digestAlgoNode","findAttr","digestAlgo","firstChild","transformsNode","transformsAll","transform","transformAttr","push","inclusiveNamespaces","flatMap","namespace","filter","forEach","t","addReference","isElementNode","isEmptyUri","computeSignature","callbackParam","xmlNsAttr","signatureAttrs","currentPrefix","validActions","attrs","location","existingPrefixes","action","err","Object","keys","createSignedInfo","getKeyInfo","existingPrefixesString","dummySignatureWrapper","nodeXml","signatureDoc","documentElement","referenceNode","err2","appendChild","insertBefore","parentNode","nextSibling","signedInfoNodes","err3","signedInfoNode","signature","createSignature","keyInfoAttrs","keyInfoContent","createReferences","res","selectWithResolver","ensureHasId","trans","getAlgorithmName","defaultNsForPrefix","cloneNode","transformedXml","transformName","process","some","setAttributeNS","setAttribute","signatureValueXml","getSignatureXml","getOriginalXmlWithIds","getSignedXml","exports","ds"],"sources":["/Users/soukaina/Desktop/hotel-reservation-management-soap/frontend-soapt/node_modules/xml-crypto/src/signed-xml.ts"],"sourcesContent":["import type {\n  CanonicalizationAlgorithmType,\n  CanonicalizationOrTransformationAlgorithm,\n  ComputeSignatureOptions,\n  GetKeyInfoContentArgs,\n  HashAlgorithm,\n  HashAlgorithmType,\n  Reference,\n  SignatureAlgorithm,\n  SignatureAlgorithmType,\n  SignedXmlOptions,\n  CanonicalizationOrTransformAlgorithmType,\n  ErrorFirstCallback,\n  CanonicalizationOrTransformationAlgorithmProcessOptions,\n} from \"./types\";\n\nimport * as xpath from \"xpath\";\nimport * as xmldom from \"@xmldom/xmldom\";\nimport * as utils from \"./utils\";\nimport * as c14n from \"./c14n-canonicalization\";\nimport * as execC14n from \"./exclusive-canonicalization\";\nimport * as envelopedSignatures from \"./enveloped-signature\";\nimport * as hashAlgorithms from \"./hash-algorithms\";\nimport * as signatureAlgorithms from \"./signature-algorithms\";\nimport * as crypto from \"crypto\";\nimport * as isDomNode from \"@xmldom/is-dom-node\";\n\nexport class SignedXml {\n  idMode?: \"wssecurity\";\n  idAttributes: string[];\n  /**\n   * A {@link Buffer} or pem encoded {@link String} containing your private key\n   */\n  privateKey?: crypto.KeyLike;\n  publicCert?: crypto.KeyLike;\n  /**\n   * One of the supported signature algorithms.\n   * @see {@link SignatureAlgorithmType}\n   */\n  signatureAlgorithm?: SignatureAlgorithmType = undefined;\n  /**\n   * Rules used to convert an XML document into its canonical form.\n   */\n  canonicalizationAlgorithm?: CanonicalizationAlgorithmType = undefined;\n  /**\n   * It specifies a list of namespace prefixes that should be considered \"inclusive\" during the canonicalization process.\n   */\n  inclusiveNamespacesPrefixList: string[] = [];\n  namespaceResolver: XPathNSResolver = {\n    lookupNamespaceURI: function (/* prefix */) {\n      throw new Error(\"Not implemented\");\n    },\n  };\n  implicitTransforms: ReadonlyArray<CanonicalizationOrTransformAlgorithmType> = [];\n  keyInfoAttributes: { [attrName: string]: string } = {};\n  getKeyInfoContent = SignedXml.getKeyInfoContent;\n  getCertFromKeyInfo = SignedXml.getCertFromKeyInfo;\n\n  // Internal state\n  private id = 0;\n  private signedXml = \"\";\n  private signatureXml = \"\";\n  private signatureNode: Node | null = null;\n  private signatureValue = \"\";\n  private originalXmlWithIds = \"\";\n  private keyInfo: Node | null = null;\n\n  /**\n   * Contains the references that were signed.\n   * @see {@link Reference}\n   */\n  private references: Reference[] = [];\n\n  /**\n   *  To add a new transformation algorithm create a new class that implements the {@link TransformationAlgorithm} interface, and register it here. More info: {@link https://github.com/node-saml/xml-crypto#customizing-algorithms|Customizing Algorithms}\n   */\n  CanonicalizationAlgorithms: Record<\n    CanonicalizationOrTransformAlgorithmType,\n    new () => CanonicalizationOrTransformationAlgorithm\n  > = {\n    \"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\": c14n.C14nCanonicalization,\n    \"http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments\":\n      c14n.C14nCanonicalizationWithComments,\n    \"http://www.w3.org/2001/10/xml-exc-c14n#\": execC14n.ExclusiveCanonicalization,\n    \"http://www.w3.org/2001/10/xml-exc-c14n#WithComments\":\n      execC14n.ExclusiveCanonicalizationWithComments,\n    \"http://www.w3.org/2000/09/xmldsig#enveloped-signature\": envelopedSignatures.EnvelopedSignature,\n  };\n\n  /**\n   * To add a new hash algorithm create a new class that implements the {@link HashAlgorithm} interface, and register it here. More info: {@link https://github.com/node-saml/xml-crypto#customizing-algorithms|Customizing Algorithms}\n   */\n  HashAlgorithms: Record<HashAlgorithmType, new () => HashAlgorithm> = {\n    \"http://www.w3.org/2000/09/xmldsig#sha1\": hashAlgorithms.Sha1,\n    \"http://www.w3.org/2001/04/xmlenc#sha256\": hashAlgorithms.Sha256,\n    \"http://www.w3.org/2001/04/xmlenc#sha512\": hashAlgorithms.Sha512,\n  };\n\n  /**\n   * To add a new signature algorithm create a new class that implements the {@link SignatureAlgorithm} interface, and register it here. More info: {@link https://github.com/node-saml/xml-crypto#customizing-algorithms|Customizing Algorithms}\n   */\n  SignatureAlgorithms: Record<SignatureAlgorithmType, new () => SignatureAlgorithm> = {\n    \"http://www.w3.org/2000/09/xmldsig#rsa-sha1\": signatureAlgorithms.RsaSha1,\n    \"http://www.w3.org/2001/04/xmldsig-more#rsa-sha256\": signatureAlgorithms.RsaSha256,\n    \"http://www.w3.org/2001/04/xmldsig-more#rsa-sha512\": signatureAlgorithms.RsaSha512,\n    // Disabled by default due to key confusion concerns.\n    // 'http://www.w3.org/2000/09/xmldsig#hmac-sha1': SignatureAlgorithms.HmacSha1\n  };\n\n  static defaultNsForPrefix = {\n    ds: \"http://www.w3.org/2000/09/xmldsig#\",\n  };\n\n  static noop = () => null;\n\n  /**\n   * The SignedXml constructor provides an abstraction for sign and verify xml documents. The object is constructed using\n   * @param options {@link SignedXmlOptions}\n   */\n  constructor(options: SignedXmlOptions = {}) {\n    const {\n      idMode,\n      idAttribute,\n      privateKey,\n      publicCert,\n      signatureAlgorithm,\n      canonicalizationAlgorithm,\n      inclusiveNamespacesPrefixList,\n      implicitTransforms,\n      keyInfoAttributes,\n      getKeyInfoContent,\n      getCertFromKeyInfo,\n    } = options;\n\n    // Options\n    this.idMode = idMode;\n    this.idAttributes = [\"Id\", \"ID\", \"id\"];\n    if (idAttribute) {\n      this.idAttributes.unshift(idAttribute);\n    }\n    this.privateKey = privateKey;\n    this.publicCert = publicCert;\n    this.signatureAlgorithm = signatureAlgorithm ?? this.signatureAlgorithm;\n    this.canonicalizationAlgorithm = canonicalizationAlgorithm;\n    if (typeof inclusiveNamespacesPrefixList === \"string\") {\n      this.inclusiveNamespacesPrefixList = inclusiveNamespacesPrefixList.split(\" \");\n    } else if (utils.isArrayHasLength(inclusiveNamespacesPrefixList)) {\n      this.inclusiveNamespacesPrefixList = inclusiveNamespacesPrefixList;\n    }\n    this.implicitTransforms = implicitTransforms ?? this.implicitTransforms;\n    this.keyInfoAttributes = keyInfoAttributes ?? this.keyInfoAttributes;\n    this.getKeyInfoContent = getKeyInfoContent ?? this.getKeyInfoContent;\n    this.getCertFromKeyInfo = getCertFromKeyInfo ?? SignedXml.noop;\n    this.CanonicalizationAlgorithms;\n    this.HashAlgorithms;\n    this.SignatureAlgorithms;\n  }\n\n  /**\n   * Due to key-confusion issues, it's risky to have both hmac\n   * and digital signature algorithms enabled at the same time.\n   * This enables HMAC and disables other signing algorithms.\n   */\n  enableHMAC(): void {\n    this.SignatureAlgorithms = {\n      \"http://www.w3.org/2000/09/xmldsig#hmac-sha1\": signatureAlgorithms.HmacSha1,\n    };\n    this.getKeyInfoContent = SignedXml.noop;\n  }\n\n  /**\n   * Builds the contents of a KeyInfo element as an XML string.\n   *\n   * For example, if the value of the prefix argument is 'foo', then\n   * the resultant XML string will be \"<foo:X509Data></foo:X509Data>\"\n   *\n   * @return an XML string representation of the contents of a KeyInfo element, or `null` if no `KeyInfo` element should be included\n   */\n  static getKeyInfoContent({ publicCert, prefix }: GetKeyInfoContentArgs): string | null {\n    if (publicCert == null) {\n      return null;\n    }\n\n    prefix = prefix ? `${prefix}:` : \"\";\n\n    let x509Certs = \"\";\n    if (Buffer.isBuffer(publicCert)) {\n      publicCert = publicCert.toString(\"latin1\");\n    }\n\n    let publicCertMatches: string[] = [];\n    if (typeof publicCert === \"string\") {\n      publicCertMatches = publicCert.match(utils.EXTRACT_X509_CERTS) || [];\n    }\n\n    if (publicCertMatches.length > 0) {\n      x509Certs = publicCertMatches\n        .map(\n          (c) =>\n            `<${prefix}X509Certificate>${utils\n              .pemToDer(c)\n              .toString(\"base64\")}</${prefix}X509Certificate>`,\n        )\n        .join(\"\");\n    }\n\n    return `<${prefix}X509Data>${x509Certs}</${prefix}X509Data>`;\n  }\n\n  /**\n   * Returns the value of the signing certificate based on the contents of the\n   * specified KeyInfo.\n   *\n   * @param keyInfo KeyInfo element (@see https://www.w3.org/TR/2008/REC-xmldsig-core-20080610/#sec-X509Data)\n   * @return the signing certificate as a string in PEM format\n   */\n  static getCertFromKeyInfo(keyInfo?: Node | null): string | null {\n    if (keyInfo != null) {\n      const cert = xpath.select1(\".//*[local-name(.)='X509Certificate']\", keyInfo);\n      if (isDomNode.isNodeLike(cert)) {\n        return utils.derToPem(cert.textContent ?? \"\", \"CERTIFICATE\");\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Validates the signature of the provided XML document synchronously using the configured key info provider.\n   *\n   * @param xml The XML document containing the signature to be validated.\n   * @returns `true` if the signature is valid\n   * @throws Error if no key info resolver is provided.\n   */\n  checkSignature(xml: string): boolean;\n  /**\n   * Validates the signature of the provided XML document synchronously using the configured key info provider.\n   *\n   * @param xml The XML document containing the signature to be validated.\n   * @param callback Callback function to handle the validation result asynchronously.\n   * @throws Error if the last parameter is provided and is not a function, or if no key info resolver is provided.\n   */\n  checkSignature(xml: string, callback: (error: Error | null, isValid?: boolean) => void): void;\n  checkSignature(\n    xml: string,\n    callback?: (error: Error | null, isValid?: boolean) => void,\n  ): unknown {\n    if (callback != null && typeof callback !== \"function\") {\n      throw new Error(\"Last parameter must be a callback function\");\n    }\n\n    this.signedXml = xml;\n\n    const doc = new xmldom.DOMParser().parseFromString(xml);\n\n    if (!this.getReferences().every((ref) => this.validateReference(ref, doc))) {\n      if (callback) {\n        callback(new Error(\"Could not validate all references\"));\n        return;\n      }\n\n      return false;\n    }\n\n    const signedInfoCanon = this.getCanonSignedInfoXml(doc);\n    const signer = this.findSignatureAlgorithm(this.signatureAlgorithm);\n    const key = this.getCertFromKeyInfo(this.keyInfo) || this.publicCert || this.privateKey;\n    if (key == null) {\n      throw new Error(\"KeyInfo or publicCert or privateKey is required to validate signature\");\n    }\n    if (callback) {\n      signer.verifySignature(signedInfoCanon, key, this.signatureValue, callback);\n    } else {\n      const verified = signer.verifySignature(signedInfoCanon, key, this.signatureValue);\n\n      if (verified === false) {\n        throw new Error(\n          `invalid signature: the signature value ${this.signatureValue} is incorrect`,\n        );\n      }\n\n      return true;\n    }\n  }\n\n  private getCanonSignedInfoXml(doc: Document) {\n    if (this.signatureNode == null) {\n      throw new Error(\"No signature found.\");\n    }\n    if (typeof this.canonicalizationAlgorithm !== \"string\") {\n      throw new Error(\"Missing canonicalizationAlgorithm when trying to get signed info for XML\");\n    }\n\n    const signedInfo = utils.findChildren(this.signatureNode, \"SignedInfo\");\n    if (signedInfo.length === 0) {\n      throw new Error(\"could not find SignedInfo element in the message\");\n    }\n\n    if (\n      this.canonicalizationAlgorithm === \"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\" ||\n      this.canonicalizationAlgorithm ===\n        \"http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments\"\n    ) {\n      if (!doc || typeof doc !== \"object\") {\n        throw new Error(\n          \"When canonicalization method is non-exclusive, whole xml dom must be provided as an argument\",\n        );\n      }\n    }\n\n    /**\n     * Search for ancestor namespaces before canonicalization.\n     */\n    const ancestorNamespaces = utils.findAncestorNs(doc, \"//*[local-name()='SignedInfo']\");\n\n    const c14nOptions = {\n      ancestorNamespaces: ancestorNamespaces,\n    };\n\n    return this.getCanonXml([this.canonicalizationAlgorithm], signedInfo[0], c14nOptions);\n  }\n\n  private getCanonReferenceXml(doc: Document, ref: Reference, node: Node) {\n    /**\n     * Search for ancestor namespaces before canonicalization.\n     */\n    if (Array.isArray(ref.transforms)) {\n      ref.ancestorNamespaces = utils.findAncestorNs(doc, ref.xpath, this.namespaceResolver);\n    }\n\n    const c14nOptions = {\n      inclusiveNamespacesPrefixList: ref.inclusiveNamespacesPrefixList,\n      ancestorNamespaces: ref.ancestorNamespaces,\n    };\n\n    return this.getCanonXml(ref.transforms, node, c14nOptions);\n  }\n\n  private calculateSignatureValue(doc: Document, callback?: ErrorFirstCallback<string>) {\n    const signedInfoCanon = this.getCanonSignedInfoXml(doc);\n    const signer = this.findSignatureAlgorithm(this.signatureAlgorithm);\n    if (this.privateKey == null) {\n      throw new Error(\"Private key is required to compute signature\");\n    }\n    if (typeof callback === \"function\") {\n      signer.getSignature(signedInfoCanon, this.privateKey, callback);\n    } else {\n      this.signatureValue = signer.getSignature(signedInfoCanon, this.privateKey);\n    }\n  }\n\n  private findSignatureAlgorithm(name?: SignatureAlgorithmType) {\n    if (name == null) {\n      throw new Error(\"signatureAlgorithm is required\");\n    }\n    const algo = this.SignatureAlgorithms[name];\n    if (algo) {\n      return new algo();\n    } else {\n      throw new Error(`signature algorithm '${name}' is not supported`);\n    }\n  }\n\n  private findCanonicalizationAlgorithm(name: CanonicalizationOrTransformAlgorithmType) {\n    if (name != null) {\n      const algo = this.CanonicalizationAlgorithms[name];\n      if (algo) {\n        return new algo();\n      }\n    }\n\n    throw new Error(`canonicalization algorithm '${name}' is not supported`);\n  }\n\n  private findHashAlgorithm(name: HashAlgorithmType) {\n    const algo = this.HashAlgorithms[name];\n    if (algo) {\n      return new algo();\n    } else {\n      throw new Error(`hash algorithm '${name}' is not supported`);\n    }\n  }\n\n  validateElementAgainstReferences(elemOrXpath: Element | string, doc: Document): Reference {\n    let elem: Element;\n    if (typeof elemOrXpath === \"string\") {\n      const firstElem = xpath.select1(elemOrXpath, doc);\n      isDomNode.assertIsElementNode(firstElem);\n      elem = firstElem;\n    } else {\n      elem = elemOrXpath;\n    }\n\n    for (const ref of this.getReferences()) {\n      const uri = ref.uri?.[0] === \"#\" ? ref.uri.substring(1) : ref.uri;\n\n      for (const attr of this.idAttributes) {\n        const elemId = elem.getAttribute(attr);\n        if (uri === elemId) {\n          ref.xpath = `//*[@*[local-name(.)='${attr}']='${uri}']`;\n          break; // found the correct element, no need to check further\n        }\n      }\n\n      const canonXml = this.getCanonReferenceXml(doc, ref, elem);\n      const hash = this.findHashAlgorithm(ref.digestAlgorithm);\n      const digest = hash.getHash(canonXml);\n\n      if (utils.validateDigestValue(digest, ref.digestValue)) {\n        return ref;\n      }\n    }\n\n    throw new Error(\"No references passed validation\");\n  }\n\n  private validateReference(ref: Reference, doc: Document) {\n    const uri = ref.uri?.[0] === \"#\" ? ref.uri.substring(1) : ref.uri;\n    let elem: xpath.SelectSingleReturnType = null;\n\n    if (uri === \"\") {\n      elem = xpath.select1(\"//*\", doc);\n    } else if (uri?.indexOf(\"'\") !== -1) {\n      // xpath injection\n      throw new Error(\"Cannot validate a uri with quotes inside it\");\n    } else {\n      let num_elements_for_id = 0;\n      for (const attr of this.idAttributes) {\n        const tmp_elemXpath = `//*[@*[local-name(.)='${attr}']='${uri}']`;\n        const tmp_elem = xpath.select(tmp_elemXpath, doc);\n        if (utils.isArrayHasLength(tmp_elem)) {\n          num_elements_for_id += tmp_elem.length;\n\n          if (num_elements_for_id > 1) {\n            throw new Error(\n              \"Cannot validate a document which contains multiple elements with the \" +\n                \"same value for the ID / Id / Id attributes, in order to prevent \" +\n                \"signature wrapping attack.\",\n            );\n          }\n\n          elem = tmp_elem[0];\n          ref.xpath = tmp_elemXpath;\n        }\n      }\n    }\n\n    ref.getValidatedNode = (xpathSelector?: string) => {\n      xpathSelector = xpathSelector || ref.xpath;\n      if (typeof xpathSelector !== \"string\" || ref.validationError != null) {\n        return null;\n      }\n      const selectedValue = xpath.select1(xpathSelector, doc);\n      return isDomNode.isNodeLike(selectedValue) ? selectedValue : null;\n    };\n\n    if (!isDomNode.isNodeLike(elem)) {\n      const validationError = new Error(\n        `invalid signature: the signature references an element with uri ${ref.uri} but could not find such element in the xml`,\n      );\n      ref.validationError = validationError;\n      return false;\n    }\n\n    const canonXml = this.getCanonReferenceXml(doc, ref, elem);\n    const hash = this.findHashAlgorithm(ref.digestAlgorithm);\n    const digest = hash.getHash(canonXml);\n\n    if (!utils.validateDigestValue(digest, ref.digestValue)) {\n      const validationError = new Error(\n        `invalid signature: for uri ${ref.uri} calculated digest is ${digest} but the xml to validate supplies digest ${ref.digestValue}`,\n      );\n      ref.validationError = validationError;\n\n      return false;\n    }\n\n    return true;\n  }\n\n  findSignatures(doc: Node): Node[] {\n    const nodes = xpath.select(\n      \"//*[local-name(.)='Signature' and namespace-uri(.)='http://www.w3.org/2000/09/xmldsig#']\",\n      doc,\n    );\n\n    return isDomNode.isArrayOfNodes(nodes) ? nodes : [];\n  }\n\n  /**\n   * Loads the signature information from the provided XML node or string.\n   *\n   * @param signatureNode The XML node or string representing the signature.\n   */\n  loadSignature(signatureNode: Node | string): void {\n    if (typeof signatureNode === \"string\") {\n      this.signatureNode = signatureNode = new xmldom.DOMParser().parseFromString(signatureNode);\n    } else {\n      this.signatureNode = signatureNode;\n    }\n\n    this.signatureXml = signatureNode.toString();\n\n    const node = xpath.select1(\n      \".//*[local-name(.)='CanonicalizationMethod']/@Algorithm\",\n      signatureNode,\n    );\n    if (!isDomNode.isNodeLike(node)) {\n      throw new Error(\"could not find CanonicalizationMethod/@Algorithm element\");\n    }\n\n    if (isDomNode.isAttributeNode(node)) {\n      this.canonicalizationAlgorithm = node.value as CanonicalizationAlgorithmType;\n    }\n\n    const signatureAlgorithm = xpath.select1(\n      \".//*[local-name(.)='SignatureMethod']/@Algorithm\",\n      signatureNode,\n    );\n\n    if (isDomNode.isAttributeNode(signatureAlgorithm)) {\n      this.signatureAlgorithm = signatureAlgorithm.value as SignatureAlgorithmType;\n    }\n\n    this.references = [];\n    const references = xpath.select(\n      \".//*[local-name(.)='SignedInfo']/*[local-name(.)='Reference']\",\n      signatureNode,\n    );\n    if (!utils.isArrayHasLength(references)) {\n      throw new Error(\"could not find any Reference elements\");\n    }\n\n    for (const reference of references) {\n      this.loadReference(reference);\n    }\n\n    const signatureValue = xpath.select1(\n      \".//*[local-name(.)='SignatureValue']/text()\",\n      signatureNode,\n    );\n\n    if (isDomNode.isTextNode(signatureValue)) {\n      this.signatureValue = signatureValue.data.replace(/\\r?\\n/g, \"\");\n    }\n\n    const keyInfo = xpath.select1(\".//*[local-name(.)='KeyInfo']\", signatureNode);\n\n    if (isDomNode.isNodeLike(keyInfo)) {\n      this.keyInfo = keyInfo;\n    }\n  }\n\n  /**\n   * Load the reference xml node to a model\n   *\n   */\n  private loadReference(refNode: Node) {\n    let nodes = utils.findChildren(refNode, \"DigestMethod\");\n    if (nodes.length === 0) {\n      throw new Error(`could not find DigestMethod in reference ${refNode.toString()}`);\n    }\n    const digestAlgoNode = nodes[0];\n\n    const attr = utils.findAttr(digestAlgoNode, \"Algorithm\");\n    if (!attr) {\n      throw new Error(`could not find Algorithm attribute in node ${digestAlgoNode.toString()}`);\n    }\n    const digestAlgo = attr.value;\n\n    nodes = utils.findChildren(refNode, \"DigestValue\");\n    if (nodes.length === 0) {\n      throw new Error(`could not find DigestValue node in reference ${refNode.toString()}`);\n    }\n    const firstChild = nodes[0].firstChild;\n    if (!firstChild || !(\"data\" in firstChild)) {\n      throw new Error(`could not find the value of DigestValue in ${nodes[0].toString()}`);\n    }\n    const digestValue = firstChild.data;\n\n    const transforms: string[] = [];\n    let inclusiveNamespacesPrefixList: string[] = [];\n    nodes = utils.findChildren(refNode, \"Transforms\");\n    if (nodes.length !== 0) {\n      const transformsNode = nodes[0];\n      const transformsAll = utils.findChildren(transformsNode, \"Transform\");\n      for (const transform of transformsAll) {\n        const transformAttr = utils.findAttr(transform, \"Algorithm\");\n\n        if (transformAttr) {\n          transforms.push(transformAttr.value);\n        }\n      }\n\n      // This is a little strange, we are looking for children of the last child of `transformsNode`\n      const inclusiveNamespaces = utils.findChildren(\n        transformsAll[transformsAll.length - 1],\n        \"InclusiveNamespaces\",\n      );\n      if (utils.isArrayHasLength(inclusiveNamespaces)) {\n        // Should really only be one prefix list, but maybe there's some circumstances where more than one to let's handle it\n        inclusiveNamespacesPrefixList = inclusiveNamespaces\n          .flatMap((namespace) => (namespace.getAttribute(\"PrefixList\") ?? \"\").split(\" \"))\n          .filter((value) => value.length > 0);\n      }\n    }\n\n    if (utils.isArrayHasLength(this.implicitTransforms)) {\n      this.implicitTransforms.forEach(function (t) {\n        transforms.push(t);\n      });\n    }\n\n    /**\n     * DigestMethods take an octet stream rather than a node set. If the output of the last transform is a node set, we\n     * need to canonicalize the node set to an octet stream using non-exclusive canonicalization. If there are no\n     * transforms, we need to canonicalize because URI dereferencing for a same-document reference will return a node-set.\n     * @see:\n     * https://www.w3.org/TR/xmldsig-core1/#sec-DigestMethod\n     * https://www.w3.org/TR/xmldsig-core1/#sec-ReferenceProcessingModel\n     * https://www.w3.org/TR/xmldsig-core1/#sec-Same-Document\n     */\n    if (\n      transforms.length === 0 ||\n      transforms[transforms.length - 1] === \"http://www.w3.org/2000/09/xmldsig#enveloped-signature\"\n    ) {\n      transforms.push(\"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\");\n    }\n\n    this.addReference({\n      transforms,\n      digestAlgorithm: digestAlgo,\n      uri: isDomNode.isElementNode(refNode) ? utils.findAttr(refNode, \"URI\")?.value : undefined,\n      digestValue,\n      inclusiveNamespacesPrefixList,\n      isEmptyUri: false,\n    });\n  }\n\n  /**\n   * Adds a reference to the signature.\n   *\n   * @param xpath The XPath expression to select the XML nodes to be referenced.\n   * @param transforms An array of transform algorithms to be applied to the selected nodes.\n   * @param digestAlgorithm The digest algorithm to use for computing the digest value.\n   * @param uri The URI identifier for the reference. If empty, an empty URI will be used.\n   * @param digestValue The expected digest value for the reference.\n   * @param inclusiveNamespacesPrefixList The prefix list for inclusive namespace canonicalization.\n   * @param isEmptyUri Indicates whether the URI is empty. Defaults to `false`.\n   */\n  addReference({\n    xpath,\n    transforms,\n    digestAlgorithm,\n    uri = \"\",\n    digestValue,\n    inclusiveNamespacesPrefixList = [],\n    isEmptyUri = false,\n  }: Partial<Reference> & Pick<Reference, \"xpath\">): void {\n    if (digestAlgorithm == null) {\n      throw new Error(\"digestAlgorithm is required\");\n    }\n\n    if (!utils.isArrayHasLength(transforms)) {\n      throw new Error(\"transforms must contain at least one transform algorithm\");\n    }\n\n    this.references.push({\n      xpath,\n      transforms,\n      digestAlgorithm,\n      uri,\n      digestValue,\n      inclusiveNamespacesPrefixList,\n      isEmptyUri,\n      getValidatedNode: () => {\n        throw new Error(\n          \"Reference has not been validated yet; Did you call `sig.checkSignature()`?\",\n        );\n      },\n    });\n  }\n\n  getReferences(): Reference[] {\n    return this.references;\n  }\n\n  /**\n   * Compute the signature of the given XML (using the already defined settings).\n   *\n   * @param xml The XML to compute the signature for.\n   * @param callback A callback function to handle the signature computation asynchronously.\n   * @returns void\n   * @throws TypeError If the xml can not be parsed.\n   */\n  computeSignature(xml: string): void;\n\n  /**\n   * Compute the signature of the given XML (using the already defined settings).\n   *\n   * @param xml The XML to compute the signature for.\n   * @param callback A callback function to handle the signature computation asynchronously.\n   * @returns void\n   * @throws TypeError If the xml can not be parsed.\n   */\n  computeSignature(xml: string, callback: ErrorFirstCallback<SignedXml>): void;\n\n  /**\n   * Compute the signature of the given XML (using the already defined settings).\n   *\n   * @param xml The XML to compute the signature for.\n   * @param opts An object containing options for the signature computation.\n   * @returns If no callback is provided, returns `this` (the instance of SignedXml).\n   * @throws TypeError If the xml can not be parsed, or Error if there were invalid options passed.\n   */\n  computeSignature(xml: string, options: ComputeSignatureOptions): void;\n\n  /**\n   * Compute the signature of the given XML (using the already defined settings).\n   *\n   * @param xml The XML to compute the signature for.\n   * @param opts An object containing options for the signature computation.\n   * @param callback A callback function to handle the signature computation asynchronously.\n   * @returns void\n   * @throws TypeError If the xml can not be parsed, or Error if there were invalid options passed.\n   */\n  computeSignature(\n    xml: string,\n    options: ComputeSignatureOptions,\n    callback: ErrorFirstCallback<SignedXml>,\n  ): void;\n\n  computeSignature(\n    xml: string,\n    options?: ComputeSignatureOptions | ErrorFirstCallback<SignedXml>,\n    callbackParam?: ErrorFirstCallback<SignedXml>,\n  ): void {\n    let callback: ErrorFirstCallback<SignedXml>;\n    if (typeof options === \"function\" && callbackParam == null) {\n      callback = options as ErrorFirstCallback<SignedXml>;\n      options = {} as ComputeSignatureOptions;\n    } else {\n      callback = callbackParam as ErrorFirstCallback<SignedXml>;\n      options = (options ?? {}) as ComputeSignatureOptions;\n    }\n\n    const doc = new xmldom.DOMParser().parseFromString(xml);\n    let xmlNsAttr = \"xmlns\";\n    const signatureAttrs: string[] = [];\n    let currentPrefix: string;\n\n    const validActions = [\"append\", \"prepend\", \"before\", \"after\"];\n\n    const prefix = options.prefix;\n    const attrs = options.attrs || {};\n    const location = options.location || {};\n    const existingPrefixes = options.existingPrefixes || {};\n\n    this.namespaceResolver = {\n      lookupNamespaceURI: function (prefix) {\n        return prefix ? existingPrefixes[prefix] : null;\n      },\n    };\n\n    // defaults to the root node\n    location.reference = location.reference || \"/*\";\n    // defaults to append action\n    location.action = location.action || \"append\";\n\n    if (validActions.indexOf(location.action) === -1) {\n      const err = new Error(\n        `location.action option has an invalid action: ${\n          location.action\n        }, must be any of the following values: ${validActions.join(\", \")}`,\n      );\n      if (!callback) {\n        throw err;\n      } else {\n        callback(err);\n        return;\n      }\n    }\n\n    // automatic insertion of `:`\n    if (prefix) {\n      xmlNsAttr += `:${prefix}`;\n      currentPrefix = `${prefix}:`;\n    } else {\n      currentPrefix = \"\";\n    }\n\n    Object.keys(attrs).forEach(function (name) {\n      if (name !== \"xmlns\" && name !== xmlNsAttr) {\n        signatureAttrs.push(`${name}=\"${attrs[name]}\"`);\n      }\n    });\n\n    // add the xml namespace attribute\n    signatureAttrs.push(`${xmlNsAttr}=\"http://www.w3.org/2000/09/xmldsig#\"`);\n\n    let signatureXml = `<${currentPrefix}Signature ${signatureAttrs.join(\" \")}>`;\n\n    signatureXml += this.createSignedInfo(doc, prefix);\n    signatureXml += this.getKeyInfo(prefix);\n    signatureXml += `</${currentPrefix}Signature>`;\n\n    this.originalXmlWithIds = doc.toString();\n\n    let existingPrefixesString = \"\";\n    Object.keys(existingPrefixes).forEach(function (key) {\n      existingPrefixesString += `xmlns:${key}=\"${existingPrefixes[key]}\" `;\n    });\n\n    // A trick to remove the namespaces that already exist in the xml\n    // This only works if the prefix and namespace match with those in the xml\n    const dummySignatureWrapper = `<Dummy ${existingPrefixesString}>${signatureXml}</Dummy>`;\n    const nodeXml = new xmldom.DOMParser().parseFromString(dummySignatureWrapper);\n\n    // Because we are using a dummy wrapper hack described above, we know there will be a `firstChild`\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const signatureDoc = nodeXml.documentElement.firstChild!;\n\n    const referenceNode = xpath.select1(location.reference, doc);\n\n    if (!isDomNode.isNodeLike(referenceNode)) {\n      const err2 = new Error(\n        `the following xpath cannot be used because it was not found: ${location.reference}`,\n      );\n      if (!callback) {\n        throw err2;\n      } else {\n        callback(err2);\n        return;\n      }\n    }\n\n    if (location.action === \"append\") {\n      referenceNode.appendChild(signatureDoc);\n    } else if (location.action === \"prepend\") {\n      referenceNode.insertBefore(signatureDoc, referenceNode.firstChild);\n    } else if (location.action === \"before\") {\n      if (referenceNode.parentNode == null) {\n        throw new Error(\n          \"`location.reference` refers to the root node (by default), so we can't insert `before`\",\n        );\n      }\n      referenceNode.parentNode.insertBefore(signatureDoc, referenceNode);\n    } else if (location.action === \"after\") {\n      if (referenceNode.parentNode == null) {\n        throw new Error(\n          \"`location.reference` refers to the root node (by default), so we can't insert `after`\",\n        );\n      }\n      referenceNode.parentNode.insertBefore(signatureDoc, referenceNode.nextSibling);\n    }\n\n    this.signatureNode = signatureDoc;\n    const signedInfoNodes = utils.findChildren(this.signatureNode, \"SignedInfo\");\n    if (signedInfoNodes.length === 0) {\n      const err3 = new Error(\"could not find SignedInfo element in the message\");\n      if (!callback) {\n        throw err3;\n      } else {\n        callback(err3);\n        return;\n      }\n    }\n    const signedInfoNode = signedInfoNodes[0];\n\n    if (typeof callback === \"function\") {\n      // Asynchronous flow\n      this.calculateSignatureValue(doc, (err, signature) => {\n        if (err) {\n          callback(err);\n        } else {\n          this.signatureValue = signature || \"\";\n          signatureDoc.insertBefore(this.createSignature(prefix), signedInfoNode.nextSibling);\n          this.signatureXml = signatureDoc.toString();\n          this.signedXml = doc.toString();\n          callback(null, this);\n        }\n      });\n    } else {\n      // Synchronous flow\n      this.calculateSignatureValue(doc);\n      signatureDoc.insertBefore(this.createSignature(prefix), signedInfoNode.nextSibling);\n      this.signatureXml = signatureDoc.toString();\n      this.signedXml = doc.toString();\n    }\n  }\n\n  private getKeyInfo(prefix) {\n    const currentPrefix = prefix ? `${prefix}:` : \"\";\n\n    let keyInfoAttrs = \"\";\n    if (this.keyInfoAttributes) {\n      Object.keys(this.keyInfoAttributes).forEach((name) => {\n        keyInfoAttrs += ` ${name}=\"${this.keyInfoAttributes[name]}\"`;\n      });\n    }\n\n    const keyInfoContent = this.getKeyInfoContent({ publicCert: this.publicCert, prefix });\n    if (keyInfoAttrs || keyInfoContent) {\n      return `<${currentPrefix}KeyInfo${keyInfoAttrs}>${keyInfoContent}</${currentPrefix}KeyInfo>`;\n    }\n\n    return \"\";\n  }\n\n  /**\n   * Generate the Reference nodes (as part of the signature process)\n   *\n   */\n  private createReferences(doc, prefix) {\n    let res = \"\";\n\n    prefix = prefix || \"\";\n    prefix = prefix ? `${prefix}:` : prefix;\n\n    for (const ref of this.getReferences()) {\n      const nodes = xpath.selectWithResolver(ref.xpath ?? \"\", doc, this.namespaceResolver);\n\n      if (!utils.isArrayHasLength(nodes)) {\n        throw new Error(\n          `the following xpath cannot be signed because it was not found: ${ref.xpath}`,\n        );\n      }\n\n      for (const node of nodes) {\n        if (ref.isEmptyUri) {\n          res += `<${prefix}Reference URI=\"\">`;\n        } else {\n          const id = this.ensureHasId(node);\n          ref.uri = id;\n          res += `<${prefix}Reference URI=\"#${id}\">`;\n        }\n        res += `<${prefix}Transforms>`;\n        for (const trans of ref.transforms || []) {\n          const transform = this.findCanonicalizationAlgorithm(trans);\n          res += `<${prefix}Transform Algorithm=\"${transform.getAlgorithmName()}\"`;\n          if (utils.isArrayHasLength(ref.inclusiveNamespacesPrefixList)) {\n            res += \">\";\n            res += `<InclusiveNamespaces PrefixList=\"${ref.inclusiveNamespacesPrefixList.join(\n              \" \",\n            )}\" xmlns=\"${transform.getAlgorithmName()}\"/>`;\n            res += `</${prefix}Transform>`;\n          } else {\n            res += \" />\";\n          }\n        }\n\n        const canonXml = this.getCanonReferenceXml(doc, ref, node);\n\n        const digestAlgorithm = this.findHashAlgorithm(ref.digestAlgorithm);\n        res +=\n          `</${prefix}Transforms>` +\n          `<${prefix}DigestMethod Algorithm=\"${digestAlgorithm.getAlgorithmName()}\" />` +\n          `<${prefix}DigestValue>${digestAlgorithm.getHash(canonXml)}</${prefix}DigestValue>` +\n          `</${prefix}Reference>`;\n      }\n    }\n\n    return res;\n  }\n\n  getCanonXml(\n    transforms: Reference[\"transforms\"],\n    node: Node,\n    options: CanonicalizationOrTransformationAlgorithmProcessOptions = {},\n  ) {\n    options.defaultNsForPrefix = options.defaultNsForPrefix ?? SignedXml.defaultNsForPrefix;\n    options.signatureNode = this.signatureNode;\n\n    const canonXml = node.cloneNode(true); // Deep clone\n    let transformedXml: Node | string = canonXml;\n\n    transforms.forEach((transformName) => {\n      if (isDomNode.isNodeLike(transformedXml)) {\n        // If, after processing, `transformedNode` is a string, we can't do anymore transforms on it\n        const transform = this.findCanonicalizationAlgorithm(transformName);\n        transformedXml = transform.process(transformedXml, options);\n      }\n      //TODO: currently transform.process may return either Node or String value (enveloped transformation returns Node, exclusive-canonicalization returns String).\n      //This either needs to be more explicit in the API, or all should return the same.\n      //exclusive-canonicalization returns String since it builds the Xml by hand. If it had used xmldom it would incorrectly minimize empty tags\n      //to <x/> instead of <x></x> and also incorrectly handle some delicate line break issues.\n      //enveloped transformation returns Node since if it would return String consider this case:\n      //<x xmlns:p='ns'><p:y/></x>\n      //if only y is the node to sign then a string would be <p:y/> without the definition of the p namespace. probably xmldom toString() should have added it.\n    });\n\n    return transformedXml.toString();\n  }\n\n  /**\n   * Ensure an element has Id attribute. If not create it with unique value.\n   * Work with both normal and wssecurity Id flavour\n   */\n  private ensureHasId(node) {\n    let attr;\n\n    if (this.idMode === \"wssecurity\") {\n      attr = utils.findAttr(\n        node,\n        \"Id\",\n        \"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\",\n      );\n    } else {\n      this.idAttributes.some((idAttribute) => {\n        attr = utils.findAttr(node, idAttribute);\n        return !!attr; // This will break the loop as soon as a truthy attr is found.\n      });\n    }\n\n    if (attr) {\n      return attr.value;\n    }\n\n    //add the attribute\n    const id = `_${this.id++}`;\n\n    if (this.idMode === \"wssecurity\") {\n      node.setAttributeNS(\n        \"http://www.w3.org/2000/xmlns/\",\n        \"xmlns:wsu\",\n        \"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\",\n      );\n      node.setAttributeNS(\n        \"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\",\n        \"wsu:Id\",\n        id,\n      );\n    } else {\n      node.setAttribute(\"Id\", id);\n    }\n\n    return id;\n  }\n\n  /**\n   * Create the SignedInfo element\n   *\n   */\n  private createSignedInfo(doc, prefix) {\n    if (typeof this.canonicalizationAlgorithm !== \"string\") {\n      throw new Error(\n        \"Missing canonicalizationAlgorithm when trying to create signed info for XML\",\n      );\n    }\n    const transform = this.findCanonicalizationAlgorithm(this.canonicalizationAlgorithm);\n    const algo = this.findSignatureAlgorithm(this.signatureAlgorithm);\n    let currentPrefix;\n\n    currentPrefix = prefix || \"\";\n    currentPrefix = currentPrefix ? `${currentPrefix}:` : currentPrefix;\n\n    let res = `<${currentPrefix}SignedInfo>`;\n    res += `<${currentPrefix}CanonicalizationMethod Algorithm=\"${transform.getAlgorithmName()}\"`;\n    if (utils.isArrayHasLength(this.inclusiveNamespacesPrefixList)) {\n      res += \">\";\n      res += `<InclusiveNamespaces PrefixList=\"${this.inclusiveNamespacesPrefixList.join(\n        \" \",\n      )}\" xmlns=\"${transform.getAlgorithmName()}\"/>`;\n      res += `</${currentPrefix}CanonicalizationMethod>`;\n    } else {\n      res += \" />\";\n    }\n    res += `<${currentPrefix}SignatureMethod Algorithm=\"${algo.getAlgorithmName()}\" />`;\n\n    res += this.createReferences(doc, prefix);\n    res += `</${currentPrefix}SignedInfo>`;\n    return res;\n  }\n\n  /**\n   * Create the Signature element\n   *\n   */\n  private createSignature(prefix?: string) {\n    let xmlNsAttr = \"xmlns\";\n\n    if (prefix) {\n      xmlNsAttr += `:${prefix}`;\n      prefix += \":\";\n    } else {\n      prefix = \"\";\n    }\n\n    const signatureValueXml = `<${prefix}SignatureValue>${this.signatureValue}</${prefix}SignatureValue>`;\n    //the canonicalization requires to get a valid xml node.\n    //we need to wrap the info in a dummy signature since it contains the default namespace.\n    const dummySignatureWrapper = `<${prefix}Signature ${xmlNsAttr}=\"http://www.w3.org/2000/09/xmldsig#\">${signatureValueXml}</${prefix}Signature>`;\n\n    const doc = new xmldom.DOMParser().parseFromString(dummySignatureWrapper);\n\n    // Because we are using a dummy wrapper hack described above, we know there will be a `firstChild`\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return doc.documentElement.firstChild!;\n  }\n\n  /**\n   * Returns just the signature part, must be called only after {@link computeSignature}\n   *\n   * @returns The signature XML.\n   */\n  getSignatureXml(): string {\n    return this.signatureXml;\n  }\n\n  /**\n   * Returns the original xml with Id attributes added on relevant elements (required for validation), must be called only after {@link computeSignature}\n   *\n   * @returns The original XML with IDs.\n   */\n  getOriginalXmlWithIds(): string {\n    return this.originalXmlWithIds;\n  }\n\n  /**\n   * Returns the original xml document with the signature in it, must be called only after {@link computeSignature}\n   *\n   * @returns The signed XML.\n   */\n  getSignedXml(): string {\n    return this.signedXml;\n  }\n}\n"],"mappings":";;;;;;AAgBA,MAAAA,KAAA,GAAAC,OAAA;AACA,MAAAC,MAAA,GAAAD,OAAA;AACA,MAAAE,KAAA,GAAAF,OAAA;AACA,MAAAG,IAAA,GAAAH,OAAA;AACA,MAAAI,QAAA,GAAAJ,OAAA;AACA,MAAAK,mBAAA,GAAAL,OAAA;AACA,MAAAM,cAAA,GAAAN,OAAA;AACA,MAAAO,mBAAA,GAAAP,OAAA;AAEA,MAAAQ,SAAA,GAAAR,OAAA;AAEA,MAAaS,SAAS;EAwFpB;;;;EAIAC,YAAYC,OAAA,GAA4B,EAAE;IApF1C;;;;IAIA,KAAAC,kBAAkB,GAA4BC,SAAS;IACvD;;;IAGA,KAAAC,yBAAyB,GAAmCD,SAAS;IACrE;;;IAGA,KAAAE,6BAA6B,GAAa,EAAE;IAC5C,KAAAC,iBAAiB,GAAoB;MACnCC,kBAAkB,EAAE,SAAUA;MAAA,GAAY;QACxC,MAAM,IAAIC,KAAK,CAAC,iBAAiB,CAAC;MACpC;KACD;IACD,KAAAC,kBAAkB,GAA4D,EAAE;IAChF,KAAAC,iBAAiB,GAAmC,EAAE;IACtD,KAAAC,iBAAiB,GAAGZ,SAAS,CAACY,iBAAiB;IAC/C,KAAAC,kBAAkB,GAAGb,SAAS,CAACa,kBAAkB;IAEjD;IACQ,KAAAC,EAAE,GAAG,CAAC;IACN,KAAAC,SAAS,GAAG,EAAE;IACd,KAAAC,YAAY,GAAG,EAAE;IACjB,KAAAC,aAAa,GAAgB,IAAI;IACjC,KAAAC,cAAc,GAAG,EAAE;IACnB,KAAAC,kBAAkB,GAAG,EAAE;IACvB,KAAAC,OAAO,GAAgB,IAAI;IAEnC;;;;IAIQ,KAAAC,UAAU,GAAgB,EAAE;IAEpC;;;IAGA,KAAAC,0BAA0B,GAGtB;MACF,iDAAiD,EAAE5B,IAAI,CAAC6B,oBAAoB;MAC5E,8DAA8D,EAC5D7B,IAAI,CAAC8B,gCAAgC;MACvC,yCAAyC,EAAE7B,QAAQ,CAAC8B,yBAAyB;MAC7E,qDAAqD,EACnD9B,QAAQ,CAAC+B,qCAAqC;MAChD,uDAAuD,EAAE9B,mBAAmB,CAAC+B;KAC9E;IAED;;;IAGA,KAAAC,cAAc,GAAuD;MACnE,wCAAwC,EAAE/B,cAAc,CAACgC,IAAI;MAC7D,yCAAyC,EAAEhC,cAAc,CAACiC,MAAM;MAChE,yCAAyC,EAAEjC,cAAc,CAACkC;KAC3D;IAED;;;IAGA,KAAAC,mBAAmB,GAAiE;MAClF,4CAA4C,EAAElC,mBAAmB,CAACmC,OAAO;MACzE,mDAAmD,EAAEnC,mBAAmB,CAACoC,SAAS;MAClF,mDAAmD,EAAEpC,mBAAmB,CAACqC;MACzE;MACA;KACD;IAaC,MAAM;MACJC,MAAM;MACNC,WAAW;MACXC,UAAU;MACVC,UAAU;MACVpC,kBAAkB;MAClBE,yBAAyB;MACzBC,6BAA6B;MAC7BI,kBAAkB;MAClBC,iBAAiB;MACjBC,iBAAiB;MACjBC;IAAkB,CACnB,GAAGX,OAAO;IAEX;IACA,IAAI,CAACkC,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACI,YAAY,GAAG,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;IACtC,IAAIH,WAAW,EAAE;MACf,IAAI,CAACG,YAAY,CAACC,OAAO,CAACJ,WAAW,CAAC;IACxC;IACA,IAAI,CAACC,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACC,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACpC,kBAAkB,GAAGA,kBAAkB,IAAI,IAAI,CAACA,kBAAkB;IACvE,IAAI,CAACE,yBAAyB,GAAGA,yBAAyB;IAC1D,IAAI,OAAOC,6BAA6B,KAAK,QAAQ,EAAE;MACrD,IAAI,CAACA,6BAA6B,GAAGA,6BAA6B,CAACoC,KAAK,CAAC,GAAG,CAAC;IAC/E,CAAC,MAAM,IAAIjD,KAAK,CAACkD,gBAAgB,CAACrC,6BAA6B,CAAC,EAAE;MAChE,IAAI,CAACA,6BAA6B,GAAGA,6BAA6B;IACpE;IACA,IAAI,CAACI,kBAAkB,GAAGA,kBAAkB,IAAI,IAAI,CAACA,kBAAkB;IACvE,IAAI,CAACC,iBAAiB,GAAGA,iBAAiB,IAAI,IAAI,CAACA,iBAAiB;IACpE,IAAI,CAACC,iBAAiB,GAAGA,iBAAiB,IAAI,IAAI,CAACA,iBAAiB;IACpE,IAAI,CAACC,kBAAkB,GAAGA,kBAAkB,IAAIb,SAAS,CAAC4C,IAAI;IAC9D,IAAI,CAACtB,0BAA0B;IAC/B,IAAI,CAACM,cAAc;IACnB,IAAI,CAACI,mBAAmB;EAC1B;EAEA;;;;;EAKAa,UAAUA,CAAA;IACR,IAAI,CAACb,mBAAmB,GAAG;MACzB,6CAA6C,EAAElC,mBAAmB,CAACgD;KACpE;IACD,IAAI,CAAClC,iBAAiB,GAAGZ,SAAS,CAAC4C,IAAI;EACzC;EAEA;;;;;;;;EAQA,OAAOhC,iBAAiBA,CAAC;IAAE2B,UAAU;IAAEQ;EAAM,CAAyB;IACpE,IAAIR,UAAU,IAAI,IAAI,EAAE;MACtB,OAAO,IAAI;IACb;IAEAQ,MAAM,GAAGA,MAAM,GAAG,GAAGA,MAAM,GAAG,GAAG,EAAE;IAEnC,IAAIC,SAAS,GAAG,EAAE;IAClB,IAAIC,MAAM,CAACC,QAAQ,CAACX,UAAU,CAAC,EAAE;MAC/BA,UAAU,GAAGA,UAAU,CAACY,QAAQ,CAAC,QAAQ,CAAC;IAC5C;IAEA,IAAIC,iBAAiB,GAAa,EAAE;IACpC,IAAI,OAAOb,UAAU,KAAK,QAAQ,EAAE;MAClCa,iBAAiB,GAAGb,UAAU,CAACc,KAAK,CAAC5D,KAAK,CAAC6D,kBAAkB,CAAC,IAAI,EAAE;IACtE;IAEA,IAAIF,iBAAiB,CAACG,MAAM,GAAG,CAAC,EAAE;MAChCP,SAAS,GAAGI,iBAAiB,CAC1BI,GAAG,CACDC,CAAC,IACA,IAAIV,MAAM,mBAAmBtD,KAAK,CAC/BiE,QAAQ,CAACD,CAAC,CAAC,CACXN,QAAQ,CAAC,QAAQ,CAAC,KAAKJ,MAAM,kBAAkB,CACrD,CACAY,IAAI,CAAC,EAAE,CAAC;IACb;IAEA,OAAO,IAAIZ,MAAM,YAAYC,SAAS,KAAKD,MAAM,WAAW;EAC9D;EAEA;;;;;;;EAOA,OAAOlC,kBAAkBA,CAACO,OAAqB;IAC7C,IAAIA,OAAO,IAAI,IAAI,EAAE;MACnB,MAAMwC,IAAI,GAAGtE,KAAK,CAACuE,OAAO,CAAC,uCAAuC,EAAEzC,OAAO,CAAC;MAC5E,IAAIrB,SAAS,CAAC+D,UAAU,CAACF,IAAI,CAAC,EAAE;QAC9B,OAAOnE,KAAK,CAACsE,QAAQ,CAACH,IAAI,CAACI,WAAW,IAAI,EAAE,EAAE,aAAa,CAAC;MAC9D;IACF;IAEA,OAAO,IAAI;EACb;EAkBAC,cAAcA,CACZC,GAAW,EACXC,QAA2D;IAE3D,IAAIA,QAAQ,IAAI,IAAI,IAAI,OAAOA,QAAQ,KAAK,UAAU,EAAE;MACtD,MAAM,IAAI1D,KAAK,CAAC,4CAA4C,CAAC;IAC/D;IAEA,IAAI,CAACM,SAAS,GAAGmD,GAAG;IAEpB,MAAME,GAAG,GAAG,IAAI5E,MAAM,CAAC6E,SAAS,EAAE,CAACC,eAAe,CAACJ,GAAG,CAAC;IAEvD,IAAI,CAAC,IAAI,CAACK,aAAa,EAAE,CAACC,KAAK,CAAEC,GAAG,IAAK,IAAI,CAACC,iBAAiB,CAACD,GAAG,EAAEL,GAAG,CAAC,CAAC,EAAE;MAC1E,IAAID,QAAQ,EAAE;QACZA,QAAQ,CAAC,IAAI1D,KAAK,CAAC,mCAAmC,CAAC,CAAC;QACxD;MACF;MAEA,OAAO,KAAK;IACd;IAEA,MAAMkE,eAAe,GAAG,IAAI,CAACC,qBAAqB,CAACR,GAAG,CAAC;IACvD,MAAMS,MAAM,GAAG,IAAI,CAACC,sBAAsB,CAAC,IAAI,CAAC3E,kBAAkB,CAAC;IACnE,MAAM4E,GAAG,GAAG,IAAI,CAAClE,kBAAkB,CAAC,IAAI,CAACO,OAAO,CAAC,IAAI,IAAI,CAACmB,UAAU,IAAI,IAAI,CAACD,UAAU;IACvF,IAAIyC,GAAG,IAAI,IAAI,EAAE;MACf,MAAM,IAAItE,KAAK,CAAC,uEAAuE,CAAC;IAC1F;IACA,IAAI0D,QAAQ,EAAE;MACZU,MAAM,CAACG,eAAe,CAACL,eAAe,EAAEI,GAAG,EAAE,IAAI,CAAC7D,cAAc,EAAEiD,QAAQ,CAAC;IAC7E,CAAC,MAAM;MACL,MAAMc,QAAQ,GAAGJ,MAAM,CAACG,eAAe,CAACL,eAAe,EAAEI,GAAG,EAAE,IAAI,CAAC7D,cAAc,CAAC;MAElF,IAAI+D,QAAQ,KAAK,KAAK,EAAE;QACtB,MAAM,IAAIxE,KAAK,CACb,0CAA0C,IAAI,CAACS,cAAc,eAAe,CAC7E;MACH;MAEA,OAAO,IAAI;IACb;EACF;EAEQ0D,qBAAqBA,CAACR,GAAa;IACzC,IAAI,IAAI,CAACnD,aAAa,IAAI,IAAI,EAAE;MAC9B,MAAM,IAAIR,KAAK,CAAC,qBAAqB,CAAC;IACxC;IACA,IAAI,OAAO,IAAI,CAACJ,yBAAyB,KAAK,QAAQ,EAAE;MACtD,MAAM,IAAII,KAAK,CAAC,0EAA0E,CAAC;IAC7F;IAEA,MAAMyE,UAAU,GAAGzF,KAAK,CAAC0F,YAAY,CAAC,IAAI,CAAClE,aAAa,EAAE,YAAY,CAAC;IACvE,IAAIiE,UAAU,CAAC3B,MAAM,KAAK,CAAC,EAAE;MAC3B,MAAM,IAAI9C,KAAK,CAAC,kDAAkD,CAAC;IACrE;IAEA,IACE,IAAI,CAACJ,yBAAyB,KAAK,iDAAiD,IACpF,IAAI,CAACA,yBAAyB,KAC5B,8DAA8D,EAChE;MACA,IAAI,CAAC+D,GAAG,IAAI,OAAOA,GAAG,KAAK,QAAQ,EAAE;QACnC,MAAM,IAAI3D,KAAK,CACb,8FAA8F,CAC/F;MACH;IACF;IAEA;;;IAGA,MAAM2E,kBAAkB,GAAG3F,KAAK,CAAC4F,cAAc,CAACjB,GAAG,EAAE,gCAAgC,CAAC;IAEtF,MAAMkB,WAAW,GAAG;MAClBF,kBAAkB,EAAEA;KACrB;IAED,OAAO,IAAI,CAACG,WAAW,CAAC,CAAC,IAAI,CAAClF,yBAAyB,CAAC,EAAE6E,UAAU,CAAC,CAAC,CAAC,EAAEI,WAAW,CAAC;EACvF;EAEQE,oBAAoBA,CAACpB,GAAa,EAAEK,GAAc,EAAEgB,IAAU;IACpE;;;IAGA,IAAIC,KAAK,CAACC,OAAO,CAAClB,GAAG,CAACmB,UAAU,CAAC,EAAE;MACjCnB,GAAG,CAACW,kBAAkB,GAAG3F,KAAK,CAAC4F,cAAc,CAACjB,GAAG,EAAEK,GAAG,CAACnF,KAAK,EAAE,IAAI,CAACiB,iBAAiB,CAAC;IACvF;IAEA,MAAM+E,WAAW,GAAG;MAClBhF,6BAA6B,EAAEmE,GAAG,CAACnE,6BAA6B;MAChE8E,kBAAkB,EAAEX,GAAG,CAACW;KACzB;IAED,OAAO,IAAI,CAACG,WAAW,CAACd,GAAG,CAACmB,UAAU,EAAEH,IAAI,EAAEH,WAAW,CAAC;EAC5D;EAEQO,uBAAuBA,CAACzB,GAAa,EAAED,QAAqC;IAClF,MAAMQ,eAAe,GAAG,IAAI,CAACC,qBAAqB,CAACR,GAAG,CAAC;IACvD,MAAMS,MAAM,GAAG,IAAI,CAACC,sBAAsB,CAAC,IAAI,CAAC3E,kBAAkB,CAAC;IACnE,IAAI,IAAI,CAACmC,UAAU,IAAI,IAAI,EAAE;MAC3B,MAAM,IAAI7B,KAAK,CAAC,8CAA8C,CAAC;IACjE;IACA,IAAI,OAAO0D,QAAQ,KAAK,UAAU,EAAE;MAClCU,MAAM,CAACiB,YAAY,CAACnB,eAAe,EAAE,IAAI,CAACrC,UAAU,EAAE6B,QAAQ,CAAC;IACjE,CAAC,MAAM;MACL,IAAI,CAACjD,cAAc,GAAG2D,MAAM,CAACiB,YAAY,CAACnB,eAAe,EAAE,IAAI,CAACrC,UAAU,CAAC;IAC7E;EACF;EAEQwC,sBAAsBA,CAACiB,IAA6B;IAC1D,IAAIA,IAAI,IAAI,IAAI,EAAE;MAChB,MAAM,IAAItF,KAAK,CAAC,gCAAgC,CAAC;IACnD;IACA,MAAMuF,IAAI,GAAG,IAAI,CAAChE,mBAAmB,CAAC+D,IAAI,CAAC;IAC3C,IAAIC,IAAI,EAAE;MACR,OAAO,IAAIA,IAAI,EAAE;IACnB,CAAC,MAAM;MACL,MAAM,IAAIvF,KAAK,CAAC,wBAAwBsF,IAAI,oBAAoB,CAAC;IACnE;EACF;EAEQE,6BAA6BA,CAACF,IAA8C;IAClF,IAAIA,IAAI,IAAI,IAAI,EAAE;MAChB,MAAMC,IAAI,GAAG,IAAI,CAAC1E,0BAA0B,CAACyE,IAAI,CAAC;MAClD,IAAIC,IAAI,EAAE;QACR,OAAO,IAAIA,IAAI,EAAE;MACnB;IACF;IAEA,MAAM,IAAIvF,KAAK,CAAC,+BAA+BsF,IAAI,oBAAoB,CAAC;EAC1E;EAEQG,iBAAiBA,CAACH,IAAuB;IAC/C,MAAMC,IAAI,GAAG,IAAI,CAACpE,cAAc,CAACmE,IAAI,CAAC;IACtC,IAAIC,IAAI,EAAE;MACR,OAAO,IAAIA,IAAI,EAAE;IACnB,CAAC,MAAM;MACL,MAAM,IAAIvF,KAAK,CAAC,mBAAmBsF,IAAI,oBAAoB,CAAC;IAC9D;EACF;EAEAI,gCAAgCA,CAACC,WAA6B,EAAEhC,GAAa;IAC3E,IAAIiC,IAAa;IACjB,IAAI,OAAOD,WAAW,KAAK,QAAQ,EAAE;MACnC,MAAME,SAAS,GAAGhH,KAAK,CAACuE,OAAO,CAACuC,WAAW,EAAEhC,GAAG,CAAC;MACjDrE,SAAS,CAACwG,mBAAmB,CAACD,SAAS,CAAC;MACxCD,IAAI,GAAGC,SAAS;IAClB,CAAC,MAAM;MACLD,IAAI,GAAGD,WAAW;IACpB;IAEA,KAAK,MAAM3B,GAAG,IAAI,IAAI,CAACF,aAAa,EAAE,EAAE;MACtC,MAAMiC,GAAG,GAAG/B,GAAG,CAAC+B,GAAG,GAAG,CAAC,CAAC,KAAK,GAAG,GAAG/B,GAAG,CAAC+B,GAAG,CAACC,SAAS,CAAC,CAAC,CAAC,GAAGhC,GAAG,CAAC+B,GAAG;MAEjE,KAAK,MAAME,IAAI,IAAI,IAAI,CAAClE,YAAY,EAAE;QACpC,MAAMmE,MAAM,GAAGN,IAAI,CAACO,YAAY,CAACF,IAAI,CAAC;QACtC,IAAIF,GAAG,KAAKG,MAAM,EAAE;UAClBlC,GAAG,CAACnF,KAAK,GAAG,yBAAyBoH,IAAI,OAAOF,GAAG,IAAI;UACvD,MAAM,CAAC;QACT;MACF;MAEA,MAAMK,QAAQ,GAAG,IAAI,CAACrB,oBAAoB,CAACpB,GAAG,EAAEK,GAAG,EAAE4B,IAAI,CAAC;MAC1D,MAAMS,IAAI,GAAG,IAAI,CAACZ,iBAAiB,CAACzB,GAAG,CAACsC,eAAe,CAAC;MACxD,MAAMC,MAAM,GAAGF,IAAI,CAACG,OAAO,CAACJ,QAAQ,CAAC;MAErC,IAAIpH,KAAK,CAACyH,mBAAmB,CAACF,MAAM,EAAEvC,GAAG,CAAC0C,WAAW,CAAC,EAAE;QACtD,OAAO1C,GAAG;MACZ;IACF;IAEA,MAAM,IAAIhE,KAAK,CAAC,iCAAiC,CAAC;EACpD;EAEQiE,iBAAiBA,CAACD,GAAc,EAAEL,GAAa;IACrD,MAAMoC,GAAG,GAAG/B,GAAG,CAAC+B,GAAG,GAAG,CAAC,CAAC,KAAK,GAAG,GAAG/B,GAAG,CAAC+B,GAAG,CAACC,SAAS,CAAC,CAAC,CAAC,GAAGhC,GAAG,CAAC+B,GAAG;IACjE,IAAIH,IAAI,GAAiC,IAAI;IAE7C,IAAIG,GAAG,KAAK,EAAE,EAAE;MACdH,IAAI,GAAG/G,KAAK,CAACuE,OAAO,CAAC,KAAK,EAAEO,GAAG,CAAC;IAClC,CAAC,MAAM,IAAIoC,GAAG,EAAEY,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE;MACnC;MACA,MAAM,IAAI3G,KAAK,CAAC,6CAA6C,CAAC;IAChE,CAAC,MAAM;MACL,IAAI4G,mBAAmB,GAAG,CAAC;MAC3B,KAAK,MAAMX,IAAI,IAAI,IAAI,CAAClE,YAAY,EAAE;QACpC,MAAM8E,aAAa,GAAG,yBAAyBZ,IAAI,OAAOF,GAAG,IAAI;QACjE,MAAMe,QAAQ,GAAGjI,KAAK,CAACkI,MAAM,CAACF,aAAa,EAAElD,GAAG,CAAC;QACjD,IAAI3E,KAAK,CAACkD,gBAAgB,CAAC4E,QAAQ,CAAC,EAAE;UACpCF,mBAAmB,IAAIE,QAAQ,CAAChE,MAAM;UAEtC,IAAI8D,mBAAmB,GAAG,CAAC,EAAE;YAC3B,MAAM,IAAI5G,KAAK,CACb,uEAAuE,GACrE,kEAAkE,GAClE,4BAA4B,CAC/B;UACH;UAEA4F,IAAI,GAAGkB,QAAQ,CAAC,CAAC,CAAC;UAClB9C,GAAG,CAACnF,KAAK,GAAGgI,aAAa;QAC3B;MACF;IACF;IAEA7C,GAAG,CAACgD,gBAAgB,GAAIC,aAAsB,IAAI;MAChDA,aAAa,GAAGA,aAAa,IAAIjD,GAAG,CAACnF,KAAK;MAC1C,IAAI,OAAOoI,aAAa,KAAK,QAAQ,IAAIjD,GAAG,CAACkD,eAAe,IAAI,IAAI,EAAE;QACpE,OAAO,IAAI;MACb;MACA,MAAMC,aAAa,GAAGtI,KAAK,CAACuE,OAAO,CAAC6D,aAAa,EAAEtD,GAAG,CAAC;MACvD,OAAOrE,SAAS,CAAC+D,UAAU,CAAC8D,aAAa,CAAC,GAAGA,aAAa,GAAG,IAAI;IACnE,CAAC;IAED,IAAI,CAAC7H,SAAS,CAAC+D,UAAU,CAACuC,IAAI,CAAC,EAAE;MAC/B,MAAMsB,eAAe,GAAG,IAAIlH,KAAK,CAC/B,mEAAmEgE,GAAG,CAAC+B,GAAG,6CAA6C,CACxH;MACD/B,GAAG,CAACkD,eAAe,GAAGA,eAAe;MACrC,OAAO,KAAK;IACd;IAEA,MAAMd,QAAQ,GAAG,IAAI,CAACrB,oBAAoB,CAACpB,GAAG,EAAEK,GAAG,EAAE4B,IAAI,CAAC;IAC1D,MAAMS,IAAI,GAAG,IAAI,CAACZ,iBAAiB,CAACzB,GAAG,CAACsC,eAAe,CAAC;IACxD,MAAMC,MAAM,GAAGF,IAAI,CAACG,OAAO,CAACJ,QAAQ,CAAC;IAErC,IAAI,CAACpH,KAAK,CAACyH,mBAAmB,CAACF,MAAM,EAAEvC,GAAG,CAAC0C,WAAW,CAAC,EAAE;MACvD,MAAMQ,eAAe,GAAG,IAAIlH,KAAK,CAC/B,8BAA8BgE,GAAG,CAAC+B,GAAG,yBAAyBQ,MAAM,4CAA4CvC,GAAG,CAAC0C,WAAW,EAAE,CAClI;MACD1C,GAAG,CAACkD,eAAe,GAAGA,eAAe;MAErC,OAAO,KAAK;IACd;IAEA,OAAO,IAAI;EACb;EAEAE,cAAcA,CAACzD,GAAS;IACtB,MAAM0D,KAAK,GAAGxI,KAAK,CAACkI,MAAM,CACxB,0FAA0F,EAC1FpD,GAAG,CACJ;IAED,OAAOrE,SAAS,CAACgI,cAAc,CAACD,KAAK,CAAC,GAAGA,KAAK,GAAG,EAAE;EACrD;EAEA;;;;;EAKAE,aAAaA,CAAC/G,aAA4B;IACxC,IAAI,OAAOA,aAAa,KAAK,QAAQ,EAAE;MACrC,IAAI,CAACA,aAAa,GAAGA,aAAa,GAAG,IAAIzB,MAAM,CAAC6E,SAAS,EAAE,CAACC,eAAe,CAACrD,aAAa,CAAC;IAC5F,CAAC,MAAM;MACL,IAAI,CAACA,aAAa,GAAGA,aAAa;IACpC;IAEA,IAAI,CAACD,YAAY,GAAGC,aAAa,CAACkC,QAAQ,EAAE;IAE5C,MAAMsC,IAAI,GAAGnG,KAAK,CAACuE,OAAO,CACxB,yDAAyD,EACzD5C,aAAa,CACd;IACD,IAAI,CAAClB,SAAS,CAAC+D,UAAU,CAAC2B,IAAI,CAAC,EAAE;MAC/B,MAAM,IAAIhF,KAAK,CAAC,0DAA0D,CAAC;IAC7E;IAEA,IAAIV,SAAS,CAACkI,eAAe,CAACxC,IAAI,CAAC,EAAE;MACnC,IAAI,CAACpF,yBAAyB,GAAGoF,IAAI,CAACyC,KAAsC;IAC9E;IAEA,MAAM/H,kBAAkB,GAAGb,KAAK,CAACuE,OAAO,CACtC,kDAAkD,EAClD5C,aAAa,CACd;IAED,IAAIlB,SAAS,CAACkI,eAAe,CAAC9H,kBAAkB,CAAC,EAAE;MACjD,IAAI,CAACA,kBAAkB,GAAGA,kBAAkB,CAAC+H,KAA+B;IAC9E;IAEA,IAAI,CAAC7G,UAAU,GAAG,EAAE;IACpB,MAAMA,UAAU,GAAG/B,KAAK,CAACkI,MAAM,CAC7B,+DAA+D,EAC/DvG,aAAa,CACd;IACD,IAAI,CAACxB,KAAK,CAACkD,gBAAgB,CAACtB,UAAU,CAAC,EAAE;MACvC,MAAM,IAAIZ,KAAK,CAAC,uCAAuC,CAAC;IAC1D;IAEA,KAAK,MAAM0H,SAAS,IAAI9G,UAAU,EAAE;MAClC,IAAI,CAAC+G,aAAa,CAACD,SAAS,CAAC;IAC/B;IAEA,MAAMjH,cAAc,GAAG5B,KAAK,CAACuE,OAAO,CAClC,6CAA6C,EAC7C5C,aAAa,CACd;IAED,IAAIlB,SAAS,CAACsI,UAAU,CAACnH,cAAc,CAAC,EAAE;MACxC,IAAI,CAACA,cAAc,GAAGA,cAAc,CAACoH,IAAI,CAACC,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC;IACjE;IAEA,MAAMnH,OAAO,GAAG9B,KAAK,CAACuE,OAAO,CAAC,+BAA+B,EAAE5C,aAAa,CAAC;IAE7E,IAAIlB,SAAS,CAAC+D,UAAU,CAAC1C,OAAO,CAAC,EAAE;MACjC,IAAI,CAACA,OAAO,GAAGA,OAAO;IACxB;EACF;EAEA;;;;EAIQgH,aAAaA,CAACI,OAAa;IACjC,IAAIV,KAAK,GAAGrI,KAAK,CAAC0F,YAAY,CAACqD,OAAO,EAAE,cAAc,CAAC;IACvD,IAAIV,KAAK,CAACvE,MAAM,KAAK,CAAC,EAAE;MACtB,MAAM,IAAI9C,KAAK,CAAC,4CAA4C+H,OAAO,CAACrF,QAAQ,EAAE,EAAE,CAAC;IACnF;IACA,MAAMsF,cAAc,GAAGX,KAAK,CAAC,CAAC,CAAC;IAE/B,MAAMpB,IAAI,GAAGjH,KAAK,CAACiJ,QAAQ,CAACD,cAAc,EAAE,WAAW,CAAC;IACxD,IAAI,CAAC/B,IAAI,EAAE;MACT,MAAM,IAAIjG,KAAK,CAAC,8CAA8CgI,cAAc,CAACtF,QAAQ,EAAE,EAAE,CAAC;IAC5F;IACA,MAAMwF,UAAU,GAAGjC,IAAI,CAACwB,KAAK;IAE7BJ,KAAK,GAAGrI,KAAK,CAAC0F,YAAY,CAACqD,OAAO,EAAE,aAAa,CAAC;IAClD,IAAIV,KAAK,CAACvE,MAAM,KAAK,CAAC,EAAE;MACtB,MAAM,IAAI9C,KAAK,CAAC,gDAAgD+H,OAAO,CAACrF,QAAQ,EAAE,EAAE,CAAC;IACvF;IACA,MAAMyF,UAAU,GAAGd,KAAK,CAAC,CAAC,CAAC,CAACc,UAAU;IACtC,IAAI,CAACA,UAAU,IAAI,EAAE,MAAM,IAAIA,UAAU,CAAC,EAAE;MAC1C,MAAM,IAAInI,KAAK,CAAC,8CAA8CqH,KAAK,CAAC,CAAC,CAAC,CAAC3E,QAAQ,EAAE,EAAE,CAAC;IACtF;IACA,MAAMgE,WAAW,GAAGyB,UAAU,CAACN,IAAI;IAEnC,MAAM1C,UAAU,GAAa,EAAE;IAC/B,IAAItF,6BAA6B,GAAa,EAAE;IAChDwH,KAAK,GAAGrI,KAAK,CAAC0F,YAAY,CAACqD,OAAO,EAAE,YAAY,CAAC;IACjD,IAAIV,KAAK,CAACvE,MAAM,KAAK,CAAC,EAAE;MACtB,MAAMsF,cAAc,GAAGf,KAAK,CAAC,CAAC,CAAC;MAC/B,MAAMgB,aAAa,GAAGrJ,KAAK,CAAC0F,YAAY,CAAC0D,cAAc,EAAE,WAAW,CAAC;MACrE,KAAK,MAAME,SAAS,IAAID,aAAa,EAAE;QACrC,MAAME,aAAa,GAAGvJ,KAAK,CAACiJ,QAAQ,CAACK,SAAS,EAAE,WAAW,CAAC;QAE5D,IAAIC,aAAa,EAAE;UACjBpD,UAAU,CAACqD,IAAI,CAACD,aAAa,CAACd,KAAK,CAAC;QACtC;MACF;MAEA;MACA,MAAMgB,mBAAmB,GAAGzJ,KAAK,CAAC0F,YAAY,CAC5C2D,aAAa,CAACA,aAAa,CAACvF,MAAM,GAAG,CAAC,CAAC,EACvC,qBAAqB,CACtB;MACD,IAAI9D,KAAK,CAACkD,gBAAgB,CAACuG,mBAAmB,CAAC,EAAE;QAC/C;QACA5I,6BAA6B,GAAG4I,mBAAmB,CAChDC,OAAO,CAAEC,SAAS,IAAK,CAACA,SAAS,CAACxC,YAAY,CAAC,YAAY,CAAC,IAAI,EAAE,EAAElE,KAAK,CAAC,GAAG,CAAC,CAAC,CAC/E2G,MAAM,CAAEnB,KAAK,IAAKA,KAAK,CAAC3E,MAAM,GAAG,CAAC,CAAC;MACxC;IACF;IAEA,IAAI9D,KAAK,CAACkD,gBAAgB,CAAC,IAAI,CAACjC,kBAAkB,CAAC,EAAE;MACnD,IAAI,CAACA,kBAAkB,CAAC4I,OAAO,CAAC,UAAUC,CAAC;QACzC3D,UAAU,CAACqD,IAAI,CAACM,CAAC,CAAC;MACpB,CAAC,CAAC;IACJ;IAEA;;;;;;;;;IASA,IACE3D,UAAU,CAACrC,MAAM,KAAK,CAAC,IACvBqC,UAAU,CAACA,UAAU,CAACrC,MAAM,GAAG,CAAC,CAAC,KAAK,uDAAuD,EAC7F;MACAqC,UAAU,CAACqD,IAAI,CAAC,iDAAiD,CAAC;IACpE;IAEA,IAAI,CAACO,YAAY,CAAC;MAChB5D,UAAU;MACVmB,eAAe,EAAE4B,UAAU;MAC3BnC,GAAG,EAAEzG,SAAS,CAAC0J,aAAa,CAACjB,OAAO,CAAC,GAAG/I,KAAK,CAACiJ,QAAQ,CAACF,OAAO,EAAE,KAAK,CAAC,EAAEN,KAAK,GAAG9H,SAAS;MACzF+G,WAAW;MACX7G,6BAA6B;MAC7BoJ,UAAU,EAAE;KACb,CAAC;EACJ;EAEA;;;;;;;;;;;EAWAF,YAAYA,CAAC;IACXlK,KAAK;IACLsG,UAAU;IACVmB,eAAe;IACfP,GAAG,GAAG,EAAE;IACRW,WAAW;IACX7G,6BAA6B,GAAG,EAAE;IAClCoJ,UAAU,GAAG;EAAK,CAC4B;IAC9C,IAAI3C,eAAe,IAAI,IAAI,EAAE;MAC3B,MAAM,IAAItG,KAAK,CAAC,6BAA6B,CAAC;IAChD;IAEA,IAAI,CAAChB,KAAK,CAACkD,gBAAgB,CAACiD,UAAU,CAAC,EAAE;MACvC,MAAM,IAAInF,KAAK,CAAC,0DAA0D,CAAC;IAC7E;IAEA,IAAI,CAACY,UAAU,CAAC4H,IAAI,CAAC;MACnB3J,KAAK;MACLsG,UAAU;MACVmB,eAAe;MACfP,GAAG;MACHW,WAAW;MACX7G,6BAA6B;MAC7BoJ,UAAU;MACVjC,gBAAgB,EAAEA,CAAA,KAAK;QACrB,MAAM,IAAIhH,KAAK,CACb,4EAA4E,CAC7E;MACH;KACD,CAAC;EACJ;EAEA8D,aAAaA,CAAA;IACX,OAAO,IAAI,CAAClD,UAAU;EACxB;EA+CAsI,gBAAgBA,CACdzF,GAAW,EACXhE,OAAiE,EACjE0J,aAA6C;IAE7C,IAAIzF,QAAuC;IAC3C,IAAI,OAAOjE,OAAO,KAAK,UAAU,IAAI0J,aAAa,IAAI,IAAI,EAAE;MAC1DzF,QAAQ,GAAGjE,OAAwC;MACnDA,OAAO,GAAG,EAA6B;IACzC,CAAC,MAAM;MACLiE,QAAQ,GAAGyF,aAA8C;MACzD1J,OAAO,GAAIA,OAAO,IAAI,EAA8B;IACtD;IAEA,MAAMkE,GAAG,GAAG,IAAI5E,MAAM,CAAC6E,SAAS,EAAE,CAACC,eAAe,CAACJ,GAAG,CAAC;IACvD,IAAI2F,SAAS,GAAG,OAAO;IACvB,MAAMC,cAAc,GAAa,EAAE;IACnC,IAAIC,aAAqB;IAEzB,MAAMC,YAAY,GAAG,CAAC,QAAQ,EAAE,SAAS,EAAE,QAAQ,EAAE,OAAO,CAAC;IAE7D,MAAMjH,MAAM,GAAG7C,OAAO,CAAC6C,MAAM;IAC7B,MAAMkH,KAAK,GAAG/J,OAAO,CAAC+J,KAAK,IAAI,EAAE;IACjC,MAAMC,QAAQ,GAAGhK,OAAO,CAACgK,QAAQ,IAAI,EAAE;IACvC,MAAMC,gBAAgB,GAAGjK,OAAO,CAACiK,gBAAgB,IAAI,EAAE;IAEvD,IAAI,CAAC5J,iBAAiB,GAAG;MACvBC,kBAAkB,EAAE,SAAAA,CAAUuC,MAAM;QAClC,OAAOA,MAAM,GAAGoH,gBAAgB,CAACpH,MAAM,CAAC,GAAG,IAAI;MACjD;KACD;IAED;IACAmH,QAAQ,CAAC/B,SAAS,GAAG+B,QAAQ,CAAC/B,SAAS,IAAI,IAAI;IAC/C;IACA+B,QAAQ,CAACE,MAAM,GAAGF,QAAQ,CAACE,MAAM,IAAI,QAAQ;IAE7C,IAAIJ,YAAY,CAAC5C,OAAO,CAAC8C,QAAQ,CAACE,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE;MAChD,MAAMC,GAAG,GAAG,IAAI5J,KAAK,CACnB,iDACEyJ,QAAQ,CAACE,MACX,0CAA0CJ,YAAY,CAACrG,IAAI,CAAC,IAAI,CAAC,EAAE,CACpE;MACD,IAAI,CAACQ,QAAQ,EAAE;QACb,MAAMkG,GAAG;MACX,CAAC,MAAM;QACLlG,QAAQ,CAACkG,GAAG,CAAC;QACb;MACF;IACF;IAEA;IACA,IAAItH,MAAM,EAAE;MACV8G,SAAS,IAAI,IAAI9G,MAAM,EAAE;MACzBgH,aAAa,GAAG,GAAGhH,MAAM,GAAG;IAC9B,CAAC,MAAM;MACLgH,aAAa,GAAG,EAAE;IACpB;IAEAO,MAAM,CAACC,IAAI,CAACN,KAAK,CAAC,CAACX,OAAO,CAAC,UAAUvD,IAAI;MACvC,IAAIA,IAAI,KAAK,OAAO,IAAIA,IAAI,KAAK8D,SAAS,EAAE;QAC1CC,cAAc,CAACb,IAAI,CAAC,GAAGlD,IAAI,KAAKkE,KAAK,CAAClE,IAAI,CAAC,GAAG,CAAC;MACjD;IACF,CAAC,CAAC;IAEF;IACA+D,cAAc,CAACb,IAAI,CAAC,GAAGY,SAAS,uCAAuC,CAAC;IAExE,IAAI7I,YAAY,GAAG,IAAI+I,aAAa,aAAaD,cAAc,CAACnG,IAAI,CAAC,GAAG,CAAC,GAAG;IAE5E3C,YAAY,IAAI,IAAI,CAACwJ,gBAAgB,CAACpG,GAAG,EAAErB,MAAM,CAAC;IAClD/B,YAAY,IAAI,IAAI,CAACyJ,UAAU,CAAC1H,MAAM,CAAC;IACvC/B,YAAY,IAAI,KAAK+I,aAAa,YAAY;IAE9C,IAAI,CAAC5I,kBAAkB,GAAGiD,GAAG,CAACjB,QAAQ,EAAE;IAExC,IAAIuH,sBAAsB,GAAG,EAAE;IAC/BJ,MAAM,CAACC,IAAI,CAACJ,gBAAgB,CAAC,CAACb,OAAO,CAAC,UAAUvE,GAAG;MACjD2F,sBAAsB,IAAI,SAAS3F,GAAG,KAAKoF,gBAAgB,CAACpF,GAAG,CAAC,IAAI;IACtE,CAAC,CAAC;IAEF;IACA;IACA,MAAM4F,qBAAqB,GAAG,UAAUD,sBAAsB,IAAI1J,YAAY,UAAU;IACxF,MAAM4J,OAAO,GAAG,IAAIpL,MAAM,CAAC6E,SAAS,EAAE,CAACC,eAAe,CAACqG,qBAAqB,CAAC;IAE7E;IACA;IACA,MAAME,YAAY,GAAGD,OAAO,CAACE,eAAe,CAAClC,UAAW;IAExD,MAAMmC,aAAa,GAAGzL,KAAK,CAACuE,OAAO,CAACqG,QAAQ,CAAC/B,SAAS,EAAE/D,GAAG,CAAC;IAE5D,IAAI,CAACrE,SAAS,CAAC+D,UAAU,CAACiH,aAAa,CAAC,EAAE;MACxC,MAAMC,IAAI,GAAG,IAAIvK,KAAK,CACpB,gEAAgEyJ,QAAQ,CAAC/B,SAAS,EAAE,CACrF;MACD,IAAI,CAAChE,QAAQ,EAAE;QACb,MAAM6G,IAAI;MACZ,CAAC,MAAM;QACL7G,QAAQ,CAAC6G,IAAI,CAAC;QACd;MACF;IACF;IAEA,IAAId,QAAQ,CAACE,MAAM,KAAK,QAAQ,EAAE;MAChCW,aAAa,CAACE,WAAW,CAACJ,YAAY,CAAC;IACzC,CAAC,MAAM,IAAIX,QAAQ,CAACE,MAAM,KAAK,SAAS,EAAE;MACxCW,aAAa,CAACG,YAAY,CAACL,YAAY,EAAEE,aAAa,CAACnC,UAAU,CAAC;IACpE,CAAC,MAAM,IAAIsB,QAAQ,CAACE,MAAM,KAAK,QAAQ,EAAE;MACvC,IAAIW,aAAa,CAACI,UAAU,IAAI,IAAI,EAAE;QACpC,MAAM,IAAI1K,KAAK,CACb,wFAAwF,CACzF;MACH;MACAsK,aAAa,CAACI,UAAU,CAACD,YAAY,CAACL,YAAY,EAAEE,aAAa,CAAC;IACpE,CAAC,MAAM,IAAIb,QAAQ,CAACE,MAAM,KAAK,OAAO,EAAE;MACtC,IAAIW,aAAa,CAACI,UAAU,IAAI,IAAI,EAAE;QACpC,MAAM,IAAI1K,KAAK,CACb,uFAAuF,CACxF;MACH;MACAsK,aAAa,CAACI,UAAU,CAACD,YAAY,CAACL,YAAY,EAAEE,aAAa,CAACK,WAAW,CAAC;IAChF;IAEA,IAAI,CAACnK,aAAa,GAAG4J,YAAY;IACjC,MAAMQ,eAAe,GAAG5L,KAAK,CAAC0F,YAAY,CAAC,IAAI,CAAClE,aAAa,EAAE,YAAY,CAAC;IAC5E,IAAIoK,eAAe,CAAC9H,MAAM,KAAK,CAAC,EAAE;MAChC,MAAM+H,IAAI,GAAG,IAAI7K,KAAK,CAAC,kDAAkD,CAAC;MAC1E,IAAI,CAAC0D,QAAQ,EAAE;QACb,MAAMmH,IAAI;MACZ,CAAC,MAAM;QACLnH,QAAQ,CAACmH,IAAI,CAAC;QACd;MACF;IACF;IACA,MAAMC,cAAc,GAAGF,eAAe,CAAC,CAAC,CAAC;IAEzC,IAAI,OAAOlH,QAAQ,KAAK,UAAU,EAAE;MAClC;MACA,IAAI,CAAC0B,uBAAuB,CAACzB,GAAG,EAAE,CAACiG,GAAG,EAAEmB,SAAS,KAAI;QACnD,IAAInB,GAAG,EAAE;UACPlG,QAAQ,CAACkG,GAAG,CAAC;QACf,CAAC,MAAM;UACL,IAAI,CAACnJ,cAAc,GAAGsK,SAAS,IAAI,EAAE;UACrCX,YAAY,CAACK,YAAY,CAAC,IAAI,CAACO,eAAe,CAAC1I,MAAM,CAAC,EAAEwI,cAAc,CAACH,WAAW,CAAC;UACnF,IAAI,CAACpK,YAAY,GAAG6J,YAAY,CAAC1H,QAAQ,EAAE;UAC3C,IAAI,CAACpC,SAAS,GAAGqD,GAAG,CAACjB,QAAQ,EAAE;UAC/BgB,QAAQ,CAAC,IAAI,EAAE,IAAI,CAAC;QACtB;MACF,CAAC,CAAC;IACJ,CAAC,MAAM;MACL;MACA,IAAI,CAAC0B,uBAAuB,CAACzB,GAAG,CAAC;MACjCyG,YAAY,CAACK,YAAY,CAAC,IAAI,CAACO,eAAe,CAAC1I,MAAM,CAAC,EAAEwI,cAAc,CAACH,WAAW,CAAC;MACnF,IAAI,CAACpK,YAAY,GAAG6J,YAAY,CAAC1H,QAAQ,EAAE;MAC3C,IAAI,CAACpC,SAAS,GAAGqD,GAAG,CAACjB,QAAQ,EAAE;IACjC;EACF;EAEQsH,UAAUA,CAAC1H,MAAM;IACvB,MAAMgH,aAAa,GAAGhH,MAAM,GAAG,GAAGA,MAAM,GAAG,GAAG,EAAE;IAEhD,IAAI2I,YAAY,GAAG,EAAE;IACrB,IAAI,IAAI,CAAC/K,iBAAiB,EAAE;MAC1B2J,MAAM,CAACC,IAAI,CAAC,IAAI,CAAC5J,iBAAiB,CAAC,CAAC2I,OAAO,CAAEvD,IAAI,IAAI;QACnD2F,YAAY,IAAI,IAAI3F,IAAI,KAAK,IAAI,CAACpF,iBAAiB,CAACoF,IAAI,CAAC,GAAG;MAC9D,CAAC,CAAC;IACJ;IAEA,MAAM4F,cAAc,GAAG,IAAI,CAAC/K,iBAAiB,CAAC;MAAE2B,UAAU,EAAE,IAAI,CAACA,UAAU;MAAEQ;IAAM,CAAE,CAAC;IACtF,IAAI2I,YAAY,IAAIC,cAAc,EAAE;MAClC,OAAO,IAAI5B,aAAa,UAAU2B,YAAY,IAAIC,cAAc,KAAK5B,aAAa,UAAU;IAC9F;IAEA,OAAO,EAAE;EACX;EAEA;;;;EAIQ6B,gBAAgBA,CAACxH,GAAG,EAAErB,MAAM;IAClC,IAAI8I,GAAG,GAAG,EAAE;IAEZ9I,MAAM,GAAGA,MAAM,IAAI,EAAE;IACrBA,MAAM,GAAGA,MAAM,GAAG,GAAGA,MAAM,GAAG,GAAGA,MAAM;IAEvC,KAAK,MAAM0B,GAAG,IAAI,IAAI,CAACF,aAAa,EAAE,EAAE;MACtC,MAAMuD,KAAK,GAAGxI,KAAK,CAACwM,kBAAkB,CAACrH,GAAG,CAACnF,KAAK,IAAI,EAAE,EAAE8E,GAAG,EAAE,IAAI,CAAC7D,iBAAiB,CAAC;MAEpF,IAAI,CAACd,KAAK,CAACkD,gBAAgB,CAACmF,KAAK,CAAC,EAAE;QAClC,MAAM,IAAIrH,KAAK,CACb,kEAAkEgE,GAAG,CAACnF,KAAK,EAAE,CAC9E;MACH;MAEA,KAAK,MAAMmG,IAAI,IAAIqC,KAAK,EAAE;QACxB,IAAIrD,GAAG,CAACiF,UAAU,EAAE;UAClBmC,GAAG,IAAI,IAAI9I,MAAM,mBAAmB;QACtC,CAAC,MAAM;UACL,MAAMjC,EAAE,GAAG,IAAI,CAACiL,WAAW,CAACtG,IAAI,CAAC;UACjChB,GAAG,CAAC+B,GAAG,GAAG1F,EAAE;UACZ+K,GAAG,IAAI,IAAI9I,MAAM,mBAAmBjC,EAAE,IAAI;QAC5C;QACA+K,GAAG,IAAI,IAAI9I,MAAM,aAAa;QAC9B,KAAK,MAAMiJ,KAAK,IAAIvH,GAAG,CAACmB,UAAU,IAAI,EAAE,EAAE;UACxC,MAAMmD,SAAS,GAAG,IAAI,CAAC9C,6BAA6B,CAAC+F,KAAK,CAAC;UAC3DH,GAAG,IAAI,IAAI9I,MAAM,wBAAwBgG,SAAS,CAACkD,gBAAgB,EAAE,GAAG;UACxE,IAAIxM,KAAK,CAACkD,gBAAgB,CAAC8B,GAAG,CAACnE,6BAA6B,CAAC,EAAE;YAC7DuL,GAAG,IAAI,GAAG;YACVA,GAAG,IAAI,oCAAoCpH,GAAG,CAACnE,6BAA6B,CAACqD,IAAI,CAC/E,GAAG,CACJ,YAAYoF,SAAS,CAACkD,gBAAgB,EAAE,KAAK;YAC9CJ,GAAG,IAAI,KAAK9I,MAAM,YAAY;UAChC,CAAC,MAAM;YACL8I,GAAG,IAAI,KAAK;UACd;QACF;QAEA,MAAMhF,QAAQ,GAAG,IAAI,CAACrB,oBAAoB,CAACpB,GAAG,EAAEK,GAAG,EAAEgB,IAAI,CAAC;QAE1D,MAAMsB,eAAe,GAAG,IAAI,CAACb,iBAAiB,CAACzB,GAAG,CAACsC,eAAe,CAAC;QACnE8E,GAAG,IACD,KAAK9I,MAAM,aAAa,GACxB,IAAIA,MAAM,2BAA2BgE,eAAe,CAACkF,gBAAgB,EAAE,MAAM,GAC7E,IAAIlJ,MAAM,eAAegE,eAAe,CAACE,OAAO,CAACJ,QAAQ,CAAC,KAAK9D,MAAM,cAAc,GACnF,KAAKA,MAAM,YAAY;MAC3B;IACF;IAEA,OAAO8I,GAAG;EACZ;EAEAtG,WAAWA,CACTK,UAAmC,EACnCH,IAAU,EACVvF,OAAA,GAAmE,EAAE;IAErEA,OAAO,CAACgM,kBAAkB,GAAGhM,OAAO,CAACgM,kBAAkB,IAAIlM,SAAS,CAACkM,kBAAkB;IACvFhM,OAAO,CAACe,aAAa,GAAG,IAAI,CAACA,aAAa;IAE1C,MAAM4F,QAAQ,GAAGpB,IAAI,CAAC0G,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC;IACvC,IAAIC,cAAc,GAAkBvF,QAAQ;IAE5CjB,UAAU,CAAC0D,OAAO,CAAE+C,aAAa,IAAI;MACnC,IAAItM,SAAS,CAAC+D,UAAU,CAACsI,cAAc,CAAC,EAAE;QACxC;QACA,MAAMrD,SAAS,GAAG,IAAI,CAAC9C,6BAA6B,CAACoG,aAAa,CAAC;QACnED,cAAc,GAAGrD,SAAS,CAACuD,OAAO,CAACF,cAAc,EAAElM,OAAO,CAAC;MAC7D;MACA;MACA;MACA;MACA;MACA;MACA;MACA;IACF,CAAC,CAAC;IAEF,OAAOkM,cAAc,CAACjJ,QAAQ,EAAE;EAClC;EAEA;;;;EAIQ4I,WAAWA,CAACtG,IAAI;IACtB,IAAIiB,IAAI;IAER,IAAI,IAAI,CAACtE,MAAM,KAAK,YAAY,EAAE;MAChCsE,IAAI,GAAGjH,KAAK,CAACiJ,QAAQ,CACnBjD,IAAI,EACJ,IAAI,EACJ,oFAAoF,CACrF;IACH,CAAC,MAAM;MACL,IAAI,CAACjD,YAAY,CAAC+J,IAAI,CAAElK,WAAW,IAAI;QACrCqE,IAAI,GAAGjH,KAAK,CAACiJ,QAAQ,CAACjD,IAAI,EAAEpD,WAAW,CAAC;QACxC,OAAO,CAAC,CAACqE,IAAI,CAAC,CAAC;MACjB,CAAC,CAAC;IACJ;IAEA,IAAIA,IAAI,EAAE;MACR,OAAOA,IAAI,CAACwB,KAAK;IACnB;IAEA;IACA,MAAMpH,EAAE,GAAG,IAAI,IAAI,CAACA,EAAE,EAAE,EAAE;IAE1B,IAAI,IAAI,CAACsB,MAAM,KAAK,YAAY,EAAE;MAChCqD,IAAI,CAAC+G,cAAc,CACjB,+BAA+B,EAC/B,WAAW,EACX,oFAAoF,CACrF;MACD/G,IAAI,CAAC+G,cAAc,CACjB,oFAAoF,EACpF,QAAQ,EACR1L,EAAE,CACH;IACH,CAAC,MAAM;MACL2E,IAAI,CAACgH,YAAY,CAAC,IAAI,EAAE3L,EAAE,CAAC;IAC7B;IAEA,OAAOA,EAAE;EACX;EAEA;;;;EAIQ0J,gBAAgBA,CAACpG,GAAG,EAAErB,MAAM;IAClC,IAAI,OAAO,IAAI,CAAC1C,yBAAyB,KAAK,QAAQ,EAAE;MACtD,MAAM,IAAII,KAAK,CACb,6EAA6E,CAC9E;IACH;IACA,MAAMsI,SAAS,GAAG,IAAI,CAAC9C,6BAA6B,CAAC,IAAI,CAAC5F,yBAAyB,CAAC;IACpF,MAAM2F,IAAI,GAAG,IAAI,CAAClB,sBAAsB,CAAC,IAAI,CAAC3E,kBAAkB,CAAC;IACjE,IAAI4J,aAAa;IAEjBA,aAAa,GAAGhH,MAAM,IAAI,EAAE;IAC5BgH,aAAa,GAAGA,aAAa,GAAG,GAAGA,aAAa,GAAG,GAAGA,aAAa;IAEnE,IAAI8B,GAAG,GAAG,IAAI9B,aAAa,aAAa;IACxC8B,GAAG,IAAI,IAAI9B,aAAa,qCAAqChB,SAAS,CAACkD,gBAAgB,EAAE,GAAG;IAC5F,IAAIxM,KAAK,CAACkD,gBAAgB,CAAC,IAAI,CAACrC,6BAA6B,CAAC,EAAE;MAC9DuL,GAAG,IAAI,GAAG;MACVA,GAAG,IAAI,oCAAoC,IAAI,CAACvL,6BAA6B,CAACqD,IAAI,CAChF,GAAG,CACJ,YAAYoF,SAAS,CAACkD,gBAAgB,EAAE,KAAK;MAC9CJ,GAAG,IAAI,KAAK9B,aAAa,yBAAyB;IACpD,CAAC,MAAM;MACL8B,GAAG,IAAI,KAAK;IACd;IACAA,GAAG,IAAI,IAAI9B,aAAa,8BAA8B/D,IAAI,CAACiG,gBAAgB,EAAE,MAAM;IAEnFJ,GAAG,IAAI,IAAI,CAACD,gBAAgB,CAACxH,GAAG,EAAErB,MAAM,CAAC;IACzC8I,GAAG,IAAI,KAAK9B,aAAa,aAAa;IACtC,OAAO8B,GAAG;EACZ;EAEA;;;;EAIQJ,eAAeA,CAAC1I,MAAe;IACrC,IAAI8G,SAAS,GAAG,OAAO;IAEvB,IAAI9G,MAAM,EAAE;MACV8G,SAAS,IAAI,IAAI9G,MAAM,EAAE;MACzBA,MAAM,IAAI,GAAG;IACf,CAAC,MAAM;MACLA,MAAM,GAAG,EAAE;IACb;IAEA,MAAM2J,iBAAiB,GAAG,IAAI3J,MAAM,kBAAkB,IAAI,CAAC7B,cAAc,KAAK6B,MAAM,iBAAiB;IACrG;IACA;IACA,MAAM4H,qBAAqB,GAAG,IAAI5H,MAAM,aAAa8G,SAAS,yCAAyC6C,iBAAiB,KAAK3J,MAAM,YAAY;IAE/I,MAAMqB,GAAG,GAAG,IAAI5E,MAAM,CAAC6E,SAAS,EAAE,CAACC,eAAe,CAACqG,qBAAqB,CAAC;IAEzE;IACA;IACA,OAAOvG,GAAG,CAAC0G,eAAe,CAAClC,UAAW;EACxC;EAEA;;;;;EAKA+D,eAAeA,CAAA;IACb,OAAO,IAAI,CAAC3L,YAAY;EAC1B;EAEA;;;;;EAKA4L,qBAAqBA,CAAA;IACnB,OAAO,IAAI,CAACzL,kBAAkB;EAChC;EAEA;;;;;EAKA0L,YAAYA,CAAA;IACV,OAAO,IAAI,CAAC9L,SAAS;EACvB;;AA1kCF+L,OAAA,CAAA9M,SAAA,GAAAA,SAAA;AAkFSA,SAAA,CAAAkM,kBAAkB,GAAG;EAC1Ba,EAAE,EAAE;CACL;AAEM/M,SAAA,CAAA4C,IAAI,GAAG,MAAM,IAAI","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}