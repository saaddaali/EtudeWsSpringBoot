{"ast":null,"code":"/* eslint-disable class-methods-use-this */\n/* eslint-disable no-underscore-dangle */\n\nimport os from 'node:os';\nimport path from 'node:path';\nimport fsPromises from 'node:fs/promises';\nimport { EventEmitter } from 'node:events';\nimport { StringDecoder } from 'node:string_decoder';\nimport { hexoid } from 'hexoid';\nimport once from 'once';\nimport dezalgo from 'dezalgo';\nimport { octetstream, querystring, multipart, json } from './plugins/index.js';\nimport PersistentFile from './PersistentFile.js';\nimport VolatileFile from './VolatileFile.js';\nimport DummyParser from './parsers/Dummy.js';\nimport MultipartParser from './parsers/Multipart.js';\nimport * as errors from './FormidableError.js';\nimport FormidableError from './FormidableError.js';\nconst toHexoId = hexoid(25);\nconst DEFAULT_OPTIONS = {\n  maxFields: 1000,\n  maxFieldsSize: 20 * 1024 * 1024,\n  maxFiles: Infinity,\n  maxFileSize: 200 * 1024 * 1024,\n  maxTotalFileSize: undefined,\n  minFileSize: 1,\n  allowEmptyFiles: false,\n  createDirsFromUploads: false,\n  keepExtensions: false,\n  encoding: 'utf-8',\n  hashAlgorithm: false,\n  uploadDir: os.tmpdir(),\n  enabledPlugins: [octetstream, querystring, multipart, json],\n  fileWriteStreamHandler: null,\n  defaultInvalidName: 'invalid-name',\n  filter(_part) {\n    return true;\n  },\n  filename: undefined\n};\nfunction hasOwnProp(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\nconst decorateForceSequential = function (promiseCreator) {\n  /* forces a function that returns a promise to be sequential\n  useful for fs  for example */\n  let lastPromise = Promise.resolve();\n  return async function (...x) {\n    const promiseWeAreWaitingFor = lastPromise;\n    let currentPromise;\n    let callback;\n    // we need to change lastPromise before await anything,\n    // otherwise 2 calls might wait the same thing\n    lastPromise = new Promise(function (resolve) {\n      callback = resolve;\n    });\n    await promiseWeAreWaitingFor;\n    currentPromise = promiseCreator(...x);\n    currentPromise.then(callback).catch(callback);\n    return currentPromise;\n  };\n};\nconst createNecessaryDirectoriesAsync = decorateForceSequential(function (filePath) {\n  const directoryname = path.dirname(filePath);\n  return fsPromises.mkdir(directoryname, {\n    recursive: true\n  });\n});\nconst invalidExtensionChar = c => {\n  const code = c.charCodeAt(0);\n  return !(code === 46 ||\n  // .\n  code >= 48 && code <= 57 || code >= 65 && code <= 90 || code >= 97 && code <= 122);\n};\nclass IncomingForm extends EventEmitter {\n  constructor(options = {}) {\n    super();\n    this.options = {\n      ...DEFAULT_OPTIONS,\n      ...options\n    };\n    if (!this.options.maxTotalFileSize) {\n      this.options.maxTotalFileSize = this.options.maxFileSize;\n    }\n    const dir = path.resolve(this.options.uploadDir || this.options.uploaddir || os.tmpdir());\n    this.uploaddir = dir;\n    this.uploadDir = dir;\n\n    // initialize with null\n    ['error', 'headers', 'type', 'bytesExpected', 'bytesReceived', '_parser', 'req'].forEach(key => {\n      this[key] = null;\n    });\n    this._setUpRename();\n    this._flushing = 0;\n    this._fieldsSize = 0;\n    this._totalFileSize = 0;\n    this._plugins = [];\n    this.openedFiles = [];\n    this.options.enabledPlugins = [].concat(this.options.enabledPlugins).filter(Boolean);\n    if (this.options.enabledPlugins.length === 0) {\n      throw new FormidableError('expect at least 1 enabled builtin plugin, see options.enabledPlugins', errors.missingPlugin);\n    }\n    this.options.enabledPlugins.forEach(plugin => {\n      this.use(plugin);\n    });\n    this._setUpMaxFields();\n    this._setUpMaxFiles();\n    this.ended = undefined;\n    this.type = undefined;\n  }\n  use(plugin) {\n    if (typeof plugin !== 'function') {\n      throw new FormidableError('.use: expect `plugin` to be a function', errors.pluginFunction);\n    }\n    this._plugins.push(plugin.bind(this));\n    return this;\n  }\n  pause() {\n    try {\n      this.req.pause();\n    } catch (err) {\n      // the stream was destroyed\n      if (!this.ended) {\n        // before it was completed, crash & burn\n        this._error(err);\n      }\n      return false;\n    }\n    return true;\n  }\n  resume() {\n    try {\n      this.req.resume();\n    } catch (err) {\n      // the stream was destroyed\n      if (!this.ended) {\n        // before it was completed, crash & burn\n        this._error(err);\n      }\n      return false;\n    }\n    return true;\n  }\n\n  // returns a promise if no callback is provided\n  async parse(req, cb) {\n    this.req = req;\n    let promise;\n\n    // Setup callback first, so we don't miss anything from data events emitted immediately.\n    if (!cb) {\n      let resolveRef;\n      let rejectRef;\n      promise = new Promise((resolve, reject) => {\n        resolveRef = resolve;\n        rejectRef = reject;\n      });\n      cb = (err, fields, files) => {\n        if (err) {\n          rejectRef(err);\n        } else {\n          resolveRef([fields, files]);\n        }\n      };\n    }\n    const callback = once(dezalgo(cb));\n    this.fields = {};\n    const files = {};\n    this.on('field', (name, value) => {\n      if (this.type === 'multipart' || this.type === 'urlencoded') {\n        if (!hasOwnProp(this.fields, name)) {\n          this.fields[name] = [value];\n        } else {\n          this.fields[name].push(value);\n        }\n      } else {\n        this.fields[name] = value;\n      }\n    });\n    this.on('file', (name, file) => {\n      if (!hasOwnProp(files, name)) {\n        files[name] = [file];\n      } else {\n        files[name].push(file);\n      }\n    });\n    this.on('error', err => {\n      callback(err, this.fields, files);\n    });\n    this.on('end', () => {\n      callback(null, this.fields, files);\n    });\n\n    // Parse headers and setup the parser, ready to start listening for data.\n    await this.writeHeaders(req.headers);\n\n    // Start listening for data.\n    req.on('error', err => {\n      this._error(err);\n    }).on('aborted', () => {\n      this.emit('aborted');\n      this._error(new FormidableError('Request aborted', errors.aborted));\n    }).on('data', buffer => {\n      try {\n        this.write(buffer);\n      } catch (err) {\n        this._error(err);\n      }\n    }).on('end', () => {\n      if (this.error) {\n        return;\n      }\n      if (this._parser) {\n        this._parser.end();\n      }\n    });\n    if (promise) {\n      return promise;\n    }\n    return this;\n  }\n  async writeHeaders(headers) {\n    this.headers = headers;\n    this._parseContentLength();\n    await this._parseContentType();\n    if (!this._parser) {\n      this._error(new FormidableError('no parser found', errors.noParser, 415) // Unsupported Media Type\n      );\n      return;\n    }\n    this._parser.once('error', error => {\n      this._error(error);\n    });\n  }\n  write(buffer) {\n    if (this.error) {\n      return null;\n    }\n    if (!this._parser) {\n      this._error(new FormidableError('uninitialized parser', errors.uninitializedParser));\n      return null;\n    }\n    this.bytesReceived += buffer.length;\n    this.emit('progress', this.bytesReceived, this.bytesExpected);\n    this._parser.write(buffer);\n    return this.bytesReceived;\n  }\n  onPart(part) {\n    // this method can be overwritten by the user\n    return this._handlePart(part);\n  }\n  async _handlePart(part) {\n    if (part.originalFilename && typeof part.originalFilename !== 'string') {\n      this._error(new FormidableError(`the part.originalFilename should be string when it exists`, errors.filenameNotString));\n      return;\n    }\n\n    // This MUST check exactly for undefined. You can not change it to !part.originalFilename.\n\n    // todo: uncomment when switch tests to Jest\n    // console.log(part);\n\n    // ? NOTE(@tunnckocore): no it can be any falsey value, it most probably depends on what's returned\n    // from somewhere else. Where recently I changed the return statements\n    // and such thing because code style\n    // ? NOTE(@tunnckocore): or even better, if there is no mimetype, then it's for sure a field\n    // ? NOTE(@tunnckocore): originalFilename is an empty string when a field?\n    if (!part.mimetype) {\n      let value = '';\n      const decoder = new StringDecoder(part.transferEncoding || this.options.encoding);\n      part.on('data', buffer => {\n        this._fieldsSize += buffer.length;\n        if (this._fieldsSize > this.options.maxFieldsSize) {\n          this._error(new FormidableError(`options.maxFieldsSize (${this.options.maxFieldsSize} bytes) exceeded, received ${this._fieldsSize} bytes of field data`, errors.maxFieldsSizeExceeded, 413) // Payload Too Large\n          );\n          return;\n        }\n        value += decoder.write(buffer);\n      });\n      part.on('end', () => {\n        this.emit('field', part.name, value);\n      });\n      return;\n    }\n    if (!this.options.filter(part)) {\n      return;\n    }\n    this._flushing += 1;\n    let fileSize = 0;\n    const newFilename = this._getNewName(part);\n    const filepath = this._joinDirectoryName(newFilename);\n    const file = await this._newFile({\n      newFilename,\n      filepath,\n      originalFilename: part.originalFilename,\n      mimetype: part.mimetype\n    });\n    file.on('error', err => {\n      this._error(err);\n    });\n    this.emit('fileBegin', part.name, file);\n    file.open();\n    this.openedFiles.push(file);\n    part.on('data', buffer => {\n      this._totalFileSize += buffer.length;\n      fileSize += buffer.length;\n      if (this._totalFileSize > this.options.maxTotalFileSize) {\n        this._error(new FormidableError(`options.maxTotalFileSize (${this.options.maxTotalFileSize} bytes) exceeded, received ${this._totalFileSize} bytes of file data`, errors.biggerThanTotalMaxFileSize, 413));\n        return;\n      }\n      if (buffer.length === 0) {\n        return;\n      }\n      this.pause();\n      file.write(buffer, () => {\n        this.resume();\n      });\n    });\n    part.on('end', () => {\n      if (!this.options.allowEmptyFiles && fileSize === 0) {\n        this._error(new FormidableError(`options.allowEmptyFiles is false, file size should be greater than 0`, errors.noEmptyFiles, 400));\n        return;\n      }\n      if (fileSize < this.options.minFileSize) {\n        this._error(new FormidableError(`options.minFileSize (${this.options.minFileSize} bytes) inferior, received ${fileSize} bytes of file data`, errors.smallerThanMinFileSize, 400));\n        return;\n      }\n      if (fileSize > this.options.maxFileSize) {\n        this._error(new FormidableError(`options.maxFileSize (${this.options.maxFileSize} bytes), received ${fileSize} bytes of file data`, errors.biggerThanMaxFileSize, 413));\n        return;\n      }\n      file.end(() => {\n        this._flushing -= 1;\n        this.emit('file', part.name, file);\n        this._maybeEnd();\n      });\n    });\n  }\n\n  // eslint-disable-next-line max-statements\n  async _parseContentType() {\n    if (this.bytesExpected === 0) {\n      this._parser = new DummyParser(this, this.options);\n      return;\n    }\n    if (!this.headers['content-type']) {\n      this._error(new FormidableError('bad content-type header, no content-type', errors.missingContentType, 400));\n      return;\n    }\n    new DummyParser(this, this.options);\n    const results = [];\n    await Promise.all(this._plugins.map(async (plugin, idx) => {\n      let pluginReturn = null;\n      try {\n        pluginReturn = (await plugin(this, this.options)) || this;\n      } catch (err) {\n        // directly throw from the `form.parse` method;\n        // there is no other better way, except a handle through options\n        const error = new FormidableError(`plugin on index ${idx} failed with: ${err.message}`, errors.pluginFailed, 500);\n        error.idx = idx;\n        throw error;\n      }\n      Object.assign(this, pluginReturn);\n\n      // todo: use Set/Map and pass plugin name instead of the `idx` index\n      this.emit('plugin', idx, pluginReturn);\n    }));\n    this.emit('pluginsResults', results);\n  }\n  _error(err, eventName = 'error') {\n    if (this.error || this.ended) {\n      return;\n    }\n    this.req = null;\n    this.error = err;\n    this.emit(eventName, err);\n    this.openedFiles.forEach(file => {\n      file.destroy();\n    });\n  }\n  _parseContentLength() {\n    this.bytesReceived = 0;\n    if (this.headers['content-length']) {\n      this.bytesExpected = parseInt(this.headers['content-length'], 10);\n    } else if (this.headers['transfer-encoding'] === undefined) {\n      this.bytesExpected = 0;\n    }\n    if (this.bytesExpected !== null) {\n      this.emit('progress', this.bytesReceived, this.bytesExpected);\n    }\n  }\n  _newParser() {\n    return new MultipartParser(this.options);\n  }\n  async _newFile({\n    filepath,\n    originalFilename,\n    mimetype,\n    newFilename\n  }) {\n    if (this.options.fileWriteStreamHandler) {\n      return new VolatileFile({\n        newFilename,\n        filepath,\n        originalFilename,\n        mimetype,\n        createFileWriteStream: this.options.fileWriteStreamHandler,\n        hashAlgorithm: this.options.hashAlgorithm\n      });\n    }\n    if (this.options.createDirsFromUploads) {\n      try {\n        await createNecessaryDirectoriesAsync(filepath);\n      } catch (errorCreatingDir) {\n        this._error(new FormidableError(`cannot create directory`, errors.cannotCreateDir, 409));\n      }\n    }\n    return new PersistentFile({\n      newFilename,\n      filepath,\n      originalFilename,\n      mimetype,\n      hashAlgorithm: this.options.hashAlgorithm\n    });\n  }\n  _getFileName(headerValue) {\n    // matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n    const m = headerValue.match(/\\bfilename=(\"(.*?)\"|([^()<>{}[\\]@,;:\"?=\\s/\\t]+))($|;\\s)/i);\n    if (!m) return null;\n    const match = m[2] || m[3] || '';\n    let originalFilename = match.substr(match.lastIndexOf('\\\\') + 1);\n    originalFilename = originalFilename.replace(/%22/g, '\"');\n    originalFilename = originalFilename.replace(/&#([\\d]{4});/g, (_, code) => String.fromCharCode(code));\n    return originalFilename;\n  }\n\n  // able to get composed extension with multiple dots\n  // \"a.b.c\" -> \".b.c\"\n  // as opposed to path.extname -> \".c\"\n  _getExtension(str) {\n    if (!str) {\n      return '';\n    }\n    const basename = path.basename(str);\n    const firstDot = basename.indexOf('.');\n    const lastDot = basename.lastIndexOf('.');\n    let rawExtname = path.extname(basename);\n    if (firstDot !== lastDot) {\n      rawExtname = basename.slice(firstDot);\n    }\n    let filtered;\n    const firstInvalidIndex = Array.from(rawExtname).findIndex(invalidExtensionChar);\n    if (firstInvalidIndex === -1) {\n      filtered = rawExtname;\n    } else {\n      filtered = rawExtname.substring(0, firstInvalidIndex);\n    }\n    if (filtered === '.') {\n      return '';\n    }\n    return filtered;\n  }\n  _joinDirectoryName(name) {\n    const newPath = path.join(this.uploadDir, name);\n\n    // prevent directory traversal attacks\n    if (!newPath.startsWith(this.uploadDir)) {\n      return path.join(this.uploadDir, this.options.defaultInvalidName);\n    }\n    return newPath;\n  }\n  _setUpRename() {\n    const hasRename = typeof this.options.filename === 'function';\n    if (hasRename) {\n      this._getNewName = part => {\n        let ext = '';\n        let name = this.options.defaultInvalidName;\n        if (part.originalFilename) {\n          // can be null\n          ({\n            ext,\n            name\n          } = path.parse(part.originalFilename));\n          if (this.options.keepExtensions !== true) {\n            ext = '';\n          }\n        }\n        return this.options.filename.call(this, name, ext, part, this);\n      };\n    } else {\n      this._getNewName = part => {\n        const name = toHexoId();\n        if (part && this.options.keepExtensions) {\n          const originalFilename = typeof part === 'string' ? part : part.originalFilename;\n          return `${name}${this._getExtension(originalFilename)}`;\n        }\n        return name;\n      };\n    }\n  }\n  _setUpMaxFields() {\n    if (this.options.maxFields !== Infinity) {\n      let fieldsCount = 0;\n      this.on('field', () => {\n        fieldsCount += 1;\n        if (fieldsCount > this.options.maxFields) {\n          this._error(new FormidableError(`options.maxFields (${this.options.maxFields}) exceeded`, errors.maxFieldsExceeded, 413));\n        }\n      });\n    }\n  }\n  _setUpMaxFiles() {\n    if (this.options.maxFiles !== Infinity) {\n      let fileCount = 0;\n      this.on('fileBegin', () => {\n        fileCount += 1;\n        if (fileCount > this.options.maxFiles) {\n          this._error(new FormidableError(`options.maxFiles (${this.options.maxFiles}) exceeded`, errors.maxFilesExceeded, 413));\n        }\n      });\n    }\n  }\n  _maybeEnd() {\n    if (!this.ended || this._flushing || this.error) {\n      return;\n    }\n    this.req = null;\n    this.emit('end');\n  }\n}\nexport default IncomingForm;\nexport { DEFAULT_OPTIONS };","map":{"version":3,"names":["os","path","fsPromises","EventEmitter","StringDecoder","hexoid","once","dezalgo","octetstream","querystring","multipart","json","PersistentFile","VolatileFile","DummyParser","MultipartParser","errors","FormidableError","toHexoId","DEFAULT_OPTIONS","maxFields","maxFieldsSize","maxFiles","Infinity","maxFileSize","maxTotalFileSize","undefined","minFileSize","allowEmptyFiles","createDirsFromUploads","keepExtensions","encoding","hashAlgorithm","uploadDir","tmpdir","enabledPlugins","fileWriteStreamHandler","defaultInvalidName","filter","_part","filename","hasOwnProp","obj","key","Object","prototype","hasOwnProperty","call","decorateForceSequential","promiseCreator","lastPromise","Promise","resolve","x","promiseWeAreWaitingFor","currentPromise","callback","then","catch","createNecessaryDirectoriesAsync","filePath","directoryname","dirname","mkdir","recursive","invalidExtensionChar","c","code","charCodeAt","IncomingForm","constructor","options","dir","uploaddir","forEach","_setUpRename","_flushing","_fieldsSize","_totalFileSize","_plugins","openedFiles","concat","Boolean","length","missingPlugin","plugin","use","_setUpMaxFields","_setUpMaxFiles","ended","type","pluginFunction","push","bind","pause","req","err","_error","resume","parse","cb","promise","resolveRef","rejectRef","reject","fields","files","on","name","value","file","writeHeaders","headers","emit","aborted","buffer","write","error","_parser","end","_parseContentLength","_parseContentType","noParser","uninitializedParser","bytesReceived","bytesExpected","onPart","part","_handlePart","originalFilename","filenameNotString","mimetype","decoder","transferEncoding","maxFieldsSizeExceeded","fileSize","newFilename","_getNewName","filepath","_joinDirectoryName","_newFile","open","biggerThanTotalMaxFileSize","noEmptyFiles","smallerThanMinFileSize","biggerThanMaxFileSize","_maybeEnd","missingContentType","results","all","map","idx","pluginReturn","message","pluginFailed","assign","eventName","destroy","parseInt","_newParser","createFileWriteStream","errorCreatingDir","cannotCreateDir","_getFileName","headerValue","m","match","substr","lastIndexOf","replace","_","String","fromCharCode","_getExtension","str","basename","firstDot","indexOf","lastDot","rawExtname","extname","slice","filtered","firstInvalidIndex","Array","from","findIndex","substring","newPath","join","startsWith","hasRename","ext","fieldsCount","maxFieldsExceeded","fileCount","maxFilesExceeded"],"sources":["/Users/soukaina/Desktop/hotel-reservation-management-soap/frontend-soapt/node_modules/formidable/src/Formidable.js"],"sourcesContent":["/* eslint-disable class-methods-use-this */\n/* eslint-disable no-underscore-dangle */\n\nimport os from 'node:os';\nimport path from 'node:path';\nimport fsPromises from 'node:fs/promises';\nimport { EventEmitter } from 'node:events';\nimport { StringDecoder } from 'node:string_decoder';\nimport { hexoid } from 'hexoid';\nimport once from 'once';\nimport dezalgo from 'dezalgo';\nimport { octetstream, querystring, multipart, json } from './plugins/index.js';\nimport PersistentFile from './PersistentFile.js';\nimport VolatileFile from './VolatileFile.js';\nimport DummyParser from './parsers/Dummy.js';\nimport MultipartParser from './parsers/Multipart.js';\nimport * as errors from './FormidableError.js';\nimport FormidableError from './FormidableError.js';\n\nconst toHexoId = hexoid(25);\nconst DEFAULT_OPTIONS = {\n  maxFields: 1000,\n  maxFieldsSize: 20 * 1024 * 1024,\n  maxFiles: Infinity,\n  maxFileSize: 200 * 1024 * 1024,\n  maxTotalFileSize: undefined,\n  minFileSize: 1,\n  allowEmptyFiles: false,\n  createDirsFromUploads: false,\n  keepExtensions: false,\n  encoding: 'utf-8',\n  hashAlgorithm: false,\n  uploadDir: os.tmpdir(),\n  enabledPlugins: [octetstream, querystring, multipart, json],\n  fileWriteStreamHandler: null,\n  defaultInvalidName: 'invalid-name',\n  filter(_part) {\n    return true;\n  },\n  filename: undefined,\n};\n\nfunction hasOwnProp(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\n\nconst decorateForceSequential = function (promiseCreator) {\n  /* forces a function that returns a promise to be sequential\n  useful for fs  for example */\n  let lastPromise = Promise.resolve();\n  return async function (...x) {\n      const promiseWeAreWaitingFor = lastPromise;\n      let currentPromise;\n      let callback;\n      // we need to change lastPromise before await anything,\n      // otherwise 2 calls might wait the same thing\n      lastPromise = new Promise(function (resolve) {\n          callback = resolve;\n      });\n      await promiseWeAreWaitingFor;\n      currentPromise = promiseCreator(...x);\n      currentPromise.then(callback).catch(callback);\n      return currentPromise;\n  };\n};\n\nconst createNecessaryDirectoriesAsync = decorateForceSequential(function (filePath) {\n  const directoryname = path.dirname(filePath);\n  return fsPromises.mkdir(directoryname, { recursive: true });\n});\n\nconst invalidExtensionChar = (c) => {\n  const code = c.charCodeAt(0);\n  return !(\n    code === 46 || // .\n    (code >= 48 && code <= 57) ||\n    (code >= 65 && code <= 90) ||\n    (code >= 97 && code <= 122)\n  );\n};\n\nclass IncomingForm extends EventEmitter {\n  constructor(options = {}) {\n    super();\n\n    this.options = { ...DEFAULT_OPTIONS, ...options };\n    if (!this.options.maxTotalFileSize) {\n      this.options.maxTotalFileSize = this.options.maxFileSize\n    }\n\n    const dir = path.resolve(\n      this.options.uploadDir || this.options.uploaddir || os.tmpdir(),\n    );\n\n    this.uploaddir = dir;\n    this.uploadDir = dir;\n\n    // initialize with null\n    [\n      'error',\n      'headers',\n      'type',\n      'bytesExpected',\n      'bytesReceived',\n      '_parser',\n      'req',\n    ].forEach((key) => {\n      this[key] = null;\n    });\n\n    this._setUpRename();\n\n    this._flushing = 0;\n    this._fieldsSize = 0;\n    this._totalFileSize = 0;\n    this._plugins = [];\n    this.openedFiles = [];\n\n    this.options.enabledPlugins = []\n      .concat(this.options.enabledPlugins)\n      .filter(Boolean);\n\n    if (this.options.enabledPlugins.length === 0) {\n      throw new FormidableError(\n        'expect at least 1 enabled builtin plugin, see options.enabledPlugins',\n        errors.missingPlugin,\n      );\n    }\n\n    this.options.enabledPlugins.forEach((plugin) => {\n      this.use(plugin);\n    });\n\n    this._setUpMaxFields();\n    this._setUpMaxFiles();\n    this.ended = undefined;\n    this.type = undefined;\n  }\n\n  use(plugin) {\n    if (typeof plugin !== 'function') {\n      throw new FormidableError(\n        '.use: expect `plugin` to be a function',\n        errors.pluginFunction,\n      );\n    }\n    this._plugins.push(plugin.bind(this));\n    return this;\n  }\n\n  pause () {\n    try {\n      this.req.pause();\n    } catch (err) {\n      // the stream was destroyed\n      if (!this.ended) {\n        // before it was completed, crash & burn\n        this._error(err);\n      }\n      return false;\n    }\n    return true;\n  }\n\n  resume () {\n    try {\n      this.req.resume();\n    } catch (err) {\n      // the stream was destroyed\n      if (!this.ended) {\n        // before it was completed, crash & burn\n        this._error(err);\n      }\n      return false;\n    }\n\n    return true;\n  }\n\n  // returns a promise if no callback is provided\n  async parse(req, cb) {\n    this.req = req;\n    let promise;\n\n    // Setup callback first, so we don't miss anything from data events emitted immediately.\n    if (!cb) {\n      let resolveRef;\n      let rejectRef;\n      promise = new Promise((resolve, reject) => {\n        resolveRef = resolve;\n        rejectRef = reject;\n      });\n      cb = (err, fields, files) => {\n        if (err) {\n          rejectRef(err);\n        } else {\n          resolveRef([fields, files]);\n        }\n      }\n    }\n    const callback = once(dezalgo(cb));\n    this.fields = {};\n    const files = {};\n\n    this.on('field', (name, value) => {\n      if (this.type === 'multipart' || this.type === 'urlencoded') {\n        if (!hasOwnProp(this.fields, name)) {\n          this.fields[name] = [value];\n        } else {\n          this.fields[name].push(value);\n        }\n      } else {\n        this.fields[name] = value;\n      }\n    });\n    this.on('file', (name, file) => {\n      if (!hasOwnProp(files, name)) {\n        files[name] = [file];\n      } else {\n        files[name].push(file);\n      }\n    });\n    this.on('error', (err) => {\n      callback(err, this.fields, files);\n    });\n    this.on('end', () => {\n      callback(null, this.fields, files);\n    });\n\n    // Parse headers and setup the parser, ready to start listening for data.\n    await this.writeHeaders(req.headers);\n\n    // Start listening for data.\n    req\n      .on('error', (err) => {\n        this._error(err);\n      })\n      .on('aborted', () => {\n        this.emit('aborted');\n        this._error(new FormidableError('Request aborted', errors.aborted));\n      })\n      .on('data', (buffer) => {\n        try {\n          this.write(buffer);\n        } catch (err) {\n          this._error(err);\n        }\n      })\n      .on('end', () => {\n        if (this.error) {\n          return;\n        }\n        if (this._parser) {\n          this._parser.end();\n        }\n      });\n    if (promise) {\n      return promise;\n    }\n    return this;\n  }\n\n  async writeHeaders(headers) {\n    this.headers = headers;\n    this._parseContentLength();\n    await this._parseContentType();\n\n    if (!this._parser) {\n      this._error(\n        new FormidableError(\n          'no parser found',\n          errors.noParser,\n          415, // Unsupported Media Type\n        ),\n      );\n      return;\n    }\n\n    this._parser.once('error', (error) => {\n      this._error(error);\n    });\n  }\n\n  write(buffer) {\n    if (this.error) {\n      return null;\n    }\n    if (!this._parser) {\n      this._error(\n        new FormidableError('uninitialized parser', errors.uninitializedParser),\n      );\n      return null;\n    }\n\n    this.bytesReceived += buffer.length;\n    this.emit('progress', this.bytesReceived, this.bytesExpected);\n\n    this._parser.write(buffer);\n\n    return this.bytesReceived;\n  }\n\n  onPart(part) {\n    // this method can be overwritten by the user\n    return this._handlePart(part);\n  }\n\n  async _handlePart(part) {\n    if (part.originalFilename && typeof part.originalFilename !== 'string') {\n      this._error(\n        new FormidableError(\n          `the part.originalFilename should be string when it exists`,\n          errors.filenameNotString,\n        ),\n      );\n      return;\n    }\n\n    // This MUST check exactly for undefined. You can not change it to !part.originalFilename.\n\n    // todo: uncomment when switch tests to Jest\n    // console.log(part);\n\n    // ? NOTE(@tunnckocore): no it can be any falsey value, it most probably depends on what's returned\n    // from somewhere else. Where recently I changed the return statements\n    // and such thing because code style\n    // ? NOTE(@tunnckocore): or even better, if there is no mimetype, then it's for sure a field\n    // ? NOTE(@tunnckocore): originalFilename is an empty string when a field?\n    if (!part.mimetype) {\n      let value = '';\n      const decoder = new StringDecoder(\n        part.transferEncoding || this.options.encoding,\n      );\n\n      part.on('data', (buffer) => {\n        this._fieldsSize += buffer.length;\n        if (this._fieldsSize > this.options.maxFieldsSize) {\n          this._error(\n            new FormidableError(\n              `options.maxFieldsSize (${this.options.maxFieldsSize} bytes) exceeded, received ${this._fieldsSize} bytes of field data`,\n              errors.maxFieldsSizeExceeded,\n              413, // Payload Too Large\n            ),\n          );\n          return;\n        }\n        value += decoder.write(buffer);\n      });\n\n      part.on('end', () => {\n        this.emit('field', part.name, value);\n      });\n      return;\n    }\n\n    if (!this.options.filter(part)) {\n      return;\n    }\n\n    this._flushing += 1;\n\n    let fileSize = 0;\n    const newFilename = this._getNewName(part);\n    const filepath = this._joinDirectoryName(newFilename);\n    const file = await this._newFile({\n      newFilename,\n      filepath,\n      originalFilename: part.originalFilename,\n      mimetype: part.mimetype,\n    });\n    file.on('error', (err) => {\n      this._error(err);\n    });\n    this.emit('fileBegin', part.name, file);\n\n    file.open();\n    this.openedFiles.push(file);\n\n    part.on('data', (buffer) => {\n      this._totalFileSize += buffer.length;\n      fileSize += buffer.length;\n\n      if (this._totalFileSize > this.options.maxTotalFileSize) {\n        this._error(\n          new FormidableError(\n            `options.maxTotalFileSize (${this.options.maxTotalFileSize} bytes) exceeded, received ${this._totalFileSize} bytes of file data`,\n            errors.biggerThanTotalMaxFileSize,\n            413,\n          ),\n        );\n        return;\n      }\n      if (buffer.length === 0) {\n        return;\n      }\n      this.pause();\n      file.write(buffer, () => {\n        this.resume();\n      });\n    });\n\n    part.on('end', () => {\n      if (!this.options.allowEmptyFiles && fileSize === 0) {\n        this._error(\n          new FormidableError(\n            `options.allowEmptyFiles is false, file size should be greater than 0`,\n            errors.noEmptyFiles,\n            400,\n          ),\n        );\n        return;\n      }\n      if (fileSize < this.options.minFileSize) {\n        this._error(\n          new FormidableError(\n            `options.minFileSize (${this.options.minFileSize} bytes) inferior, received ${fileSize} bytes of file data`,\n            errors.smallerThanMinFileSize,\n            400,\n          ),\n        );\n        return;\n      }\n      if (fileSize > this.options.maxFileSize) {\n        this._error(\n          new FormidableError(\n            `options.maxFileSize (${this.options.maxFileSize} bytes), received ${fileSize} bytes of file data`,\n            errors.biggerThanMaxFileSize,\n            413,\n          ),\n        );\n        return;\n      }\n\n      file.end(() => {\n        this._flushing -= 1;\n        this.emit('file', part.name, file);\n        this._maybeEnd();\n      });\n    });\n  }\n\n  // eslint-disable-next-line max-statements\n  async _parseContentType() {\n    if (this.bytesExpected === 0) {\n      this._parser = new DummyParser(this, this.options);\n      return;\n    }\n\n    if (!this.headers['content-type']) {\n      this._error(\n        new FormidableError(\n          'bad content-type header, no content-type',\n          errors.missingContentType,\n          400,\n        ),\n      );\n      return;\n    }\n\n\n    new DummyParser(this, this.options);\n\n    const results = [];\n    await Promise.all(this._plugins.map(async (plugin, idx) => {\n      let pluginReturn = null;\n      try {\n        pluginReturn = await plugin(this, this.options) || this;\n      } catch (err) {\n        // directly throw from the `form.parse` method;\n        // there is no other better way, except a handle through options\n        const error = new FormidableError(\n          `plugin on index ${idx} failed with: ${err.message}`,\n          errors.pluginFailed,\n          500,\n        );\n        error.idx = idx;\n        throw error;\n      }\n      Object.assign(this, pluginReturn);\n\n      // todo: use Set/Map and pass plugin name instead of the `idx` index\n      this.emit('plugin', idx, pluginReturn);\n    }));\n    this.emit('pluginsResults', results);\n  }\n\n  _error(err, eventName = 'error') {\n    if (this.error || this.ended) {\n      return;\n    }\n\n    this.req = null;\n    this.error = err;\n    this.emit(eventName, err);\n\n    this.openedFiles.forEach((file) => {\n      file.destroy();\n    });\n  }\n\n  _parseContentLength() {\n    this.bytesReceived = 0;\n    if (this.headers['content-length']) {\n      this.bytesExpected = parseInt(this.headers['content-length'], 10);\n    } else if (this.headers['transfer-encoding'] === undefined) {\n      this.bytesExpected = 0;\n    }\n\n    if (this.bytesExpected !== null) {\n      this.emit('progress', this.bytesReceived, this.bytesExpected);\n    }\n  }\n\n  _newParser() {\n    return new MultipartParser(this.options);\n  }\n\n  async _newFile({ filepath, originalFilename, mimetype, newFilename }) {\n    if (this.options.fileWriteStreamHandler) {\n      return new VolatileFile({\n        newFilename,\n        filepath,\n        originalFilename,\n        mimetype,\n        createFileWriteStream: this.options.fileWriteStreamHandler,\n        hashAlgorithm: this.options.hashAlgorithm,\n      });\n    }\n    if (this.options.createDirsFromUploads) {\n      try {\n        await createNecessaryDirectoriesAsync(filepath);\n      } catch (errorCreatingDir) {\n        this._error(new FormidableError(\n          `cannot create directory`,\n          errors.cannotCreateDir,\n          409,\n        ));\n      }\n    }\n    return new PersistentFile({\n      newFilename,\n      filepath,\n      originalFilename,\n      mimetype,\n      hashAlgorithm: this.options.hashAlgorithm,\n    });\n  }\n\n  _getFileName(headerValue) {\n    // matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n    const m = headerValue.match(\n      /\\bfilename=(\"(.*?)\"|([^()<>{}[\\]@,;:\"?=\\s/\\t]+))($|;\\s)/i,\n    );\n    if (!m) return null;\n\n    const match = m[2] || m[3] || '';\n    let originalFilename = match.substr(match.lastIndexOf('\\\\') + 1);\n    originalFilename = originalFilename.replace(/%22/g, '\"');\n    originalFilename = originalFilename.replace(/&#([\\d]{4});/g, (_, code) =>\n      String.fromCharCode(code),\n    );\n\n    return originalFilename;\n  }\n\n  // able to get composed extension with multiple dots\n  // \"a.b.c\" -> \".b.c\"\n  // as opposed to path.extname -> \".c\"\n  _getExtension(str) {\n    if (!str) {\n      return '';\n    }\n\n    const basename = path.basename(str);\n    const firstDot = basename.indexOf('.');\n    const lastDot = basename.lastIndexOf('.');\n    let rawExtname = path.extname(basename);\n\n    if (firstDot !== lastDot) {\n      rawExtname =  basename.slice(firstDot);\n    }\n\n    let filtered;\n    const firstInvalidIndex = Array.from(rawExtname).findIndex(invalidExtensionChar);\n    if (firstInvalidIndex === -1) {\n      filtered = rawExtname;\n    } else {\n      filtered = rawExtname.substring(0, firstInvalidIndex);\n    }\n    if (filtered === '.') {\n      return '';\n    }\n    return filtered;\n  }\n\n  _joinDirectoryName(name) {\n    const newPath = path.join(this.uploadDir, name);\n\n    // prevent directory traversal attacks\n    if (!newPath.startsWith(this.uploadDir)) {\n      return path.join(this.uploadDir, this.options.defaultInvalidName);\n    }\n\n    return newPath;\n  }\n\n  _setUpRename() {\n    const hasRename = typeof this.options.filename === 'function';\n    if (hasRename) {\n      this._getNewName = (part) => {\n        let ext = '';\n        let name = this.options.defaultInvalidName;\n        if (part.originalFilename) {\n          // can be null\n          ({ ext, name } = path.parse(part.originalFilename));\n          if (this.options.keepExtensions !== true) {\n            ext = '';\n          }\n        }\n        return this.options.filename.call(this, name, ext, part, this);\n      };\n    } else {\n      this._getNewName = (part) => {\n        const name = toHexoId();\n\n        if (part && this.options.keepExtensions) {\n          const originalFilename =\n            typeof part === 'string' ? part : part.originalFilename;\n          return `${name}${this._getExtension(originalFilename)}`;\n        }\n\n        return name;\n      };\n    }\n  }\n\n  _setUpMaxFields() {\n    if (this.options.maxFields !== Infinity) {\n      let fieldsCount = 0;\n      this.on('field', () => {\n        fieldsCount += 1;\n        if (fieldsCount > this.options.maxFields) {\n          this._error(\n            new FormidableError(\n              `options.maxFields (${this.options.maxFields}) exceeded`,\n              errors.maxFieldsExceeded,\n              413,\n            ),\n          );\n        }\n      });\n    }\n  }\n\n  _setUpMaxFiles() {\n    if (this.options.maxFiles !== Infinity) {\n      let fileCount = 0;\n      this.on('fileBegin', () => {\n        fileCount += 1;\n        if (fileCount > this.options.maxFiles) {\n          this._error(\n            new FormidableError(\n              `options.maxFiles (${this.options.maxFiles}) exceeded`,\n              errors.maxFilesExceeded,\n              413,\n            ),\n          );\n        }\n      });\n    }\n  }\n\n  _maybeEnd() {\n    if (!this.ended || this._flushing || this.error) {\n      return;\n    }\n    this.req = null;\n    this.emit('end');\n  }\n}\n\nexport default IncomingForm;\nexport { DEFAULT_OPTIONS };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}