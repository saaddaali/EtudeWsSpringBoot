{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateDigestValue = exports.findAncestorNs = exports.derToPem = exports.pemToDer = exports.normalizePem = exports.BASE64_REGEX = exports.EXTRACT_X509_CERTS = exports.PEM_FORMAT_REGEX = exports.encodeSpecialCharactersInText = exports.encodeSpecialCharactersInAttribute = exports.findChilds = exports.findChildren = exports.findAttr = exports.isArrayHasLength = void 0;\nconst xpath = require(\"xpath\");\nconst isDomNode = require(\"@xmldom/is-dom-node\");\nfunction isArrayHasLength(array) {\n  return Array.isArray(array) && array.length > 0;\n}\nexports.isArrayHasLength = isArrayHasLength;\nfunction attrEqualsExplicitly(attr, localName, namespace) {\n  return attr.localName === localName && (attr.namespaceURI === namespace || namespace == null);\n}\nfunction attrEqualsImplicitly(attr, localName, namespace, node) {\n  return attr.localName === localName && (!attr.namespaceURI && node?.namespaceURI === namespace || namespace == null);\n}\nfunction findAttr(element, localName, namespace) {\n  for (let i = 0; i < element.attributes.length; i++) {\n    const attr = element.attributes[i];\n    if (attrEqualsExplicitly(attr, localName, namespace) || attrEqualsImplicitly(attr, localName, namespace, element)) {\n      return attr;\n    }\n  }\n  return null;\n}\nexports.findAttr = findAttr;\nfunction findChildren(node, localName, namespace) {\n  const element = node.documentElement ?? node;\n  const res = [];\n  for (let i = 0; i < element.childNodes.length; i++) {\n    const child = element.childNodes[i];\n    if (isDomNode.isElementNode(child) && child.localName === localName && (child.namespaceURI === namespace || namespace == null)) {\n      res.push(child);\n    }\n  }\n  return res;\n}\nexports.findChildren = findChildren;\n/** @deprecated */\nfunction findChilds(node, localName, namespace) {\n  return findChildren(node, localName, namespace);\n}\nexports.findChilds = findChilds;\nconst xml_special_to_encoded_attribute = {\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  '\"': \"&quot;\",\n  \"\\r\": \"&#xD;\",\n  \"\\n\": \"&#xA;\",\n  \"\\t\": \"&#x9;\"\n};\nconst xml_special_to_encoded_text = {\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  \"\\r\": \"&#xD;\"\n};\nfunction encodeSpecialCharactersInAttribute(attributeValue) {\n  return attributeValue.replace(/([&<\"\\r\\n\\t])/g, function (str, item) {\n    /** Special character normalization.\n     * @see:\n     * - https://www.w3.org/TR/xml-c14n#ProcessingModel (Attribute Nodes)\n     * - https://www.w3.org/TR/xml-c14n#Example-Chars\n     */\n    return xml_special_to_encoded_attribute[item];\n  });\n}\nexports.encodeSpecialCharactersInAttribute = encodeSpecialCharactersInAttribute;\nfunction encodeSpecialCharactersInText(text) {\n  return text.replace(/([&<>\\r])/g, function (str, item) {\n    /** Special character normalization.\n     * @see:\n     * - https://www.w3.org/TR/xml-c14n#ProcessingModel (Text Nodes)\n     * - https://www.w3.org/TR/xml-c14n#Example-Chars\n     */\n    return xml_special_to_encoded_text[item];\n  });\n}\nexports.encodeSpecialCharactersInText = encodeSpecialCharactersInText;\n/**\n * PEM format has wide range of usages, but this library\n * is enforcing RFC7468 which focuses on PKIX, PKCS and CMS.\n *\n * https://www.rfc-editor.org/rfc/rfc7468\n *\n * PEM_FORMAT_REGEX is validating given PEM file against RFC7468 'stricttextualmsg' definition.\n *\n * With few exceptions;\n *  - 'posteb' MAY have 'eol', but it is not mandatory.\n *  - 'preeb' and 'posteb' lines are limited to 64 characters, but\n *     should not cause any issues in context of PKIX, PKCS and CMS.\n */\nexports.PEM_FORMAT_REGEX = new RegExp(\"^-----BEGIN [A-Z\\x20]{1,48}-----([^-]*)-----END [A-Z\\x20]{1,48}-----$\", \"s\");\nexports.EXTRACT_X509_CERTS = new RegExp(\"-----BEGIN CERTIFICATE-----[^-]*-----END CERTIFICATE-----\", \"g\");\nexports.BASE64_REGEX = new RegExp(\"^(?:[A-Za-z0-9\\\\+\\\\/]{4}\\\\n{0,1})*(?:[A-Za-z0-9\\\\+\\\\/]{2}==|[A-Za-z0-9\\\\+\\\\/]{3}=)?$\", \"s\");\n/**\n * -----BEGIN [LABEL]-----\n * base64([DATA])\n * -----END [LABEL]-----\n *\n * Above is shown what PEM file looks like. As can be seen, base64 data\n * can be in single line or multiple lines.\n *\n * This function normalizes PEM presentation to;\n *  - contain PEM header and footer as they are given\n *  - normalize line endings to '\\n'\n *  - normalize line length to maximum of 64 characters\n *  - ensure that 'preeb' has line ending '\\n'\n *\n * With a couple of notes:\n *  - 'eol' is normalized to '\\n'\n *\n * @param pem The PEM string to normalize to RFC7468 'stricttextualmsg' definition\n */\nfunction normalizePem(pem) {\n  return `${(pem.trim().replace(/(\\r\\n|\\r)/g, \"\\n\").match(/.{1,64}/g) ?? []).join(\"\\n\")}\\n`;\n}\nexports.normalizePem = normalizePem;\n/**\n * @param pem The PEM-encoded base64 certificate to strip headers from\n */\nfunction pemToDer(pem) {\n  if (!exports.PEM_FORMAT_REGEX.test(pem.trim())) {\n    throw new Error(\"Invalid PEM format.\");\n  }\n  return Buffer.from(pem.replace(/(\\r\\n|\\r)/g, \"\").replace(/-----BEGIN [A-Z\\x20]{1,48}-----\\n?/, \"\").replace(/-----END [A-Z\\x20]{1,48}-----\\n?/, \"\"), \"base64\");\n}\nexports.pemToDer = pemToDer;\n/**\n * @param der The DER-encoded base64 certificate to add PEM headers too\n * @param pemLabel The label of the header and footer to add\n */\nfunction derToPem(der, pemLabel) {\n  const base64Der = Buffer.isBuffer(der) ? der.toString(\"base64\").trim() : der.replace(/(\\r\\n|\\r)/g, \"\").trim();\n  if (exports.PEM_FORMAT_REGEX.test(base64Der)) {\n    return normalizePem(base64Der);\n  }\n  if (exports.BASE64_REGEX.test(base64Der.replace(/ /g, \"\"))) {\n    if (pemLabel == null) {\n      throw new Error(\"PEM label is required when DER is given.\");\n    }\n    const pem = `-----BEGIN ${pemLabel}-----\\n${base64Der.replace(/ /g, \"\")}\\n-----END ${pemLabel}-----`;\n    return normalizePem(pem);\n  }\n  throw new Error(\"Unknown DER format.\");\n}\nexports.derToPem = derToPem;\nfunction collectAncestorNamespaces(node, nsArray = []) {\n  if (!isDomNode.isElementNode(node.parentNode)) {\n    return nsArray;\n  }\n  const parent = node.parentNode;\n  if (!parent) {\n    return nsArray;\n  }\n  if (parent.attributes && parent.attributes.length > 0) {\n    for (let i = 0; i < parent.attributes.length; i++) {\n      const attr = parent.attributes[i];\n      if (attr && attr.nodeName && attr.nodeName.search(/^xmlns:?/) !== -1) {\n        nsArray.push({\n          prefix: attr.nodeName.replace(/^xmlns:?/, \"\"),\n          namespaceURI: attr.nodeValue || \"\"\n        });\n      }\n    }\n  }\n  return collectAncestorNamespaces(parent, nsArray);\n}\nfunction findNSPrefix(subset) {\n  const subsetAttributes = subset.attributes;\n  for (let k = 0; k < subsetAttributes.length; k++) {\n    const nodeName = subsetAttributes[k].nodeName;\n    if (nodeName.search(/^xmlns:?/) !== -1) {\n      return nodeName.replace(/^xmlns:?/, \"\");\n    }\n  }\n  return subset.prefix || \"\";\n}\nfunction isElementSubset(docSubset) {\n  return docSubset.every(node => isDomNode.isElementNode(node));\n}\n/**\n * Extract ancestor namespaces in order to import it to root of document subset\n * which is being canonicalized for non-exclusive c14n.\n *\n * @param doc - Usually a product from `new xmldom.DOMParser().parseFromString()`\n * @param docSubsetXpath - xpath query to get document subset being canonicalized\n * @param namespaceResolver - xpath namespace resolver\n * @returns i.e. [{prefix: \"saml\", namespaceURI: \"urn:oasis:names:tc:SAML:2.0:assertion\"}]\n */\nfunction findAncestorNs(doc, docSubsetXpath, namespaceResolver) {\n  if (docSubsetXpath == null) {\n    return [];\n  }\n  const docSubset = xpath.selectWithResolver(docSubsetXpath, doc, namespaceResolver);\n  if (!isArrayHasLength(docSubset)) {\n    return [];\n  }\n  if (!isElementSubset(docSubset)) {\n    throw new Error(\"Document subset must be list of elements\");\n  }\n  // Remove duplicate on ancestor namespace\n  const ancestorNs = collectAncestorNamespaces(docSubset[0]);\n  const ancestorNsWithoutDuplicate = [];\n  for (let i = 0; i < ancestorNs.length; i++) {\n    let notOnTheList = true;\n    for (const v in ancestorNsWithoutDuplicate) {\n      if (ancestorNsWithoutDuplicate[v].prefix === ancestorNs[i].prefix) {\n        notOnTheList = false;\n        break;\n      }\n    }\n    if (notOnTheList) {\n      ancestorNsWithoutDuplicate.push(ancestorNs[i]);\n    }\n  }\n  // Remove namespaces which are already declared in the subset with the same prefix\n  const returningNs = [];\n  const subsetNsPrefix = findNSPrefix(docSubset[0]);\n  for (const ancestorNs of ancestorNsWithoutDuplicate) {\n    if (ancestorNs.prefix !== subsetNsPrefix) {\n      returningNs.push(ancestorNs);\n    }\n  }\n  return returningNs;\n}\nexports.findAncestorNs = findAncestorNs;\nfunction validateDigestValue(digest, expectedDigest) {\n  const buffer = Buffer.from(digest, \"base64\");\n  const expectedBuffer = Buffer.from(expectedDigest, \"base64\");\n  if (typeof buffer.equals === \"function\") {\n    return buffer.equals(expectedBuffer);\n  }\n  if (buffer.length !== expectedBuffer.length) {\n    return false;\n  }\n  for (let i = 0; i < buffer.length; i++) {\n    if (buffer[i] !== expectedBuffer[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nexports.validateDigestValue = validateDigestValue;","map":{"version":3,"names":["xpath","require","isDomNode","isArrayHasLength","array","Array","isArray","length","exports","attrEqualsExplicitly","attr","localName","namespace","namespaceURI","attrEqualsImplicitly","node","findAttr","element","i","attributes","findChildren","documentElement","res","childNodes","child","isElementNode","push","findChilds","xml_special_to_encoded_attribute","xml_special_to_encoded_text","encodeSpecialCharactersInAttribute","attributeValue","replace","str","item","encodeSpecialCharactersInText","text","PEM_FORMAT_REGEX","RegExp","EXTRACT_X509_CERTS","BASE64_REGEX","normalizePem","pem","trim","match","join","pemToDer","test","Error","Buffer","from","derToPem","der","pemLabel","base64Der","isBuffer","toString","collectAncestorNamespaces","nsArray","parentNode","parent","nodeName","search","prefix","nodeValue","findNSPrefix","subset","subsetAttributes","k","isElementSubset","docSubset","every","findAncestorNs","doc","docSubsetXpath","namespaceResolver","selectWithResolver","ancestorNs","ancestorNsWithoutDuplicate","notOnTheList","v","returningNs","subsetNsPrefix","validateDigestValue","digest","expectedDigest","buffer","expectedBuffer","equals"],"sources":["/Users/soukaina/Desktop/hotel-reservation-management-soap/frontend-soapt/node_modules/xml-crypto/src/utils.ts"],"sourcesContent":["import * as xpath from \"xpath\";\nimport type { NamespacePrefix } from \"./types\";\nimport * as isDomNode from \"@xmldom/is-dom-node\";\n\nexport function isArrayHasLength(array: unknown): array is unknown[] {\n  return Array.isArray(array) && array.length > 0;\n}\n\nfunction attrEqualsExplicitly(attr: Attr, localName: string, namespace?: string) {\n  return attr.localName === localName && (attr.namespaceURI === namespace || namespace == null);\n}\n\nfunction attrEqualsImplicitly(attr: Attr, localName: string, namespace?: string, node?: Element) {\n  return (\n    attr.localName === localName &&\n    ((!attr.namespaceURI && node?.namespaceURI === namespace) || namespace == null)\n  );\n}\n\nexport function findAttr(element: Element, localName: string, namespace?: string) {\n  for (let i = 0; i < element.attributes.length; i++) {\n    const attr = element.attributes[i];\n\n    if (\n      attrEqualsExplicitly(attr, localName, namespace) ||\n      attrEqualsImplicitly(attr, localName, namespace, element)\n    ) {\n      return attr;\n    }\n  }\n  return null;\n}\n\nexport function findChildren(node: Node | Document, localName: string, namespace?: string) {\n  const element = (node as Document).documentElement ?? node;\n  const res: Element[] = [];\n  for (let i = 0; i < element.childNodes.length; i++) {\n    const child = element.childNodes[i];\n    if (\n      isDomNode.isElementNode(child) &&\n      child.localName === localName &&\n      (child.namespaceURI === namespace || namespace == null)\n    ) {\n      res.push(child);\n    }\n  }\n  return res;\n}\n\n/** @deprecated */\nexport function findChilds(node: Node | Document, localName: string, namespace?: string) {\n  return findChildren(node, localName, namespace);\n}\n\nconst xml_special_to_encoded_attribute = {\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  '\"': \"&quot;\",\n  \"\\r\": \"&#xD;\",\n  \"\\n\": \"&#xA;\",\n  \"\\t\": \"&#x9;\",\n};\n\nconst xml_special_to_encoded_text = {\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  \"\\r\": \"&#xD;\",\n};\n\nexport function encodeSpecialCharactersInAttribute(attributeValue) {\n  return attributeValue.replace(/([&<\"\\r\\n\\t])/g, function (str, item) {\n    /** Special character normalization.\n     * @see:\n     * - https://www.w3.org/TR/xml-c14n#ProcessingModel (Attribute Nodes)\n     * - https://www.w3.org/TR/xml-c14n#Example-Chars\n     */\n    return xml_special_to_encoded_attribute[item];\n  });\n}\n\nexport function encodeSpecialCharactersInText(text: string): string {\n  return text.replace(/([&<>\\r])/g, function (str, item) {\n    /** Special character normalization.\n     * @see:\n     * - https://www.w3.org/TR/xml-c14n#ProcessingModel (Text Nodes)\n     * - https://www.w3.org/TR/xml-c14n#Example-Chars\n     */\n    return xml_special_to_encoded_text[item];\n  });\n}\n\n/**\n * PEM format has wide range of usages, but this library\n * is enforcing RFC7468 which focuses on PKIX, PKCS and CMS.\n *\n * https://www.rfc-editor.org/rfc/rfc7468\n *\n * PEM_FORMAT_REGEX is validating given PEM file against RFC7468 'stricttextualmsg' definition.\n *\n * With few exceptions;\n *  - 'posteb' MAY have 'eol', but it is not mandatory.\n *  - 'preeb' and 'posteb' lines are limited to 64 characters, but\n *     should not cause any issues in context of PKIX, PKCS and CMS.\n */\nexport const PEM_FORMAT_REGEX = new RegExp(\n  \"^-----BEGIN [A-Z\\x20]{1,48}-----([^-]*)-----END [A-Z\\x20]{1,48}-----$\",\n  \"s\",\n);\nexport const EXTRACT_X509_CERTS = new RegExp(\n  \"-----BEGIN CERTIFICATE-----[^-]*-----END CERTIFICATE-----\",\n  \"g\",\n);\nexport const BASE64_REGEX = new RegExp(\n  \"^(?:[A-Za-z0-9\\\\+\\\\/]{4}\\\\n{0,1})*(?:[A-Za-z0-9\\\\+\\\\/]{2}==|[A-Za-z0-9\\\\+\\\\/]{3}=)?$\",\n  \"s\",\n);\n\n/**\n * -----BEGIN [LABEL]-----\n * base64([DATA])\n * -----END [LABEL]-----\n *\n * Above is shown what PEM file looks like. As can be seen, base64 data\n * can be in single line or multiple lines.\n *\n * This function normalizes PEM presentation to;\n *  - contain PEM header and footer as they are given\n *  - normalize line endings to '\\n'\n *  - normalize line length to maximum of 64 characters\n *  - ensure that 'preeb' has line ending '\\n'\n *\n * With a couple of notes:\n *  - 'eol' is normalized to '\\n'\n *\n * @param pem The PEM string to normalize to RFC7468 'stricttextualmsg' definition\n */\nexport function normalizePem(pem: string): string {\n  return `${(\n    pem\n      .trim()\n      .replace(/(\\r\\n|\\r)/g, \"\\n\")\n      .match(/.{1,64}/g) ?? []\n  ).join(\"\\n\")}\\n`;\n}\n\n/**\n * @param pem The PEM-encoded base64 certificate to strip headers from\n */\nexport function pemToDer(pem: string): Buffer {\n  if (!PEM_FORMAT_REGEX.test(pem.trim())) {\n    throw new Error(\"Invalid PEM format.\");\n  }\n\n  return Buffer.from(\n    pem\n      .replace(/(\\r\\n|\\r)/g, \"\")\n      .replace(/-----BEGIN [A-Z\\x20]{1,48}-----\\n?/, \"\")\n      .replace(/-----END [A-Z\\x20]{1,48}-----\\n?/, \"\"),\n    \"base64\",\n  );\n}\n\n/**\n * @param der The DER-encoded base64 certificate to add PEM headers too\n * @param pemLabel The label of the header and footer to add\n */\nexport function derToPem(\n  der: string | Buffer,\n  pemLabel?: \"CERTIFICATE\" | \"PRIVATE KEY\" | \"RSA PUBLIC KEY\",\n): string {\n  const base64Der = Buffer.isBuffer(der)\n    ? der.toString(\"base64\").trim()\n    : der.replace(/(\\r\\n|\\r)/g, \"\").trim();\n\n  if (PEM_FORMAT_REGEX.test(base64Der)) {\n    return normalizePem(base64Der);\n  }\n\n  if (BASE64_REGEX.test(base64Der.replace(/ /g, \"\"))) {\n    if (pemLabel == null) {\n      throw new Error(\"PEM label is required when DER is given.\");\n    }\n    const pem = `-----BEGIN ${pemLabel}-----\\n${base64Der.replace(\n      / /g,\n      \"\",\n    )}\\n-----END ${pemLabel}-----`;\n\n    return normalizePem(pem);\n  }\n\n  throw new Error(\"Unknown DER format.\");\n}\n\nfunction collectAncestorNamespaces(\n  node: Element,\n  nsArray: NamespacePrefix[] = [],\n): NamespacePrefix[] {\n  if (!isDomNode.isElementNode(node.parentNode)) {\n    return nsArray;\n  }\n\n  const parent: Element = node.parentNode;\n\n  if (!parent) {\n    return nsArray;\n  }\n\n  if (parent.attributes && parent.attributes.length > 0) {\n    for (let i = 0; i < parent.attributes.length; i++) {\n      const attr = parent.attributes[i];\n      if (attr && attr.nodeName && attr.nodeName.search(/^xmlns:?/) !== -1) {\n        nsArray.push({\n          prefix: attr.nodeName.replace(/^xmlns:?/, \"\"),\n          namespaceURI: attr.nodeValue || \"\",\n        });\n      }\n    }\n  }\n\n  return collectAncestorNamespaces(parent, nsArray);\n}\n\nfunction findNSPrefix(subset) {\n  const subsetAttributes = subset.attributes;\n  for (let k = 0; k < subsetAttributes.length; k++) {\n    const nodeName = subsetAttributes[k].nodeName;\n    if (nodeName.search(/^xmlns:?/) !== -1) {\n      return nodeName.replace(/^xmlns:?/, \"\");\n    }\n  }\n  return subset.prefix || \"\";\n}\n\nfunction isElementSubset(docSubset: Node[]): docSubset is Element[] {\n  return docSubset.every((node) => isDomNode.isElementNode(node));\n}\n\n/**\n * Extract ancestor namespaces in order to import it to root of document subset\n * which is being canonicalized for non-exclusive c14n.\n *\n * @param doc - Usually a product from `new xmldom.DOMParser().parseFromString()`\n * @param docSubsetXpath - xpath query to get document subset being canonicalized\n * @param namespaceResolver - xpath namespace resolver\n * @returns i.e. [{prefix: \"saml\", namespaceURI: \"urn:oasis:names:tc:SAML:2.0:assertion\"}]\n */\nexport function findAncestorNs(\n  doc: Document,\n  docSubsetXpath?: string,\n  namespaceResolver?: XPathNSResolver,\n): NamespacePrefix[] {\n  if (docSubsetXpath == null) {\n    return [];\n  }\n\n  const docSubset = xpath.selectWithResolver(docSubsetXpath, doc, namespaceResolver);\n\n  if (!isArrayHasLength(docSubset)) {\n    return [];\n  }\n\n  if (!isElementSubset(docSubset)) {\n    throw new Error(\"Document subset must be list of elements\");\n  }\n\n  // Remove duplicate on ancestor namespace\n  const ancestorNs = collectAncestorNamespaces(docSubset[0]);\n  const ancestorNsWithoutDuplicate: NamespacePrefix[] = [];\n  for (let i = 0; i < ancestorNs.length; i++) {\n    let notOnTheList = true;\n    for (const v in ancestorNsWithoutDuplicate) {\n      if (ancestorNsWithoutDuplicate[v].prefix === ancestorNs[i].prefix) {\n        notOnTheList = false;\n        break;\n      }\n    }\n\n    if (notOnTheList) {\n      ancestorNsWithoutDuplicate.push(ancestorNs[i]);\n    }\n  }\n\n  // Remove namespaces which are already declared in the subset with the same prefix\n  const returningNs: NamespacePrefix[] = [];\n  const subsetNsPrefix = findNSPrefix(docSubset[0]);\n  for (const ancestorNs of ancestorNsWithoutDuplicate) {\n    if (ancestorNs.prefix !== subsetNsPrefix) {\n      returningNs.push(ancestorNs);\n    }\n  }\n\n  return returningNs;\n}\n\nexport function validateDigestValue(digest, expectedDigest) {\n  const buffer = Buffer.from(digest, \"base64\");\n  const expectedBuffer = Buffer.from(expectedDigest, \"base64\");\n\n  if (typeof buffer.equals === \"function\") {\n    return buffer.equals(expectedBuffer);\n  }\n\n  if (buffer.length !== expectedBuffer.length) {\n    return false;\n  }\n\n  for (let i = 0; i < buffer.length; i++) {\n    if (buffer[i] !== expectedBuffer[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}