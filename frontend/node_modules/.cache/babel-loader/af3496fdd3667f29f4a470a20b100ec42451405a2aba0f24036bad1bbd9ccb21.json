{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.C14nCanonicalizationWithComments = exports.C14nCanonicalization = void 0;\nconst utils = require(\"./utils\");\nconst isDomNode = require(\"@xmldom/is-dom-node\");\nclass C14nCanonicalization {\n  constructor() {\n    this.includeComments = false;\n    this.includeComments = false;\n  }\n  attrCompare(a, b) {\n    if (!a.namespaceURI && b.namespaceURI) {\n      return -1;\n    }\n    if (!b.namespaceURI && a.namespaceURI) {\n      return 1;\n    }\n    const left = a.namespaceURI + a.localName;\n    const right = b.namespaceURI + b.localName;\n    if (left === right) {\n      return 0;\n    } else if (left < right) {\n      return -1;\n    } else {\n      return 1;\n    }\n  }\n  nsCompare(a, b) {\n    const attr1 = a.prefix;\n    const attr2 = b.prefix;\n    if (attr1 === attr2) {\n      return 0;\n    }\n    return attr1.localeCompare(attr2);\n  }\n  renderAttrs(node) {\n    let i;\n    let attr;\n    const attrListToRender = [];\n    if (isDomNode.isCommentNode(node)) {\n      return this.renderComment(node);\n    }\n    if (node.attributes) {\n      for (i = 0; i < node.attributes.length; ++i) {\n        attr = node.attributes[i];\n        //ignore namespace definition attributes\n        if (attr.name.indexOf(\"xmlns\") === 0) {\n          continue;\n        }\n        attrListToRender.push(attr);\n      }\n    }\n    attrListToRender.sort(this.attrCompare);\n    const res = attrListToRender.map(attr => {\n      return ` ${attr.name}=\"${utils.encodeSpecialCharactersInAttribute(attr.value)}\"`;\n    });\n    return res.join(\"\");\n  }\n  /**\n   * Create the string of all namespace declarations that should appear on this element\n   *\n   * @param node The node we now render\n   * @param prefixesInScope The prefixes defined on this node parents which are a part of the output set\n   * @param defaultNs The current default namespace\n   * @param defaultNsForPrefix\n   * @param ancestorNamespaces Import ancestor namespaces if it is specified\n   * @api private\n   */\n  renderNs(node, prefixesInScope, defaultNs, defaultNsForPrefix, ancestorNamespaces) {\n    let i;\n    let attr;\n    const res = [];\n    let newDefaultNs = defaultNs;\n    const nsListToRender = [];\n    const currNs = node.namespaceURI || \"\";\n    //handle the namespace of the node itself\n    if (node.prefix) {\n      if (prefixesInScope.indexOf(node.prefix) === -1) {\n        nsListToRender.push({\n          prefix: node.prefix,\n          namespaceURI: node.namespaceURI || defaultNsForPrefix[node.prefix]\n        });\n        prefixesInScope.push(node.prefix);\n      }\n    } else if (defaultNs !== currNs) {\n      //new default ns\n      newDefaultNs = node.namespaceURI || \"\";\n      res.push(' xmlns=\"', newDefaultNs, '\"');\n    }\n    //handle the attributes namespace\n    if (node.attributes) {\n      for (i = 0; i < node.attributes.length; ++i) {\n        attr = node.attributes[i];\n        //handle all prefixed attributes that are included in the prefix list and where\n        //the prefix is not defined already. New prefixes can only be defined by `xmlns:`.\n        if (attr.prefix === \"xmlns\" && prefixesInScope.indexOf(attr.localName) === -1) {\n          nsListToRender.push({\n            prefix: attr.localName,\n            namespaceURI: attr.value\n          });\n          prefixesInScope.push(attr.localName);\n        }\n        //handle all prefixed attributes that are not xmlns definitions and where\n        //the prefix is not defined already\n        if (attr.prefix && prefixesInScope.indexOf(attr.prefix) === -1 && attr.prefix !== \"xmlns\" && attr.prefix !== \"xml\") {\n          nsListToRender.push({\n            prefix: attr.prefix,\n            namespaceURI: attr.namespaceURI\n          });\n          prefixesInScope.push(attr.prefix);\n        }\n      }\n    }\n    if (utils.isArrayHasLength(ancestorNamespaces)) {\n      // Remove namespaces which are already present in nsListToRender\n      for (const ancestorNamespace of ancestorNamespaces) {\n        let alreadyListed = false;\n        for (const nsToRender of nsListToRender) {\n          if (nsToRender.prefix === ancestorNamespace.prefix && nsToRender.namespaceURI === ancestorNamespace.namespaceURI) {\n            alreadyListed = true;\n          }\n        }\n        if (!alreadyListed) {\n          nsListToRender.push(ancestorNamespace);\n        }\n      }\n    }\n    nsListToRender.sort(this.nsCompare);\n    //render namespaces\n    res.push(...nsListToRender.map(attr => {\n      if (attr.prefix) {\n        return ` xmlns:${attr.prefix}=\"${attr.namespaceURI}\"`;\n      }\n      return ` xmlns=\"${attr.namespaceURI}\"`;\n    }));\n    return {\n      rendered: res.join(\"\"),\n      newDefaultNs\n    };\n  }\n  /**\n   * @param node Node\n   */\n  processInner(node, prefixesInScope, defaultNs, defaultNsForPrefix, ancestorNamespaces) {\n    if (isDomNode.isCommentNode(node)) {\n      return this.renderComment(node);\n    }\n    if (node.data) {\n      return utils.encodeSpecialCharactersInText(node.data);\n    }\n    if (isDomNode.isElementNode(node)) {\n      let i;\n      let pfxCopy;\n      const ns = this.renderNs(node, prefixesInScope, defaultNs, defaultNsForPrefix, ancestorNamespaces);\n      const res = [\"<\", node.tagName, ns.rendered, this.renderAttrs(node), \">\"];\n      for (i = 0; i < node.childNodes.length; ++i) {\n        pfxCopy = prefixesInScope.slice(0);\n        res.push(this.processInner(node.childNodes[i], pfxCopy, ns.newDefaultNs, defaultNsForPrefix, []));\n      }\n      res.push(\"</\", node.tagName, \">\");\n      return res.join(\"\");\n    }\n    throw new Error(`Unable to canonicalize node type: ${node.nodeType}`);\n  }\n  // Thanks to deoxxa/xml-c14n for comment renderer\n  renderComment(node) {\n    if (!this.includeComments) {\n      return \"\";\n    }\n    const isOutsideDocument = node.ownerDocument === node.parentNode;\n    let isBeforeDocument = false;\n    let isAfterDocument = false;\n    if (isOutsideDocument) {\n      let nextNode = node;\n      let previousNode = node;\n      while (nextNode !== null) {\n        if (nextNode === node.ownerDocument.documentElement) {\n          isBeforeDocument = true;\n          break;\n        }\n        nextNode = nextNode.nextSibling;\n      }\n      while (previousNode !== null) {\n        if (previousNode === node.ownerDocument.documentElement) {\n          isAfterDocument = true;\n          break;\n        }\n        previousNode = previousNode.previousSibling;\n      }\n    }\n    const afterDocument = isAfterDocument ? \"\\n\" : \"\";\n    const beforeDocument = isBeforeDocument ? \"\\n\" : \"\";\n    const encodedText = utils.encodeSpecialCharactersInText(node.data);\n    return `${afterDocument}<!--${encodedText}-->${beforeDocument}`;\n  }\n  /**\n   * Perform canonicalization of the given node\n   *\n   * @param node\n   * @api public\n   */\n  process(node, options) {\n    options = options || {};\n    const defaultNs = options.defaultNs || \"\";\n    const defaultNsForPrefix = options.defaultNsForPrefix || {};\n    const ancestorNamespaces = options.ancestorNamespaces || [];\n    const prefixesInScope = [];\n    for (let i = 0; i < ancestorNamespaces.length; i++) {\n      prefixesInScope.push(ancestorNamespaces[i].prefix);\n    }\n    const res = this.processInner(node, prefixesInScope, defaultNs, defaultNsForPrefix, ancestorNamespaces);\n    return res;\n  }\n  getAlgorithmName() {\n    return \"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\";\n  }\n}\nexports.C14nCanonicalization = C14nCanonicalization;\n/**\n * Add c14n#WithComments here (very simple subclass)\n */\nclass C14nCanonicalizationWithComments extends C14nCanonicalization {\n  constructor() {\n    super();\n    this.includeComments = true;\n  }\n  getAlgorithmName() {\n    return \"http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments\";\n  }\n}\nexports.C14nCanonicalizationWithComments = C14nCanonicalizationWithComments;","map":{"version":3,"names":["utils","require","isDomNode","C14nCanonicalization","constructor","includeComments","attrCompare","a","b","namespaceURI","left","localName","right","nsCompare","attr1","prefix","attr2","localeCompare","renderAttrs","node","i","attr","attrListToRender","isCommentNode","renderComment","attributes","length","name","indexOf","push","sort","res","map","encodeSpecialCharactersInAttribute","value","join","renderNs","prefixesInScope","defaultNs","defaultNsForPrefix","ancestorNamespaces","newDefaultNs","nsListToRender","currNs","isArrayHasLength","ancestorNamespace","alreadyListed","nsToRender","rendered","processInner","data","encodeSpecialCharactersInText","isElementNode","pfxCopy","ns","tagName","childNodes","slice","Error","nodeType","isOutsideDocument","ownerDocument","parentNode","isBeforeDocument","isAfterDocument","nextNode","previousNode","documentElement","nextSibling","previousSibling","afterDocument","beforeDocument","encodedText","process","options","getAlgorithmName","exports","C14nCanonicalizationWithComments"],"sources":["/Users/soukaina/Desktop/hotel-reservation-management-soap/frontend-soapt/node_modules/xml-crypto/src/c14n-canonicalization.ts"],"sourcesContent":["import type {\n  CanonicalizationOrTransformationAlgorithm,\n  CanonicalizationOrTransformationAlgorithmProcessOptions,\n  NamespacePrefix,\n  RenderedNamespace,\n} from \"./types\";\nimport * as utils from \"./utils\";\nimport * as isDomNode from \"@xmldom/is-dom-node\";\n\nexport class C14nCanonicalization implements CanonicalizationOrTransformationAlgorithm {\n  protected includeComments = false;\n\n  constructor() {\n    this.includeComments = false;\n  }\n\n  attrCompare(a, b) {\n    if (!a.namespaceURI && b.namespaceURI) {\n      return -1;\n    }\n    if (!b.namespaceURI && a.namespaceURI) {\n      return 1;\n    }\n\n    const left = a.namespaceURI + a.localName;\n    const right = b.namespaceURI + b.localName;\n\n    if (left === right) {\n      return 0;\n    } else if (left < right) {\n      return -1;\n    } else {\n      return 1;\n    }\n  }\n\n  nsCompare(a, b) {\n    const attr1 = a.prefix;\n    const attr2 = b.prefix;\n    if (attr1 === attr2) {\n      return 0;\n    }\n    return attr1.localeCompare(attr2);\n  }\n\n  renderAttrs(node) {\n    let i;\n    let attr;\n    const attrListToRender: Attr[] = [];\n\n    if (isDomNode.isCommentNode(node)) {\n      return this.renderComment(node);\n    }\n\n    if (node.attributes) {\n      for (i = 0; i < node.attributes.length; ++i) {\n        attr = node.attributes[i];\n        //ignore namespace definition attributes\n        if (attr.name.indexOf(\"xmlns\") === 0) {\n          continue;\n        }\n        attrListToRender.push(attr);\n      }\n    }\n\n    attrListToRender.sort(this.attrCompare);\n\n    const res = attrListToRender.map((attr) => {\n      return ` ${attr.name}=\"${utils.encodeSpecialCharactersInAttribute(attr.value)}\"`;\n    });\n\n    return res.join(\"\");\n  }\n\n  /**\n   * Create the string of all namespace declarations that should appear on this element\n   *\n   * @param node The node we now render\n   * @param prefixesInScope The prefixes defined on this node parents which are a part of the output set\n   * @param defaultNs The current default namespace\n   * @param defaultNsForPrefix\n   * @param ancestorNamespaces Import ancestor namespaces if it is specified\n   * @api private\n   */\n  renderNs(\n    node: Element,\n    prefixesInScope: string[],\n    defaultNs: string,\n    defaultNsForPrefix: string,\n    ancestorNamespaces: NamespacePrefix[],\n  ): RenderedNamespace {\n    let i;\n    let attr;\n    const res: string[] = [];\n    let newDefaultNs = defaultNs;\n    const nsListToRender: { prefix: string; namespaceURI: string }[] = [];\n    const currNs = node.namespaceURI || \"\";\n\n    //handle the namespace of the node itself\n    if (node.prefix) {\n      if (prefixesInScope.indexOf(node.prefix) === -1) {\n        nsListToRender.push({\n          prefix: node.prefix,\n          namespaceURI: node.namespaceURI || defaultNsForPrefix[node.prefix],\n        });\n        prefixesInScope.push(node.prefix);\n      }\n    } else if (defaultNs !== currNs) {\n      //new default ns\n      newDefaultNs = node.namespaceURI || \"\";\n      res.push(' xmlns=\"', newDefaultNs, '\"');\n    }\n\n    //handle the attributes namespace\n    if (node.attributes) {\n      for (i = 0; i < node.attributes.length; ++i) {\n        attr = node.attributes[i];\n\n        //handle all prefixed attributes that are included in the prefix list and where\n        //the prefix is not defined already. New prefixes can only be defined by `xmlns:`.\n        if (attr.prefix === \"xmlns\" && prefixesInScope.indexOf(attr.localName) === -1) {\n          nsListToRender.push({ prefix: attr.localName, namespaceURI: attr.value });\n          prefixesInScope.push(attr.localName);\n        }\n\n        //handle all prefixed attributes that are not xmlns definitions and where\n        //the prefix is not defined already\n        if (\n          attr.prefix &&\n          prefixesInScope.indexOf(attr.prefix) === -1 &&\n          attr.prefix !== \"xmlns\" &&\n          attr.prefix !== \"xml\"\n        ) {\n          nsListToRender.push({ prefix: attr.prefix, namespaceURI: attr.namespaceURI });\n          prefixesInScope.push(attr.prefix);\n        }\n      }\n    }\n\n    if (utils.isArrayHasLength(ancestorNamespaces)) {\n      // Remove namespaces which are already present in nsListToRender\n      for (const ancestorNamespace of ancestorNamespaces) {\n        let alreadyListed = false;\n        for (const nsToRender of nsListToRender) {\n          if (\n            nsToRender.prefix === ancestorNamespace.prefix &&\n            nsToRender.namespaceURI === ancestorNamespace.namespaceURI\n          ) {\n            alreadyListed = true;\n          }\n        }\n\n        if (!alreadyListed) {\n          nsListToRender.push(ancestorNamespace);\n        }\n      }\n    }\n\n    nsListToRender.sort(this.nsCompare);\n\n    //render namespaces\n    res.push(\n      ...nsListToRender.map((attr) => {\n        if (attr.prefix) {\n          return ` xmlns:${attr.prefix}=\"${attr.namespaceURI}\"`;\n        }\n        return ` xmlns=\"${attr.namespaceURI}\"`;\n      }),\n    );\n\n    return { rendered: res.join(\"\"), newDefaultNs };\n  }\n\n  /**\n   * @param node Node\n   */\n  processInner(node, prefixesInScope, defaultNs, defaultNsForPrefix, ancestorNamespaces) {\n    if (isDomNode.isCommentNode(node)) {\n      return this.renderComment(node);\n    }\n    if (node.data) {\n      return utils.encodeSpecialCharactersInText(node.data);\n    }\n\n    if (isDomNode.isElementNode(node)) {\n      let i;\n      let pfxCopy;\n      const ns = this.renderNs(\n        node,\n        prefixesInScope,\n        defaultNs,\n        defaultNsForPrefix,\n        ancestorNamespaces,\n      );\n      const res = [\"<\", node.tagName, ns.rendered, this.renderAttrs(node), \">\"];\n\n      for (i = 0; i < node.childNodes.length; ++i) {\n        pfxCopy = prefixesInScope.slice(0);\n        res.push(\n          this.processInner(node.childNodes[i], pfxCopy, ns.newDefaultNs, defaultNsForPrefix, []),\n        );\n      }\n\n      res.push(\"</\", node.tagName, \">\");\n      return res.join(\"\");\n    }\n\n    throw new Error(`Unable to canonicalize node type: ${node.nodeType}`);\n  }\n\n  // Thanks to deoxxa/xml-c14n for comment renderer\n  renderComment(node: Comment) {\n    if (!this.includeComments) {\n      return \"\";\n    }\n\n    const isOutsideDocument = node.ownerDocument === node.parentNode;\n    let isBeforeDocument = false;\n    let isAfterDocument = false;\n\n    if (isOutsideDocument) {\n      let nextNode: ChildNode | null = node;\n      let previousNode: ChildNode | null = node;\n\n      while (nextNode !== null) {\n        if (nextNode === node.ownerDocument.documentElement) {\n          isBeforeDocument = true;\n          break;\n        }\n\n        nextNode = nextNode.nextSibling;\n      }\n\n      while (previousNode !== null) {\n        if (previousNode === node.ownerDocument.documentElement) {\n          isAfterDocument = true;\n          break;\n        }\n\n        previousNode = previousNode.previousSibling;\n      }\n    }\n\n    const afterDocument = isAfterDocument ? \"\\n\" : \"\";\n    const beforeDocument = isBeforeDocument ? \"\\n\" : \"\";\n    const encodedText = utils.encodeSpecialCharactersInText(node.data);\n\n    return `${afterDocument}<!--${encodedText}-->${beforeDocument}`;\n  }\n\n  /**\n   * Perform canonicalization of the given node\n   *\n   * @param node\n   * @api public\n   */\n  process(node: Node, options: CanonicalizationOrTransformationAlgorithmProcessOptions): string {\n    options = options || {};\n    const defaultNs = options.defaultNs || \"\";\n    const defaultNsForPrefix = options.defaultNsForPrefix || {};\n    const ancestorNamespaces = options.ancestorNamespaces || [];\n\n    const prefixesInScope: string[] = [];\n    for (let i = 0; i < ancestorNamespaces.length; i++) {\n      prefixesInScope.push(ancestorNamespaces[i].prefix);\n    }\n\n    const res = this.processInner(\n      node,\n      prefixesInScope,\n      defaultNs,\n      defaultNsForPrefix,\n      ancestorNamespaces,\n    );\n    return res;\n  }\n\n  getAlgorithmName() {\n    return \"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\";\n  }\n}\n\n/**\n * Add c14n#WithComments here (very simple subclass)\n */\nexport class C14nCanonicalizationWithComments extends C14nCanonicalization {\n  constructor() {\n    super();\n    this.includeComments = true;\n  }\n\n  getAlgorithmName() {\n    return \"http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments\";\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}