{"ast":null,"code":"/* eslint-disable no-underscore-dangle */\n\nimport OctetStreamParser from '../parsers/OctetStream.js';\nexport const octetStreamType = 'octet-stream';\n// the `options` is also available through the `options` / `formidable.options`\nexport default async function plugin(formidable, options) {\n  // the `this` context is always formidable, as the first argument of a plugin\n  // but this allows us to customize/test each plugin\n\n  /* istanbul ignore next */\n  const self = this || formidable;\n  if (/octet-stream/i.test(self.headers['content-type'])) {\n    await init.call(self, self, options);\n  }\n  return self;\n}\n\n// Note that it's a good practice (but it's up to you) to use the `this.options` instead\n// of the passed `options` (second) param, because when you decide\n// to test the plugin you can pass custom `this` context to it (and so `this.options`)\nasync function init(_self, _opts) {\n  this.type = octetStreamType;\n  const originalFilename = this.headers['x-file-name'];\n  const mimetype = this.headers['content-type'];\n  const thisPart = {\n    originalFilename,\n    mimetype\n  };\n  const newFilename = this._getNewName(thisPart);\n  const filepath = this._joinDirectoryName(newFilename);\n  const file = await this._newFile({\n    newFilename,\n    filepath,\n    originalFilename,\n    mimetype\n  });\n  this.emit('fileBegin', originalFilename, file);\n  file.open();\n  this.openedFiles.push(file);\n  this._flushing += 1;\n  this._parser = new OctetStreamParser(this.options);\n\n  // Keep track of writes that haven't finished so we don't emit the file before it's done being written\n  let outstandingWrites = 0;\n  this._parser.on('data', buffer => {\n    this.pause();\n    outstandingWrites += 1;\n    file.write(buffer, () => {\n      outstandingWrites -= 1;\n      this.resume();\n      if (this.ended) {\n        this._parser.emit('doneWritingFile');\n      }\n    });\n  });\n  this._parser.on('end', () => {\n    this._flushing -= 1;\n    this.ended = true;\n    const done = () => {\n      file.end(() => {\n        this.emit('file', 'file', file);\n        this._maybeEnd();\n      });\n    };\n    if (outstandingWrites === 0) {\n      done();\n    } else {\n      this._parser.once('doneWritingFile', done);\n    }\n  });\n  return this;\n}","map":{"version":3,"names":["OctetStreamParser","octetStreamType","plugin","formidable","options","self","test","headers","init","call","_self","_opts","type","originalFilename","mimetype","thisPart","newFilename","_getNewName","filepath","_joinDirectoryName","file","_newFile","emit","open","openedFiles","push","_flushing","_parser","outstandingWrites","on","buffer","pause","write","resume","ended","done","end","_maybeEnd","once"],"sources":["/Users/soukaina/Desktop/hotel-reservation-management-soap/frontend-soapt/node_modules/formidable/src/plugins/octetstream.js"],"sourcesContent":["/* eslint-disable no-underscore-dangle */\n\nimport OctetStreamParser from '../parsers/OctetStream.js';\n\nexport const octetStreamType = 'octet-stream';\n// the `options` is also available through the `options` / `formidable.options`\nexport default async function plugin(formidable, options) {\n  // the `this` context is always formidable, as the first argument of a plugin\n  // but this allows us to customize/test each plugin\n\n  /* istanbul ignore next */\n  const self = this || formidable;\n\n  if (/octet-stream/i.test(self.headers['content-type'])) {\n    await init.call(self, self, options);\n  }\n  return self;\n}\n\n// Note that it's a good practice (but it's up to you) to use the `this.options` instead\n// of the passed `options` (second) param, because when you decide\n// to test the plugin you can pass custom `this` context to it (and so `this.options`)\nasync function init(_self, _opts) {\n  this.type = octetStreamType;\n  const originalFilename = this.headers['x-file-name'];\n  const mimetype = this.headers['content-type'];\n\n  const thisPart = {\n    originalFilename,\n    mimetype,\n  };\n  const newFilename = this._getNewName(thisPart);\n  const filepath = this._joinDirectoryName(newFilename);\n  const file = await this._newFile({\n    newFilename,\n    filepath,\n    originalFilename,\n    mimetype,\n  });\n\n  this.emit('fileBegin', originalFilename, file);\n  file.open();\n  this.openedFiles.push(file);\n  this._flushing += 1;\n\n  this._parser = new OctetStreamParser(this.options);\n\n  // Keep track of writes that haven't finished so we don't emit the file before it's done being written\n  let outstandingWrites = 0;\n\n  this._parser.on('data', (buffer) => {\n    this.pause();\n    outstandingWrites += 1;\n\n    file.write(buffer, () => {\n      outstandingWrites -= 1;\n      this.resume();\n\n      if (this.ended) {\n        this._parser.emit('doneWritingFile');\n      }\n    });\n  });\n\n  this._parser.on('end', () => {\n    this._flushing -= 1;\n    this.ended = true;\n\n    const done = () => {\n      file.end(() => {\n        this.emit('file', 'file', file);\n        this._maybeEnd();\n      });\n    };\n\n    if (outstandingWrites === 0) {\n      done();\n    } else {\n      this._parser.once('doneWritingFile', done);\n    }\n  });\n\n  return this;\n}\n"],"mappings":"AAAA;;AAEA,OAAOA,iBAAiB,MAAM,2BAA2B;AAEzD,OAAO,MAAMC,eAAe,GAAG,cAAc;AAC7C;AACA,eAAe,eAAeC,MAAMA,CAACC,UAAU,EAAEC,OAAO,EAAE;EACxD;EACA;;EAEA;EACA,MAAMC,IAAI,GAAG,IAAI,IAAIF,UAAU;EAE/B,IAAI,eAAe,CAACG,IAAI,CAACD,IAAI,CAACE,OAAO,CAAC,cAAc,CAAC,CAAC,EAAE;IACtD,MAAMC,IAAI,CAACC,IAAI,CAACJ,IAAI,EAAEA,IAAI,EAAED,OAAO,CAAC;EACtC;EACA,OAAOC,IAAI;AACb;;AAEA;AACA;AACA;AACA,eAAeG,IAAIA,CAACE,KAAK,EAAEC,KAAK,EAAE;EAChC,IAAI,CAACC,IAAI,GAAGX,eAAe;EAC3B,MAAMY,gBAAgB,GAAG,IAAI,CAACN,OAAO,CAAC,aAAa,CAAC;EACpD,MAAMO,QAAQ,GAAG,IAAI,CAACP,OAAO,CAAC,cAAc,CAAC;EAE7C,MAAMQ,QAAQ,GAAG;IACfF,gBAAgB;IAChBC;EACF,CAAC;EACD,MAAME,WAAW,GAAG,IAAI,CAACC,WAAW,CAACF,QAAQ,CAAC;EAC9C,MAAMG,QAAQ,GAAG,IAAI,CAACC,kBAAkB,CAACH,WAAW,CAAC;EACrD,MAAMI,IAAI,GAAG,MAAM,IAAI,CAACC,QAAQ,CAAC;IAC/BL,WAAW;IACXE,QAAQ;IACRL,gBAAgB;IAChBC;EACF,CAAC,CAAC;EAEF,IAAI,CAACQ,IAAI,CAAC,WAAW,EAAET,gBAAgB,EAAEO,IAAI,CAAC;EAC9CA,IAAI,CAACG,IAAI,CAAC,CAAC;EACX,IAAI,CAACC,WAAW,CAACC,IAAI,CAACL,IAAI,CAAC;EAC3B,IAAI,CAACM,SAAS,IAAI,CAAC;EAEnB,IAAI,CAACC,OAAO,GAAG,IAAI3B,iBAAiB,CAAC,IAAI,CAACI,OAAO,CAAC;;EAElD;EACA,IAAIwB,iBAAiB,GAAG,CAAC;EAEzB,IAAI,CAACD,OAAO,CAACE,EAAE,CAAC,MAAM,EAAGC,MAAM,IAAK;IAClC,IAAI,CAACC,KAAK,CAAC,CAAC;IACZH,iBAAiB,IAAI,CAAC;IAEtBR,IAAI,CAACY,KAAK,CAACF,MAAM,EAAE,MAAM;MACvBF,iBAAiB,IAAI,CAAC;MACtB,IAAI,CAACK,MAAM,CAAC,CAAC;MAEb,IAAI,IAAI,CAACC,KAAK,EAAE;QACd,IAAI,CAACP,OAAO,CAACL,IAAI,CAAC,iBAAiB,CAAC;MACtC;IACF,CAAC,CAAC;EACJ,CAAC,CAAC;EAEF,IAAI,CAACK,OAAO,CAACE,EAAE,CAAC,KAAK,EAAE,MAAM;IAC3B,IAAI,CAACH,SAAS,IAAI,CAAC;IACnB,IAAI,CAACQ,KAAK,GAAG,IAAI;IAEjB,MAAMC,IAAI,GAAGA,CAAA,KAAM;MACjBf,IAAI,CAACgB,GAAG,CAAC,MAAM;QACb,IAAI,CAACd,IAAI,CAAC,MAAM,EAAE,MAAM,EAAEF,IAAI,CAAC;QAC/B,IAAI,CAACiB,SAAS,CAAC,CAAC;MAClB,CAAC,CAAC;IACJ,CAAC;IAED,IAAIT,iBAAiB,KAAK,CAAC,EAAE;MAC3BO,IAAI,CAAC,CAAC;IACR,CAAC,MAAM;MACL,IAAI,CAACR,OAAO,CAACW,IAAI,CAAC,iBAAiB,EAAEH,IAAI,CAAC;IAC5C;EACF,CAAC,CAAC;EAEF,OAAO,IAAI;AACb","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}