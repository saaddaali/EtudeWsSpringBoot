{"ast":null,"code":"/* eslint-disable no-underscore-dangle */\n\nimport { Stream } from 'node:stream';\nimport MultipartParser from '../parsers/Multipart.js';\nimport * as errors from '../FormidableError.js';\nimport FormidableError from '../FormidableError.js';\nexport const multipartType = 'multipart';\n// the `options` is also available through the `options` / `formidable.options`\nexport default function plugin(formidable, options) {\n  // the `this` context is always formidable, as the first argument of a plugin\n  // but this allows us to customize/test each plugin\n\n  /* istanbul ignore next */\n  const self = this || formidable;\n\n  // NOTE: we (currently) support both multipart/form-data and multipart/related\n  const multipart = /multipart/i.test(self.headers['content-type']);\n  if (multipart) {\n    const m = self.headers['content-type'].match(/boundary=(?:\"([^\"]+)\"|([^;]+))/i);\n    if (m) {\n      const initMultipart = createInitMultipart(m[1] || m[2]);\n      initMultipart.call(self, self, options); // lgtm [js/superfluous-trailing-arguments]\n    } else {\n      const err = new FormidableError('bad content-type header, no multipart boundary', errors.missingMultipartBoundary, 400);\n      self._error(err);\n    }\n  }\n  return self;\n}\n\n// Note that it's a good practice (but it's up to you) to use the `this.options` instead\n// of the passed `options` (second) param, because when you decide\n// to test the plugin you can pass custom `this` context to it (and so `this.options`)\nfunction createInitMultipart(boundary) {\n  return function initMultipart() {\n    this.type = multipartType;\n    const parser = new MultipartParser(this.options);\n    let headerField;\n    let headerValue;\n    let part;\n    parser.initWithBoundary(boundary);\n\n    // eslint-disable-next-line max-statements, consistent-return\n    parser.on('data', async ({\n      name,\n      buffer,\n      start,\n      end\n    }) => {\n      if (name === 'partBegin') {\n        part = new Stream();\n        part.readable = true;\n        part.headers = {};\n        part.name = null;\n        part.originalFilename = null;\n        part.mimetype = null;\n        part.transferEncoding = this.options.encoding;\n        part.transferBuffer = '';\n        headerField = '';\n        headerValue = '';\n      } else if (name === 'headerField') {\n        headerField += buffer.toString(this.options.encoding, start, end);\n      } else if (name === 'headerValue') {\n        headerValue += buffer.toString(this.options.encoding, start, end);\n      } else if (name === 'headerEnd') {\n        headerField = headerField.toLowerCase();\n        part.headers[headerField] = headerValue;\n\n        // matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n        const m = headerValue.match(\n        // eslint-disable-next-line no-useless-escape\n        /\\bname=(\"([^\"]*)\"|([^\\(\\)<>@,;:\\\\\"\\/\\[\\]\\?=\\{\\}\\s\\t/]+))/i);\n        if (headerField === 'content-disposition') {\n          if (m) {\n            part.name = m[2] || m[3] || '';\n          }\n          part.originalFilename = this._getFileName(headerValue);\n        } else if (headerField === 'content-type') {\n          part.mimetype = headerValue;\n        } else if (headerField === 'content-transfer-encoding') {\n          part.transferEncoding = headerValue.toLowerCase();\n        }\n        headerField = '';\n        headerValue = '';\n      } else if (name === 'headersEnd') {\n        switch (part.transferEncoding) {\n          case 'binary':\n          case '7bit':\n          case '8bit':\n          case 'utf-8':\n            {\n              const dataPropagation = ctx => {\n                if (ctx.name === 'partData') {\n                  part.emit('data', ctx.buffer.slice(ctx.start, ctx.end));\n                }\n              };\n              const dataStopPropagation = ctx => {\n                if (ctx.name === 'partEnd') {\n                  part.emit('end');\n                  parser.off('data', dataPropagation);\n                  parser.off('data', dataStopPropagation);\n                }\n              };\n              parser.on('data', dataPropagation);\n              parser.on('data', dataStopPropagation);\n              break;\n            }\n          case 'base64':\n            {\n              const dataPropagation = ctx => {\n                if (ctx.name === 'partData') {\n                  part.transferBuffer += ctx.buffer.slice(ctx.start, ctx.end).toString('ascii');\n\n                  /*\n                    four bytes (chars) in base64 converts to three bytes in binary\n                    encoding. So we should always work with a number of bytes that\n                    can be divided by 4, it will result in a number of bytes that\n                    can be divided vy 3.\n                    */\n                  const offset = parseInt(part.transferBuffer.length / 4, 10) * 4;\n                  part.emit('data', Buffer.from(part.transferBuffer.substring(0, offset), 'base64'));\n                  part.transferBuffer = part.transferBuffer.substring(offset);\n                }\n              };\n              const dataStopPropagation = ctx => {\n                if (ctx.name === 'partEnd') {\n                  part.emit('data', Buffer.from(part.transferBuffer, 'base64'));\n                  part.emit('end');\n                  parser.off('data', dataPropagation);\n                  parser.off('data', dataStopPropagation);\n                }\n              };\n              parser.on('data', dataPropagation);\n              parser.on('data', dataStopPropagation);\n              break;\n            }\n          default:\n            return this._error(new FormidableError('unknown transfer-encoding', errors.unknownTransferEncoding, 501));\n        }\n        this._parser.pause();\n        await this.onPart(part);\n        this._parser.resume();\n      } else if (name === 'end') {\n        this.ended = true;\n        this._maybeEnd();\n      }\n    });\n    this._parser = parser;\n  };\n}","map":{"version":3,"names":["Stream","MultipartParser","errors","FormidableError","multipartType","plugin","formidable","options","self","multipart","test","headers","m","match","initMultipart","createInitMultipart","call","err","missingMultipartBoundary","_error","boundary","type","parser","headerField","headerValue","part","initWithBoundary","on","name","buffer","start","end","readable","originalFilename","mimetype","transferEncoding","encoding","transferBuffer","toString","toLowerCase","_getFileName","dataPropagation","ctx","emit","slice","dataStopPropagation","off","offset","parseInt","length","Buffer","from","substring","unknownTransferEncoding","_parser","pause","onPart","resume","ended","_maybeEnd"],"sources":["/Users/soukaina/Desktop/hotel-reservation-management-soap/frontend-soapt/node_modules/formidable/src/plugins/multipart.js"],"sourcesContent":["/* eslint-disable no-underscore-dangle */\n\nimport { Stream } from 'node:stream';\nimport MultipartParser from '../parsers/Multipart.js';\nimport * as errors from '../FormidableError.js';\nimport FormidableError from '../FormidableError.js';\n\nexport const multipartType = 'multipart';\n// the `options` is also available through the `options` / `formidable.options`\nexport default function plugin(formidable, options) {\n  // the `this` context is always formidable, as the first argument of a plugin\n  // but this allows us to customize/test each plugin\n\n  /* istanbul ignore next */\n  const self = this || formidable;\n\n  // NOTE: we (currently) support both multipart/form-data and multipart/related\n  const multipart = /multipart/i.test(self.headers['content-type']);\n\n  if (multipart) {\n    const m = self.headers['content-type'].match(\n      /boundary=(?:\"([^\"]+)\"|([^;]+))/i,\n    );\n    if (m) {\n      const initMultipart = createInitMultipart(m[1] || m[2]);\n      initMultipart.call(self, self, options); // lgtm [js/superfluous-trailing-arguments]\n    } else {\n      const err = new FormidableError(\n        'bad content-type header, no multipart boundary',\n        errors.missingMultipartBoundary,\n        400,\n      );\n      self._error(err);\n    }\n  }\n  return self;\n}\n\n// Note that it's a good practice (but it's up to you) to use the `this.options` instead\n// of the passed `options` (second) param, because when you decide\n// to test the plugin you can pass custom `this` context to it (and so `this.options`)\nfunction createInitMultipart(boundary) {\n  return function initMultipart() {\n    this.type = multipartType;\n\n    const parser = new MultipartParser(this.options);\n    let headerField;\n    let headerValue;\n    let part;\n\n    parser.initWithBoundary(boundary);\n\n    // eslint-disable-next-line max-statements, consistent-return\n    parser.on('data', async ({ name, buffer, start, end }) => {\n      if (name === 'partBegin') {\n        part = new Stream();\n        part.readable = true;\n        part.headers = {};\n        part.name = null;\n        part.originalFilename = null;\n        part.mimetype = null;\n\n        part.transferEncoding = this.options.encoding;\n        part.transferBuffer = '';\n\n        headerField = '';\n        headerValue = '';\n      } else if (name === 'headerField') {\n        headerField += buffer.toString(this.options.encoding, start, end);\n      } else if (name === 'headerValue') {\n        headerValue += buffer.toString(this.options.encoding, start, end);\n      } else if (name === 'headerEnd') {\n        headerField = headerField.toLowerCase();\n        part.headers[headerField] = headerValue;\n\n        // matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n        const m = headerValue.match(\n          // eslint-disable-next-line no-useless-escape\n          /\\bname=(\"([^\"]*)\"|([^\\(\\)<>@,;:\\\\\"\\/\\[\\]\\?=\\{\\}\\s\\t/]+))/i,\n        );\n        if (headerField === 'content-disposition') {\n          if (m) {\n            part.name = m[2] || m[3] || '';\n          }\n\n          part.originalFilename = this._getFileName(headerValue);\n        } else if (headerField === 'content-type') {\n          part.mimetype = headerValue;\n        } else if (headerField === 'content-transfer-encoding') {\n          part.transferEncoding = headerValue.toLowerCase();\n        }\n\n        headerField = '';\n        headerValue = '';\n      } else if (name === 'headersEnd') {\n        switch (part.transferEncoding) {\n          case 'binary':\n          case '7bit':\n          case '8bit':\n          case 'utf-8': {\n            const dataPropagation = (ctx) => {\n              if (ctx.name === 'partData') {\n                part.emit('data', ctx.buffer.slice(ctx.start, ctx.end));\n              }\n            };\n            const dataStopPropagation = (ctx) => {\n              if (ctx.name === 'partEnd') {\n                part.emit('end');\n                parser.off('data', dataPropagation);\n                parser.off('data', dataStopPropagation);\n              }\n            };\n            parser.on('data', dataPropagation);\n            parser.on('data', dataStopPropagation);\n            break;\n          }\n          case 'base64': {\n            const dataPropagation = (ctx) => {\n              if (ctx.name === 'partData') {\n                part.transferBuffer += ctx.buffer\n                  .slice(ctx.start, ctx.end)\n                  .toString('ascii');\n\n                /*\n                  four bytes (chars) in base64 converts to three bytes in binary\n                  encoding. So we should always work with a number of bytes that\n                  can be divided by 4, it will result in a number of bytes that\n                  can be divided vy 3.\n                  */\n                const offset = parseInt(part.transferBuffer.length / 4, 10) * 4;\n                part.emit(\n                  'data',\n                  Buffer.from(\n                    part.transferBuffer.substring(0, offset),\n                    'base64',\n                  ),\n                );\n                part.transferBuffer = part.transferBuffer.substring(offset);\n              }\n            };\n            const dataStopPropagation = (ctx) => {\n              if (ctx.name === 'partEnd') {\n                part.emit('data', Buffer.from(part.transferBuffer, 'base64'));\n                part.emit('end');\n                parser.off('data', dataPropagation);\n                parser.off('data', dataStopPropagation);\n              }\n            };\n            parser.on('data', dataPropagation);\n            parser.on('data', dataStopPropagation);\n            break;\n          }\n          default:\n            return this._error(\n              new FormidableError(\n                'unknown transfer-encoding',\n                errors.unknownTransferEncoding,\n                501,\n              ),\n            );\n        }\n        this._parser.pause();\n        await this.onPart(part);\n        this._parser.resume();\n      } else if (name === 'end') {\n        this.ended = true;\n        this._maybeEnd();\n      }\n    });\n\n    this._parser = parser;\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}