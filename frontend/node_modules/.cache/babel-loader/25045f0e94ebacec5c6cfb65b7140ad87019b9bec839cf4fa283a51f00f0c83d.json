{"ast":null,"code":"import axios from \"axios\";\nconst API_URL = \"http://localhost:8080/services/ws\";\nconst createSoapEnvelope = (method, params) => `\n  <soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" \n                    xmlns:hot=\"http://controller.hotelgestion.example.com/\">\n    <soapenv:Header/>\n    <soapenv:Body>\n      <hot:${method}>${params}</hot:${method}>\n    </soapenv:Body>\n  </soapenv:Envelope>\n`;\nexport const reservationService = {\n  async getReservations() {\n    try {\n      const response = await axios.post(API_URL, createSoapEnvelope(\"getAllReservations\", \"\"), {\n        headers: {\n          \"Content-Type\": \"text/xml\"\n        }\n      });\n      const parser = new DOMParser();\n      const xmlDoc = parser.parseFromString(response.data, \"text/xml\");\n      return this.transformReservations(xmlDoc);\n    } catch (error) {\n      console.error(\"Erreur lors de la récupération des réservations:\", error);\n      throw new Error(\"Erreur SOAP lors du chargement\");\n    }\n  },\n  async getReservationById(id) {\n    try {\n      const params = `<id>${id}</id>`;\n      const response = await axios.post(API_URL, createSoapEnvelope(\"getReservationById\", params), {\n        headers: {\n          \"Content-Type\": \"text/xml\"\n        }\n      });\n      const parser = new DOMParser();\n      const xmlDoc = parser.parseFromString(response.data, \"text/xml\");\n      return this.transformReservation(xmlDoc.querySelector(\"return\"));\n    } catch (error) {\n      console.error(\"Erreur lors de la récupération de la réservation:\", error);\n      throw new Error(\"Erreur SOAP lors de la récupération\");\n    }\n  },\n  async createReservation(formData) {\n    try {\n      const [firstName, ...lastNameParts] = formData.clientName.split(\" \");\n      const params = `\n        <dateDebut>${formData.startDate}</dateDebut>\n        <dateFin>${formData.endDate}</dateFin>\n        <client>\n          <nom>${lastNameParts.join(\" \")}</nom>\n          <prenom>${firstName}</prenom>\n          <email>${formData.email}</email>\n          <telephone>${formData.phone}</telephone>\n        </client>\n        <chambre>\n          <type>${formData.roomType}</type>\n          <disponible>true</disponible>\n        </chambre>\n      `;\n      const response = await axios.post(API_URL, createSoapEnvelope(\"createReservation\", params), {\n        headers: {\n          \"Content-Type\": \"text/xml\"\n        }\n      });\n      const parser = new DOMParser();\n      const xmlDoc = parser.parseFromString(response.data, \"text/xml\");\n\n      // Vérifier les erreurs SOAP\n      const faultElement = xmlDoc.querySelector(\"soap\\\\:Fault, Fault\");\n      if (faultElement) {\n        throw new Error(\"Erreur SOAP lors de la création\");\n      }\n      return this.transformReservation(xmlDoc);\n    } catch (error) {\n      console.error(\"Erreur lors de la création de la réservation:\", error);\n      throw error;\n    }\n  },\n  async updateReservation(id, formData) {\n    try {\n      // Imprimer les données reçues pour débogage\n      console.log(\"Données reçues pour mise à jour:\", {\n        id,\n        formData\n      });\n      const [firstName, ...lastNameParts] = formData.clientName.split(\" \");\n      const params = `\n        <arg0>\n          <id>${id}</id>\n          <dateDebut>${formData.startDate}</dateDebut>\n          <dateFin>${formData.endDate}</dateFin>\n          <client>\n            <nom>${lastNameParts.join(\" \")}</nom>\n            <prenom>${firstName}</prenom>\n            <email>${formData.email}</email>\n            <telephone>${formData.phone}</telephone>\n          </client>\n          <chambre>\n            <type>${formData.roomType}</type>\n            <disponible>true</disponible>\n          </chambre>\n        </arg0>\n      `;\n\n      // Imprimer la requête SOAP pour débogage\n      console.log(\"Requête SOAP:\", createSoapEnvelope(\"updateReservation\", params));\n      const response = await axios.post(API_URL, createSoapEnvelope(\"updateReservation\", params), {\n        headers: {\n          \"Content-Type\": \"text/xml\",\n          SOAPAction: \"\"\n        }\n      });\n\n      // Imprimer la réponse pour débogage\n      console.log(\"Réponse SOAP brute:\", response.data);\n      const parser = new DOMParser();\n      const xmlDoc = parser.parseFromString(response.data, \"text/xml\");\n      const faultElement = xmlDoc.querySelector(\"soap\\\\:Fault, Fault\");\n      if (faultElement) {\n        var _faultElement$querySe;\n        const faultString = (_faultElement$querySe = faultElement.querySelector(\"faultstring\")) === null || _faultElement$querySe === void 0 ? void 0 : _faultElement$querySe.textContent;\n        throw new Error(faultString || \"Erreur SOAP lors de la mise à jour\");\n      }\n      const result = xmlDoc.querySelector(\"return\");\n      if (!result || result.textContent !== \"true\") {\n        throw new Error(\"Erreur SOAP lors de la mise à jour\");\n      }\n      return true;\n    } catch (error) {\n      // Amélioration du logging des erreurs\n      if (error.response) {\n        console.error(\"Détails de l'erreur SOAP:\", {\n          data: error.response.data,\n          status: error.response.status,\n          headers: error.response.headers\n        });\n      }\n      throw error;\n    }\n  },\n  async deleteReservation(id) {\n    try {\n      const params = `<id>${id}</id>`;\n      const response = await axios.post(API_URL, createSoapEnvelope(\"deleteReservation\", params), {\n        headers: {\n          \"Content-Type\": \"text/xml\"\n        }\n      });\n      const parser = new DOMParser();\n      const xmlDoc = parser.parseFromString(response.data, \"text/xml\");\n      const result = xmlDoc.querySelector(\"return\");\n      if (!result || result.textContent !== \"true\") {\n        throw new Error(\"Erreur SOAP lors de la suppression\");\n      }\n      return true;\n    } catch (error) {\n      console.error(\"Erreur lors de la suppression de la réservation:\", error);\n      throw error;\n    }\n  },\n  transformReservation(node) {\n    if (!node) return null;\n    const getNodeValue = (node, path) => {\n      const element = node.querySelector(path);\n      return element ? element.textContent : \"\";\n    };\n    return {\n      id: getNodeValue(node, \"id\"),\n      clientName: `${getNodeValue(node, \"prenom\")} ${getNodeValue(node, \"nom\")}`.trim(),\n      email: getNodeValue(node, \"email\"),\n      phone: getNodeValue(node, \"telephone\"),\n      roomType: getNodeValue(node, \"type\"),\n      startDate: getNodeValue(node, \"dateDebut\"),\n      endDate: getNodeValue(node, \"dateFin\"),\n      preferences: getNodeValue(node, \"preferences\") || \"\"\n    };\n  },\n  transformReservations(xmlDoc) {\n    const reservations = xmlDoc.querySelectorAll(\"return\");\n    return Array.from(reservations).map(res => this.transformReservation(res));\n  }\n};","map":{"version":3,"names":["axios","API_URL","createSoapEnvelope","method","params","reservationService","getReservations","response","post","headers","parser","DOMParser","xmlDoc","parseFromString","data","transformReservations","error","console","Error","getReservationById","id","transformReservation","querySelector","createReservation","formData","firstName","lastNameParts","clientName","split","startDate","endDate","join","email","phone","roomType","faultElement","updateReservation","log","SOAPAction","_faultElement$querySe","faultString","textContent","result","status","deleteReservation","node","getNodeValue","path","element","trim","preferences","reservations","querySelectorAll","Array","from","map","res"],"sources":["/Users/soukaina/Desktop/hotel-reservation-management-soap/frontend-soapt/src/services/reservationService.js"],"sourcesContent":["import axios from \"axios\";\n\nconst API_URL = \"http://localhost:8080/services/ws\";\n\nconst createSoapEnvelope = (method, params) => `\n  <soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" \n                    xmlns:hot=\"http://controller.hotelgestion.example.com/\">\n    <soapenv:Header/>\n    <soapenv:Body>\n      <hot:${method}>${params}</hot:${method}>\n    </soapenv:Body>\n  </soapenv:Envelope>\n`;\n\nexport const reservationService = {\n  async getReservations() {\n    try {\n      const response = await axios.post(\n        API_URL,\n        createSoapEnvelope(\"getAllReservations\", \"\"),\n        { headers: { \"Content-Type\": \"text/xml\" } }\n      );\n      const parser = new DOMParser();\n      const xmlDoc = parser.parseFromString(response.data, \"text/xml\");\n      return this.transformReservations(xmlDoc);\n    } catch (error) {\n      console.error(\"Erreur lors de la récupération des réservations:\", error);\n      throw new Error(\"Erreur SOAP lors du chargement\");\n    }\n  },\n\n  async getReservationById(id) {\n    try {\n      const params = `<id>${id}</id>`;\n      const response = await axios.post(\n        API_URL,\n        createSoapEnvelope(\"getReservationById\", params),\n        { headers: { \"Content-Type\": \"text/xml\" } }\n      );\n      const parser = new DOMParser();\n      const xmlDoc = parser.parseFromString(response.data, \"text/xml\");\n      return this.transformReservation(xmlDoc.querySelector(\"return\"));\n    } catch (error) {\n      console.error(\"Erreur lors de la récupération de la réservation:\", error);\n      throw new Error(\"Erreur SOAP lors de la récupération\");\n    }\n  },\n\n  async createReservation(formData) {\n    try {\n      const [firstName, ...lastNameParts] = formData.clientName.split(\" \");\n      const params = `\n        <dateDebut>${formData.startDate}</dateDebut>\n        <dateFin>${formData.endDate}</dateFin>\n        <client>\n          <nom>${lastNameParts.join(\" \")}</nom>\n          <prenom>${firstName}</prenom>\n          <email>${formData.email}</email>\n          <telephone>${formData.phone}</telephone>\n        </client>\n        <chambre>\n          <type>${formData.roomType}</type>\n          <disponible>true</disponible>\n        </chambre>\n      `;\n\n      const response = await axios.post(\n        API_URL,\n        createSoapEnvelope(\"createReservation\", params),\n        { headers: { \"Content-Type\": \"text/xml\" } }\n      );\n\n      const parser = new DOMParser();\n      const xmlDoc = parser.parseFromString(response.data, \"text/xml\");\n\n      // Vérifier les erreurs SOAP\n      const faultElement = xmlDoc.querySelector(\"soap\\\\:Fault, Fault\");\n      if (faultElement) {\n        throw new Error(\"Erreur SOAP lors de la création\");\n      }\n\n      return this.transformReservation(xmlDoc);\n    } catch (error) {\n      console.error(\"Erreur lors de la création de la réservation:\", error);\n      throw error;\n    }\n  },\n\n  async updateReservation(id, formData) {\n    try {\n      // Imprimer les données reçues pour débogage\n      console.log(\"Données reçues pour mise à jour:\", { id, formData });\n\n      const [firstName, ...lastNameParts] = formData.clientName.split(\" \");\n      const params = `\n        <arg0>\n          <id>${id}</id>\n          <dateDebut>${formData.startDate}</dateDebut>\n          <dateFin>${formData.endDate}</dateFin>\n          <client>\n            <nom>${lastNameParts.join(\" \")}</nom>\n            <prenom>${firstName}</prenom>\n            <email>${formData.email}</email>\n            <telephone>${formData.phone}</telephone>\n          </client>\n          <chambre>\n            <type>${formData.roomType}</type>\n            <disponible>true</disponible>\n          </chambre>\n        </arg0>\n      `;\n\n      // Imprimer la requête SOAP pour débogage\n      console.log(\n        \"Requête SOAP:\",\n        createSoapEnvelope(\"updateReservation\", params)\n      );\n\n      const response = await axios.post(\n        API_URL,\n        createSoapEnvelope(\"updateReservation\", params),\n        {\n          headers: {\n            \"Content-Type\": \"text/xml\",\n            SOAPAction: \"\",\n          },\n        }\n      );\n\n      // Imprimer la réponse pour débogage\n      console.log(\"Réponse SOAP brute:\", response.data);\n\n      const parser = new DOMParser();\n      const xmlDoc = parser.parseFromString(response.data, \"text/xml\");\n\n      const faultElement = xmlDoc.querySelector(\"soap\\\\:Fault, Fault\");\n      if (faultElement) {\n        const faultString =\n          faultElement.querySelector(\"faultstring\")?.textContent;\n        throw new Error(faultString || \"Erreur SOAP lors de la mise à jour\");\n      }\n\n      const result = xmlDoc.querySelector(\"return\");\n      if (!result || result.textContent !== \"true\") {\n        throw new Error(\"Erreur SOAP lors de la mise à jour\");\n      }\n\n      return true;\n    } catch (error) {\n      // Amélioration du logging des erreurs\n      if (error.response) {\n        console.error(\"Détails de l'erreur SOAP:\", {\n          data: error.response.data,\n          status: error.response.status,\n          headers: error.response.headers,\n        });\n      }\n      throw error;\n    }\n  },\n  async deleteReservation(id) {\n    try {\n      const params = `<id>${id}</id>`;\n      const response = await axios.post(\n        API_URL,\n        createSoapEnvelope(\"deleteReservation\", params),\n        { headers: { \"Content-Type\": \"text/xml\" } }\n      );\n\n      const parser = new DOMParser();\n      const xmlDoc = parser.parseFromString(response.data, \"text/xml\");\n\n      const result = xmlDoc.querySelector(\"return\");\n      if (!result || result.textContent !== \"true\") {\n        throw new Error(\"Erreur SOAP lors de la suppression\");\n      }\n\n      return true;\n    } catch (error) {\n      console.error(\"Erreur lors de la suppression de la réservation:\", error);\n      throw error;\n    }\n  },\n\n  transformReservation(node) {\n    if (!node) return null;\n\n    const getNodeValue = (node, path) => {\n      const element = node.querySelector(path);\n      return element ? element.textContent : \"\";\n    };\n\n    return {\n      id: getNodeValue(node, \"id\"),\n      clientName: `${getNodeValue(node, \"prenom\")} ${getNodeValue(\n        node,\n        \"nom\"\n      )}`.trim(),\n      email: getNodeValue(node, \"email\"),\n      phone: getNodeValue(node, \"telephone\"),\n      roomType: getNodeValue(node, \"type\"),\n      startDate: getNodeValue(node, \"dateDebut\"),\n      endDate: getNodeValue(node, \"dateFin\"),\n      preferences: getNodeValue(node, \"preferences\") || \"\",\n    };\n  },\n\n  transformReservations(xmlDoc) {\n    const reservations = xmlDoc.querySelectorAll(\"return\");\n    return Array.from(reservations).map((res) =>\n      this.transformReservation(res)\n    );\n  },\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}