{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ExclusiveCanonicalizationWithComments = exports.ExclusiveCanonicalization = void 0;\nconst utils = require(\"./utils\");\nconst isDomNode = require(\"@xmldom/is-dom-node\");\nfunction isPrefixInScope(prefixesInScope, prefix, namespaceURI) {\n  let ret = false;\n  prefixesInScope.forEach(function (pf) {\n    if (pf.prefix === prefix && pf.namespaceURI === namespaceURI) {\n      ret = true;\n    }\n  });\n  return ret;\n}\nclass ExclusiveCanonicalization {\n  constructor() {\n    this.includeComments = false;\n    this.includeComments = false;\n  }\n  attrCompare(a, b) {\n    if (!a.namespaceURI && b.namespaceURI) {\n      return -1;\n    }\n    if (!b.namespaceURI && a.namespaceURI) {\n      return 1;\n    }\n    const left = a.namespaceURI + a.localName;\n    const right = b.namespaceURI + b.localName;\n    if (left === right) {\n      return 0;\n    } else if (left < right) {\n      return -1;\n    } else {\n      return 1;\n    }\n  }\n  nsCompare(a, b) {\n    const attr1 = a.prefix;\n    const attr2 = b.prefix;\n    if (attr1 === attr2) {\n      return 0;\n    }\n    return attr1.localeCompare(attr2);\n  }\n  renderAttrs(node) {\n    let i;\n    let attr;\n    const res = [];\n    const attrListToRender = [];\n    if (isDomNode.isCommentNode(node)) {\n      return this.renderComment(node);\n    }\n    if (node.attributes) {\n      for (i = 0; i < node.attributes.length; ++i) {\n        attr = node.attributes[i];\n        //ignore namespace definition attributes\n        if (attr.name.indexOf(\"xmlns\") === 0) {\n          continue;\n        }\n        attrListToRender.push(attr);\n      }\n    }\n    attrListToRender.sort(this.attrCompare);\n    for (attr of attrListToRender) {\n      res.push(\" \", attr.name, '=\"', utils.encodeSpecialCharactersInAttribute(attr.value), '\"');\n    }\n    return res.join(\"\");\n  }\n  /**\n   * Create the string of all namespace declarations that should appear on this element\n   *\n   * @param {Node} node. The node we now render\n   * @param {Array} prefixesInScope. The prefixes defined on this node\n   *                parents which are a part of the output set\n   * @param {String} defaultNs. The current default namespace\n   * @return {String}\n   * @api private\n   */\n  renderNs(node, prefixesInScope, defaultNs, defaultNsForPrefix, inclusiveNamespacesPrefixList) {\n    let i;\n    let attr;\n    const res = [];\n    let newDefaultNs = defaultNs;\n    const nsListToRender = [];\n    const currNs = node.namespaceURI || \"\";\n    //handle the namespaceof the node itself\n    if (node.prefix) {\n      if (!isPrefixInScope(prefixesInScope, node.prefix, node.namespaceURI || defaultNsForPrefix[node.prefix])) {\n        nsListToRender.push({\n          prefix: node.prefix,\n          namespaceURI: node.namespaceURI || defaultNsForPrefix[node.prefix]\n        });\n        prefixesInScope.push({\n          prefix: node.prefix,\n          namespaceURI: node.namespaceURI || defaultNsForPrefix[node.prefix]\n        });\n      }\n    } else if (defaultNs !== currNs) {\n      //new default ns\n      newDefaultNs = node.namespaceURI;\n      res.push(' xmlns=\"', newDefaultNs, '\"');\n    }\n    //handle the attributes namespace\n    if (node.attributes) {\n      for (i = 0; i < node.attributes.length; ++i) {\n        attr = node.attributes[i];\n        //handle all prefixed attributes that are included in the prefix list and where\n        //the prefix is not defined already\n        if (attr.prefix && !isPrefixInScope(prefixesInScope, attr.localName, attr.value) && inclusiveNamespacesPrefixList.indexOf(attr.localName) >= 0) {\n          nsListToRender.push({\n            prefix: attr.localName,\n            namespaceURI: attr.value\n          });\n          prefixesInScope.push({\n            prefix: attr.localName,\n            namespaceURI: attr.value\n          });\n        }\n        //handle all prefixed attributes that are not xmlns definitions and where\n        //the prefix is not defined already\n        if (attr.prefix && !isPrefixInScope(prefixesInScope, attr.prefix, attr.namespaceURI) && attr.prefix !== \"xmlns\" && attr.prefix !== \"xml\") {\n          nsListToRender.push({\n            prefix: attr.prefix,\n            namespaceURI: attr.namespaceURI\n          });\n          prefixesInScope.push({\n            prefix: attr.prefix,\n            namespaceURI: attr.namespaceURI\n          });\n        }\n      }\n    }\n    nsListToRender.sort(this.nsCompare);\n    //render namespaces\n    for (const p of nsListToRender) {\n      res.push(\" xmlns:\", p.prefix, '=\"', p.namespaceURI, '\"');\n    }\n    return {\n      rendered: res.join(\"\"),\n      newDefaultNs: newDefaultNs\n    };\n  }\n  /**\n   * @param node Node\n   */\n  processInner(node, prefixesInScope, defaultNs, defaultNsForPrefix, inclusiveNamespacesPrefixList) {\n    if (isDomNode.isCommentNode(node)) {\n      return this.renderComment(node);\n    }\n    if (node.data) {\n      return utils.encodeSpecialCharactersInText(node.data);\n    }\n    if (isDomNode.isElementNode(node)) {\n      let i;\n      let pfxCopy;\n      const ns = this.renderNs(node, prefixesInScope, defaultNs, defaultNsForPrefix, inclusiveNamespacesPrefixList);\n      const res = [\"<\", node.tagName, ns.rendered, this.renderAttrs(node), \">\"];\n      for (i = 0; i < node.childNodes.length; ++i) {\n        pfxCopy = prefixesInScope.slice(0);\n        res.push(this.processInner(node.childNodes[i], pfxCopy, ns.newDefaultNs, defaultNsForPrefix, inclusiveNamespacesPrefixList));\n      }\n      res.push(\"</\", node.tagName, \">\");\n      return res.join(\"\");\n    }\n    throw new Error(`Unable to exclusive canonicalize node type: ${node.nodeType}`);\n  }\n  // Thanks to deoxxa/xml-c14n for comment renderer\n  renderComment(node) {\n    if (!this.includeComments) {\n      return \"\";\n    }\n    const isOutsideDocument = node.ownerDocument === node.parentNode;\n    let isBeforeDocument = false;\n    let isAfterDocument = false;\n    if (isOutsideDocument) {\n      let nextNode = node;\n      let previousNode = node;\n      while (nextNode != null) {\n        if (nextNode === node.ownerDocument.documentElement) {\n          isBeforeDocument = true;\n          break;\n        }\n        nextNode = nextNode.nextSibling;\n      }\n      while (previousNode != null) {\n        if (previousNode === node.ownerDocument.documentElement) {\n          isAfterDocument = true;\n          break;\n        }\n        previousNode = previousNode.previousSibling;\n      }\n    }\n    const afterDocument = isAfterDocument ? \"\\n\" : \"\";\n    const beforeDocument = isBeforeDocument ? \"\\n\" : \"\";\n    const encodedText = utils.encodeSpecialCharactersInText(node.data);\n    return `${afterDocument}<!--${encodedText}-->${beforeDocument}`;\n  }\n  /**\n   * Perform canonicalization of the given element node\n   *\n   * @api public\n   */\n  process(elem, options) {\n    options = options || {};\n    let inclusiveNamespacesPrefixList = options.inclusiveNamespacesPrefixList || [];\n    const defaultNs = options.defaultNs || \"\";\n    const defaultNsForPrefix = options.defaultNsForPrefix || {};\n    const ancestorNamespaces = options.ancestorNamespaces || [];\n    /**\n     * If the inclusiveNamespacesPrefixList has not been explicitly provided then look it up in CanonicalizationMethod/InclusiveNamespaces\n     */\n    if (!utils.isArrayHasLength(inclusiveNamespacesPrefixList)) {\n      const CanonicalizationMethod = utils.findChildren(elem, \"CanonicalizationMethod\");\n      if (CanonicalizationMethod.length !== 0) {\n        const inclusiveNamespaces = utils.findChildren(CanonicalizationMethod[0], \"InclusiveNamespaces\");\n        if (inclusiveNamespaces.length !== 0) {\n          inclusiveNamespacesPrefixList = (inclusiveNamespaces[0].getAttribute(\"PrefixList\") || \"\").split(\" \");\n        }\n      }\n    }\n    /**\n     * If you have a PrefixList then use it and the ancestors to add the necessary namespaces\n     */\n    if (utils.isArrayHasLength(inclusiveNamespacesPrefixList)) {\n      inclusiveNamespacesPrefixList.forEach(function (prefix) {\n        if (ancestorNamespaces) {\n          ancestorNamespaces.forEach(function (ancestorNamespace) {\n            if (prefix === ancestorNamespace.prefix) {\n              elem.setAttributeNS(\"http://www.w3.org/2000/xmlns/\", `xmlns:${prefix}`, ancestorNamespace.namespaceURI);\n            }\n          });\n        }\n      });\n    }\n    const res = this.processInner(elem, [], defaultNs, defaultNsForPrefix, inclusiveNamespacesPrefixList);\n    return res;\n  }\n  getAlgorithmName() {\n    return \"http://www.w3.org/2001/10/xml-exc-c14n#\";\n  }\n}\nexports.ExclusiveCanonicalization = ExclusiveCanonicalization;\nclass ExclusiveCanonicalizationWithComments extends ExclusiveCanonicalization {\n  constructor() {\n    super();\n    this.includeComments = true;\n  }\n  getAlgorithmName() {\n    return \"http://www.w3.org/2001/10/xml-exc-c14n#WithComments\";\n  }\n}\nexports.ExclusiveCanonicalizationWithComments = ExclusiveCanonicalizationWithComments;","map":{"version":3,"names":["utils","require","isDomNode","isPrefixInScope","prefixesInScope","prefix","namespaceURI","ret","forEach","pf","ExclusiveCanonicalization","constructor","includeComments","attrCompare","a","b","left","localName","right","nsCompare","attr1","attr2","localeCompare","renderAttrs","node","i","attr","res","attrListToRender","isCommentNode","renderComment","attributes","length","name","indexOf","push","sort","encodeSpecialCharactersInAttribute","value","join","renderNs","defaultNs","defaultNsForPrefix","inclusiveNamespacesPrefixList","newDefaultNs","nsListToRender","currNs","p","rendered","processInner","data","encodeSpecialCharactersInText","isElementNode","pfxCopy","ns","tagName","childNodes","slice","Error","nodeType","isOutsideDocument","ownerDocument","parentNode","isBeforeDocument","isAfterDocument","nextNode","previousNode","documentElement","nextSibling","previousSibling","afterDocument","beforeDocument","encodedText","process","elem","options","ancestorNamespaces","isArrayHasLength","CanonicalizationMethod","findChildren","inclusiveNamespaces","getAttribute","split","ancestorNamespace","setAttributeNS","getAlgorithmName","exports","ExclusiveCanonicalizationWithComments"],"sources":["/Users/soukaina/Desktop/hotel-reservation-management-soap/frontend-soapt/node_modules/xml-crypto/src/exclusive-canonicalization.ts"],"sourcesContent":["import type {\n  CanonicalizationOrTransformationAlgorithm,\n  CanonicalizationOrTransformationAlgorithmProcessOptions,\n  NamespacePrefix,\n} from \"./types\";\nimport * as utils from \"./utils\";\nimport * as isDomNode from \"@xmldom/is-dom-node\";\n\nfunction isPrefixInScope(prefixesInScope, prefix, namespaceURI) {\n  let ret = false;\n  prefixesInScope.forEach(function (pf) {\n    if (pf.prefix === prefix && pf.namespaceURI === namespaceURI) {\n      ret = true;\n    }\n  });\n\n  return ret;\n}\n\nexport class ExclusiveCanonicalization implements CanonicalizationOrTransformationAlgorithm {\n  protected includeComments = false;\n\n  constructor() {\n    this.includeComments = false;\n  }\n\n  attrCompare(a, b) {\n    if (!a.namespaceURI && b.namespaceURI) {\n      return -1;\n    }\n    if (!b.namespaceURI && a.namespaceURI) {\n      return 1;\n    }\n\n    const left = a.namespaceURI + a.localName;\n    const right = b.namespaceURI + b.localName;\n\n    if (left === right) {\n      return 0;\n    } else if (left < right) {\n      return -1;\n    } else {\n      return 1;\n    }\n  }\n\n  nsCompare(a, b) {\n    const attr1 = a.prefix;\n    const attr2 = b.prefix;\n    if (attr1 === attr2) {\n      return 0;\n    }\n    return attr1.localeCompare(attr2);\n  }\n\n  renderAttrs(node) {\n    let i;\n    let attr;\n    const res: string[] = [];\n    const attrListToRender: Attr[] = [];\n\n    if (isDomNode.isCommentNode(node)) {\n      return this.renderComment(node);\n    }\n\n    if (node.attributes) {\n      for (i = 0; i < node.attributes.length; ++i) {\n        attr = node.attributes[i];\n        //ignore namespace definition attributes\n        if (attr.name.indexOf(\"xmlns\") === 0) {\n          continue;\n        }\n        attrListToRender.push(attr);\n      }\n    }\n\n    attrListToRender.sort(this.attrCompare);\n\n    for (attr of attrListToRender) {\n      res.push(\" \", attr.name, '=\"', utils.encodeSpecialCharactersInAttribute(attr.value), '\"');\n    }\n\n    return res.join(\"\");\n  }\n\n  /**\n   * Create the string of all namespace declarations that should appear on this element\n   *\n   * @param {Node} node. The node we now render\n   * @param {Array} prefixesInScope. The prefixes defined on this node\n   *                parents which are a part of the output set\n   * @param {String} defaultNs. The current default namespace\n   * @return {String}\n   * @api private\n   */\n  renderNs(\n    node,\n    prefixesInScope,\n    defaultNs,\n    defaultNsForPrefix,\n    inclusiveNamespacesPrefixList: string[],\n  ) {\n    let i;\n    let attr;\n    const res: string[] = [];\n    let newDefaultNs = defaultNs;\n    const nsListToRender: NamespacePrefix[] = [];\n    const currNs = node.namespaceURI || \"\";\n\n    //handle the namespaceof the node itself\n    if (node.prefix) {\n      if (\n        !isPrefixInScope(\n          prefixesInScope,\n          node.prefix,\n          node.namespaceURI || defaultNsForPrefix[node.prefix],\n        )\n      ) {\n        nsListToRender.push({\n          prefix: node.prefix,\n          namespaceURI: node.namespaceURI || defaultNsForPrefix[node.prefix],\n        });\n        prefixesInScope.push({\n          prefix: node.prefix,\n          namespaceURI: node.namespaceURI || defaultNsForPrefix[node.prefix],\n        });\n      }\n    } else if (defaultNs !== currNs) {\n      //new default ns\n      newDefaultNs = node.namespaceURI;\n      res.push(' xmlns=\"', newDefaultNs, '\"');\n    }\n\n    //handle the attributes namespace\n    if (node.attributes) {\n      for (i = 0; i < node.attributes.length; ++i) {\n        attr = node.attributes[i];\n\n        //handle all prefixed attributes that are included in the prefix list and where\n        //the prefix is not defined already\n        if (\n          attr.prefix &&\n          !isPrefixInScope(prefixesInScope, attr.localName, attr.value) &&\n          inclusiveNamespacesPrefixList.indexOf(attr.localName) >= 0\n        ) {\n          nsListToRender.push({ prefix: attr.localName, namespaceURI: attr.value });\n          prefixesInScope.push({ prefix: attr.localName, namespaceURI: attr.value });\n        }\n\n        //handle all prefixed attributes that are not xmlns definitions and where\n        //the prefix is not defined already\n        if (\n          attr.prefix &&\n          !isPrefixInScope(prefixesInScope, attr.prefix, attr.namespaceURI) &&\n          attr.prefix !== \"xmlns\" &&\n          attr.prefix !== \"xml\"\n        ) {\n          nsListToRender.push({ prefix: attr.prefix, namespaceURI: attr.namespaceURI });\n          prefixesInScope.push({ prefix: attr.prefix, namespaceURI: attr.namespaceURI });\n        }\n      }\n    }\n\n    nsListToRender.sort(this.nsCompare);\n\n    //render namespaces\n    for (const p of nsListToRender) {\n      res.push(\" xmlns:\", p.prefix, '=\"', p.namespaceURI, '\"');\n    }\n\n    return { rendered: res.join(\"\"), newDefaultNs: newDefaultNs };\n  }\n\n  /**\n   * @param node Node\n   */\n  processInner(\n    node,\n    prefixesInScope,\n    defaultNs,\n    defaultNsForPrefix,\n    inclusiveNamespacesPrefixList: string[],\n  ) {\n    if (isDomNode.isCommentNode(node)) {\n      return this.renderComment(node);\n    }\n    if (node.data) {\n      return utils.encodeSpecialCharactersInText(node.data);\n    }\n\n    if (isDomNode.isElementNode(node)) {\n      let i;\n      let pfxCopy;\n      const ns = this.renderNs(\n        node,\n        prefixesInScope,\n        defaultNs,\n        defaultNsForPrefix,\n        inclusiveNamespacesPrefixList,\n      );\n      const res = [\"<\", node.tagName, ns.rendered, this.renderAttrs(node), \">\"];\n\n      for (i = 0; i < node.childNodes.length; ++i) {\n        pfxCopy = prefixesInScope.slice(0);\n        res.push(\n          this.processInner(\n            node.childNodes[i],\n            pfxCopy,\n            ns.newDefaultNs,\n            defaultNsForPrefix,\n            inclusiveNamespacesPrefixList,\n          ),\n        );\n      }\n\n      res.push(\"</\", node.tagName, \">\");\n      return res.join(\"\");\n    }\n\n    throw new Error(`Unable to exclusive canonicalize node type: ${node.nodeType}`);\n  }\n\n  // Thanks to deoxxa/xml-c14n for comment renderer\n  renderComment(node: Comment) {\n    if (!this.includeComments) {\n      return \"\";\n    }\n\n    const isOutsideDocument = node.ownerDocument === node.parentNode;\n    let isBeforeDocument = false;\n    let isAfterDocument = false;\n\n    if (isOutsideDocument) {\n      let nextNode: ChildNode | null = node;\n      let previousNode: ChildNode | null = node;\n\n      while (nextNode != null) {\n        if (nextNode === node.ownerDocument.documentElement) {\n          isBeforeDocument = true;\n          break;\n        }\n\n        nextNode = nextNode.nextSibling;\n      }\n\n      while (previousNode != null) {\n        if (previousNode === node.ownerDocument.documentElement) {\n          isAfterDocument = true;\n          break;\n        }\n\n        previousNode = previousNode.previousSibling;\n      }\n    }\n\n    const afterDocument = isAfterDocument ? \"\\n\" : \"\";\n    const beforeDocument = isBeforeDocument ? \"\\n\" : \"\";\n    const encodedText = utils.encodeSpecialCharactersInText(node.data);\n\n    return `${afterDocument}<!--${encodedText}-->${beforeDocument}`;\n  }\n\n  /**\n   * Perform canonicalization of the given element node\n   *\n   * @api public\n   */\n  process(elem: Element, options: CanonicalizationOrTransformationAlgorithmProcessOptions): string {\n    options = options || {};\n    let inclusiveNamespacesPrefixList = options.inclusiveNamespacesPrefixList || [];\n    const defaultNs = options.defaultNs || \"\";\n    const defaultNsForPrefix = options.defaultNsForPrefix || {};\n    const ancestorNamespaces = options.ancestorNamespaces || [];\n\n    /**\n     * If the inclusiveNamespacesPrefixList has not been explicitly provided then look it up in CanonicalizationMethod/InclusiveNamespaces\n     */\n    if (!utils.isArrayHasLength(inclusiveNamespacesPrefixList)) {\n      const CanonicalizationMethod = utils.findChildren(elem, \"CanonicalizationMethod\");\n      if (CanonicalizationMethod.length !== 0) {\n        const inclusiveNamespaces = utils.findChildren(\n          CanonicalizationMethod[0],\n          \"InclusiveNamespaces\",\n        );\n        if (inclusiveNamespaces.length !== 0) {\n          inclusiveNamespacesPrefixList = (\n            inclusiveNamespaces[0].getAttribute(\"PrefixList\") || \"\"\n          ).split(\" \");\n        }\n      }\n    }\n\n    /**\n     * If you have a PrefixList then use it and the ancestors to add the necessary namespaces\n     */\n    if (utils.isArrayHasLength(inclusiveNamespacesPrefixList)) {\n      inclusiveNamespacesPrefixList.forEach(function (prefix) {\n        if (ancestorNamespaces) {\n          ancestorNamespaces.forEach(function (ancestorNamespace) {\n            if (prefix === ancestorNamespace.prefix) {\n              elem.setAttributeNS(\n                \"http://www.w3.org/2000/xmlns/\",\n                `xmlns:${prefix}`,\n                ancestorNamespace.namespaceURI,\n              );\n            }\n          });\n        }\n      });\n    }\n\n    const res = this.processInner(\n      elem,\n      [],\n      defaultNs,\n      defaultNsForPrefix,\n      inclusiveNamespacesPrefixList,\n    );\n    return res;\n  }\n\n  getAlgorithmName() {\n    return \"http://www.w3.org/2001/10/xml-exc-c14n#\";\n  }\n}\n\nexport class ExclusiveCanonicalizationWithComments extends ExclusiveCanonicalization {\n  constructor() {\n    super();\n    this.includeComments = true;\n  }\n\n  getAlgorithmName() {\n    return \"http://www.w3.org/2001/10/xml-exc-c14n#WithComments\";\n  }\n}\n"],"mappings":";;;;;;AAKA,MAAAA,KAAA,GAAAC,OAAA;AACA,MAAAC,SAAA,GAAAD,OAAA;AAEA,SAASE,eAAeA,CAACC,eAAe,EAAEC,MAAM,EAAEC,YAAY;EAC5D,IAAIC,GAAG,GAAG,KAAK;EACfH,eAAe,CAACI,OAAO,CAAC,UAAUC,EAAE;IAClC,IAAIA,EAAE,CAACJ,MAAM,KAAKA,MAAM,IAAII,EAAE,CAACH,YAAY,KAAKA,YAAY,EAAE;MAC5DC,GAAG,GAAG,IAAI;IACZ;EACF,CAAC,CAAC;EAEF,OAAOA,GAAG;AACZ;AAEA,MAAaG,yBAAyB;EAGpCC,YAAA;IAFU,KAAAC,eAAe,GAAG,KAAK;IAG/B,IAAI,CAACA,eAAe,GAAG,KAAK;EAC9B;EAEAC,WAAWA,CAACC,CAAC,EAAEC,CAAC;IACd,IAAI,CAACD,CAAC,CAACR,YAAY,IAAIS,CAAC,CAACT,YAAY,EAAE;MACrC,OAAO,CAAC,CAAC;IACX;IACA,IAAI,CAACS,CAAC,CAACT,YAAY,IAAIQ,CAAC,CAACR,YAAY,EAAE;MACrC,OAAO,CAAC;IACV;IAEA,MAAMU,IAAI,GAAGF,CAAC,CAACR,YAAY,GAAGQ,CAAC,CAACG,SAAS;IACzC,MAAMC,KAAK,GAAGH,CAAC,CAACT,YAAY,GAAGS,CAAC,CAACE,SAAS;IAE1C,IAAID,IAAI,KAAKE,KAAK,EAAE;MAClB,OAAO,CAAC;IACV,CAAC,MAAM,IAAIF,IAAI,GAAGE,KAAK,EAAE;MACvB,OAAO,CAAC,CAAC;IACX,CAAC,MAAM;MACL,OAAO,CAAC;IACV;EACF;EAEAC,SAASA,CAACL,CAAC,EAAEC,CAAC;IACZ,MAAMK,KAAK,GAAGN,CAAC,CAACT,MAAM;IACtB,MAAMgB,KAAK,GAAGN,CAAC,CAACV,MAAM;IACtB,IAAIe,KAAK,KAAKC,KAAK,EAAE;MACnB,OAAO,CAAC;IACV;IACA,OAAOD,KAAK,CAACE,aAAa,CAACD,KAAK,CAAC;EACnC;EAEAE,WAAWA,CAACC,IAAI;IACd,IAAIC,CAAC;IACL,IAAIC,IAAI;IACR,MAAMC,GAAG,GAAa,EAAE;IACxB,MAAMC,gBAAgB,GAAW,EAAE;IAEnC,IAAI1B,SAAS,CAAC2B,aAAa,CAACL,IAAI,CAAC,EAAE;MACjC,OAAO,IAAI,CAACM,aAAa,CAACN,IAAI,CAAC;IACjC;IAEA,IAAIA,IAAI,CAACO,UAAU,EAAE;MACnB,KAAKN,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,IAAI,CAACO,UAAU,CAACC,MAAM,EAAE,EAAEP,CAAC,EAAE;QAC3CC,IAAI,GAAGF,IAAI,CAACO,UAAU,CAACN,CAAC,CAAC;QACzB;QACA,IAAIC,IAAI,CAACO,IAAI,CAACC,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;UACpC;QACF;QACAN,gBAAgB,CAACO,IAAI,CAACT,IAAI,CAAC;MAC7B;IACF;IAEAE,gBAAgB,CAACQ,IAAI,CAAC,IAAI,CAACvB,WAAW,CAAC;IAEvC,KAAKa,IAAI,IAAIE,gBAAgB,EAAE;MAC7BD,GAAG,CAACQ,IAAI,CAAC,GAAG,EAAET,IAAI,CAACO,IAAI,EAAE,IAAI,EAAEjC,KAAK,CAACqC,kCAAkC,CAACX,IAAI,CAACY,KAAK,CAAC,EAAE,GAAG,CAAC;IAC3F;IAEA,OAAOX,GAAG,CAACY,IAAI,CAAC,EAAE,CAAC;EACrB;EAEA;;;;;;;;;;EAUAC,QAAQA,CACNhB,IAAI,EACJpB,eAAe,EACfqC,SAAS,EACTC,kBAAkB,EAClBC,6BAAuC;IAEvC,IAAIlB,CAAC;IACL,IAAIC,IAAI;IACR,MAAMC,GAAG,GAAa,EAAE;IACxB,IAAIiB,YAAY,GAAGH,SAAS;IAC5B,MAAMI,cAAc,GAAsB,EAAE;IAC5C,MAAMC,MAAM,GAAGtB,IAAI,CAAClB,YAAY,IAAI,EAAE;IAEtC;IACA,IAAIkB,IAAI,CAACnB,MAAM,EAAE;MACf,IACE,CAACF,eAAe,CACdC,eAAe,EACfoB,IAAI,CAACnB,MAAM,EACXmB,IAAI,CAAClB,YAAY,IAAIoC,kBAAkB,CAAClB,IAAI,CAACnB,MAAM,CAAC,CACrD,EACD;QACAwC,cAAc,CAACV,IAAI,CAAC;UAClB9B,MAAM,EAAEmB,IAAI,CAACnB,MAAM;UACnBC,YAAY,EAAEkB,IAAI,CAAClB,YAAY,IAAIoC,kBAAkB,CAAClB,IAAI,CAACnB,MAAM;SAClE,CAAC;QACFD,eAAe,CAAC+B,IAAI,CAAC;UACnB9B,MAAM,EAAEmB,IAAI,CAACnB,MAAM;UACnBC,YAAY,EAAEkB,IAAI,CAAClB,YAAY,IAAIoC,kBAAkB,CAAClB,IAAI,CAACnB,MAAM;SAClE,CAAC;MACJ;IACF,CAAC,MAAM,IAAIoC,SAAS,KAAKK,MAAM,EAAE;MAC/B;MACAF,YAAY,GAAGpB,IAAI,CAAClB,YAAY;MAChCqB,GAAG,CAACQ,IAAI,CAAC,UAAU,EAAES,YAAY,EAAE,GAAG,CAAC;IACzC;IAEA;IACA,IAAIpB,IAAI,CAACO,UAAU,EAAE;MACnB,KAAKN,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,IAAI,CAACO,UAAU,CAACC,MAAM,EAAE,EAAEP,CAAC,EAAE;QAC3CC,IAAI,GAAGF,IAAI,CAACO,UAAU,CAACN,CAAC,CAAC;QAEzB;QACA;QACA,IACEC,IAAI,CAACrB,MAAM,IACX,CAACF,eAAe,CAACC,eAAe,EAAEsB,IAAI,CAACT,SAAS,EAAES,IAAI,CAACY,KAAK,CAAC,IAC7DK,6BAA6B,CAACT,OAAO,CAACR,IAAI,CAACT,SAAS,CAAC,IAAI,CAAC,EAC1D;UACA4B,cAAc,CAACV,IAAI,CAAC;YAAE9B,MAAM,EAAEqB,IAAI,CAACT,SAAS;YAAEX,YAAY,EAAEoB,IAAI,CAACY;UAAK,CAAE,CAAC;UACzElC,eAAe,CAAC+B,IAAI,CAAC;YAAE9B,MAAM,EAAEqB,IAAI,CAACT,SAAS;YAAEX,YAAY,EAAEoB,IAAI,CAACY;UAAK,CAAE,CAAC;QAC5E;QAEA;QACA;QACA,IACEZ,IAAI,CAACrB,MAAM,IACX,CAACF,eAAe,CAACC,eAAe,EAAEsB,IAAI,CAACrB,MAAM,EAAEqB,IAAI,CAACpB,YAAY,CAAC,IACjEoB,IAAI,CAACrB,MAAM,KAAK,OAAO,IACvBqB,IAAI,CAACrB,MAAM,KAAK,KAAK,EACrB;UACAwC,cAAc,CAACV,IAAI,CAAC;YAAE9B,MAAM,EAAEqB,IAAI,CAACrB,MAAM;YAAEC,YAAY,EAAEoB,IAAI,CAACpB;UAAY,CAAE,CAAC;UAC7EF,eAAe,CAAC+B,IAAI,CAAC;YAAE9B,MAAM,EAAEqB,IAAI,CAACrB,MAAM;YAAEC,YAAY,EAAEoB,IAAI,CAACpB;UAAY,CAAE,CAAC;QAChF;MACF;IACF;IAEAuC,cAAc,CAACT,IAAI,CAAC,IAAI,CAACjB,SAAS,CAAC;IAEnC;IACA,KAAK,MAAM4B,CAAC,IAAIF,cAAc,EAAE;MAC9BlB,GAAG,CAACQ,IAAI,CAAC,SAAS,EAAEY,CAAC,CAAC1C,MAAM,EAAE,IAAI,EAAE0C,CAAC,CAACzC,YAAY,EAAE,GAAG,CAAC;IAC1D;IAEA,OAAO;MAAE0C,QAAQ,EAAErB,GAAG,CAACY,IAAI,CAAC,EAAE,CAAC;MAAEK,YAAY,EAAEA;IAAY,CAAE;EAC/D;EAEA;;;EAGAK,YAAYA,CACVzB,IAAI,EACJpB,eAAe,EACfqC,SAAS,EACTC,kBAAkB,EAClBC,6BAAuC;IAEvC,IAAIzC,SAAS,CAAC2B,aAAa,CAACL,IAAI,CAAC,EAAE;MACjC,OAAO,IAAI,CAACM,aAAa,CAACN,IAAI,CAAC;IACjC;IACA,IAAIA,IAAI,CAAC0B,IAAI,EAAE;MACb,OAAOlD,KAAK,CAACmD,6BAA6B,CAAC3B,IAAI,CAAC0B,IAAI,CAAC;IACvD;IAEA,IAAIhD,SAAS,CAACkD,aAAa,CAAC5B,IAAI,CAAC,EAAE;MACjC,IAAIC,CAAC;MACL,IAAI4B,OAAO;MACX,MAAMC,EAAE,GAAG,IAAI,CAACd,QAAQ,CACtBhB,IAAI,EACJpB,eAAe,EACfqC,SAAS,EACTC,kBAAkB,EAClBC,6BAA6B,CAC9B;MACD,MAAMhB,GAAG,GAAG,CAAC,GAAG,EAAEH,IAAI,CAAC+B,OAAO,EAAED,EAAE,CAACN,QAAQ,EAAE,IAAI,CAACzB,WAAW,CAACC,IAAI,CAAC,EAAE,GAAG,CAAC;MAEzE,KAAKC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,IAAI,CAACgC,UAAU,CAACxB,MAAM,EAAE,EAAEP,CAAC,EAAE;QAC3C4B,OAAO,GAAGjD,eAAe,CAACqD,KAAK,CAAC,CAAC,CAAC;QAClC9B,GAAG,CAACQ,IAAI,CACN,IAAI,CAACc,YAAY,CACfzB,IAAI,CAACgC,UAAU,CAAC/B,CAAC,CAAC,EAClB4B,OAAO,EACPC,EAAE,CAACV,YAAY,EACfF,kBAAkB,EAClBC,6BAA6B,CAC9B,CACF;MACH;MAEAhB,GAAG,CAACQ,IAAI,CAAC,IAAI,EAAEX,IAAI,CAAC+B,OAAO,EAAE,GAAG,CAAC;MACjC,OAAO5B,GAAG,CAACY,IAAI,CAAC,EAAE,CAAC;IACrB;IAEA,MAAM,IAAImB,KAAK,CAAC,+CAA+ClC,IAAI,CAACmC,QAAQ,EAAE,CAAC;EACjF;EAEA;EACA7B,aAAaA,CAACN,IAAa;IACzB,IAAI,CAAC,IAAI,CAACZ,eAAe,EAAE;MACzB,OAAO,EAAE;IACX;IAEA,MAAMgD,iBAAiB,GAAGpC,IAAI,CAACqC,aAAa,KAAKrC,IAAI,CAACsC,UAAU;IAChE,IAAIC,gBAAgB,GAAG,KAAK;IAC5B,IAAIC,eAAe,GAAG,KAAK;IAE3B,IAAIJ,iBAAiB,EAAE;MACrB,IAAIK,QAAQ,GAAqBzC,IAAI;MACrC,IAAI0C,YAAY,GAAqB1C,IAAI;MAEzC,OAAOyC,QAAQ,IAAI,IAAI,EAAE;QACvB,IAAIA,QAAQ,KAAKzC,IAAI,CAACqC,aAAa,CAACM,eAAe,EAAE;UACnDJ,gBAAgB,GAAG,IAAI;UACvB;QACF;QAEAE,QAAQ,GAAGA,QAAQ,CAACG,WAAW;MACjC;MAEA,OAAOF,YAAY,IAAI,IAAI,EAAE;QAC3B,IAAIA,YAAY,KAAK1C,IAAI,CAACqC,aAAa,CAACM,eAAe,EAAE;UACvDH,eAAe,GAAG,IAAI;UACtB;QACF;QAEAE,YAAY,GAAGA,YAAY,CAACG,eAAe;MAC7C;IACF;IAEA,MAAMC,aAAa,GAAGN,eAAe,GAAG,IAAI,GAAG,EAAE;IACjD,MAAMO,cAAc,GAAGR,gBAAgB,GAAG,IAAI,GAAG,EAAE;IACnD,MAAMS,WAAW,GAAGxE,KAAK,CAACmD,6BAA6B,CAAC3B,IAAI,CAAC0B,IAAI,CAAC;IAElE,OAAO,GAAGoB,aAAa,OAAOE,WAAW,MAAMD,cAAc,EAAE;EACjE;EAEA;;;;;EAKAE,OAAOA,CAACC,IAAa,EAAEC,OAAgE;IACrFA,OAAO,GAAGA,OAAO,IAAI,EAAE;IACvB,IAAIhC,6BAA6B,GAAGgC,OAAO,CAAChC,6BAA6B,IAAI,EAAE;IAC/E,MAAMF,SAAS,GAAGkC,OAAO,CAAClC,SAAS,IAAI,EAAE;IACzC,MAAMC,kBAAkB,GAAGiC,OAAO,CAACjC,kBAAkB,IAAI,EAAE;IAC3D,MAAMkC,kBAAkB,GAAGD,OAAO,CAACC,kBAAkB,IAAI,EAAE;IAE3D;;;IAGA,IAAI,CAAC5E,KAAK,CAAC6E,gBAAgB,CAAClC,6BAA6B,CAAC,EAAE;MAC1D,MAAMmC,sBAAsB,GAAG9E,KAAK,CAAC+E,YAAY,CAACL,IAAI,EAAE,wBAAwB,CAAC;MACjF,IAAII,sBAAsB,CAAC9C,MAAM,KAAK,CAAC,EAAE;QACvC,MAAMgD,mBAAmB,GAAGhF,KAAK,CAAC+E,YAAY,CAC5CD,sBAAsB,CAAC,CAAC,CAAC,EACzB,qBAAqB,CACtB;QACD,IAAIE,mBAAmB,CAAChD,MAAM,KAAK,CAAC,EAAE;UACpCW,6BAA6B,GAAG,CAC9BqC,mBAAmB,CAAC,CAAC,CAAC,CAACC,YAAY,CAAC,YAAY,CAAC,IAAI,EAAE,EACvDC,KAAK,CAAC,GAAG,CAAC;QACd;MACF;IACF;IAEA;;;IAGA,IAAIlF,KAAK,CAAC6E,gBAAgB,CAAClC,6BAA6B,CAAC,EAAE;MACzDA,6BAA6B,CAACnC,OAAO,CAAC,UAAUH,MAAM;QACpD,IAAIuE,kBAAkB,EAAE;UACtBA,kBAAkB,CAACpE,OAAO,CAAC,UAAU2E,iBAAiB;YACpD,IAAI9E,MAAM,KAAK8E,iBAAiB,CAAC9E,MAAM,EAAE;cACvCqE,IAAI,CAACU,cAAc,CACjB,+BAA+B,EAC/B,SAAS/E,MAAM,EAAE,EACjB8E,iBAAiB,CAAC7E,YAAY,CAC/B;YACH;UACF,CAAC,CAAC;QACJ;MACF,CAAC,CAAC;IACJ;IAEA,MAAMqB,GAAG,GAAG,IAAI,CAACsB,YAAY,CAC3ByB,IAAI,EACJ,EAAE,EACFjC,SAAS,EACTC,kBAAkB,EAClBC,6BAA6B,CAC9B;IACD,OAAOhB,GAAG;EACZ;EAEA0D,gBAAgBA,CAAA;IACd,OAAO,yCAAyC;EAClD;;AAhTFC,OAAA,CAAA5E,yBAAA,GAAAA,yBAAA;AAmTA,MAAa6E,qCAAsC,SAAQ7E,yBAAyB;EAClFC,YAAA;IACE,KAAK,EAAE;IACP,IAAI,CAACC,eAAe,GAAG,IAAI;EAC7B;EAEAyE,gBAAgBA,CAAA;IACd,OAAO,qDAAqD;EAC9D;;AARFC,OAAA,CAAAC,qCAAA,GAAAA,qCAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}