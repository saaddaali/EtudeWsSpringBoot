{"ast":null,"code":"/* eslint-disable no-fallthrough */\n/* eslint-disable no-bitwise */\n/* eslint-disable no-plusplus */\n/* eslint-disable no-underscore-dangle */\n\nimport { Transform } from 'node:stream';\nimport * as errors from '../FormidableError.js';\nimport FormidableError from '../FormidableError.js';\nlet s = 0;\nconst STATE = {\n  PARSER_UNINITIALIZED: s++,\n  START: s++,\n  START_BOUNDARY: s++,\n  HEADER_FIELD_START: s++,\n  HEADER_FIELD: s++,\n  HEADER_VALUE_START: s++,\n  HEADER_VALUE: s++,\n  HEADER_VALUE_ALMOST_DONE: s++,\n  HEADERS_ALMOST_DONE: s++,\n  PART_DATA_START: s++,\n  PART_DATA: s++,\n  PART_END: s++,\n  END: s++\n};\nlet f = 1;\nconst FBOUNDARY = {\n  PART_BOUNDARY: f,\n  LAST_BOUNDARY: f *= 2\n};\nconst LF = 10;\nconst CR = 13;\nconst SPACE = 32;\nconst HYPHEN = 45;\nconst COLON = 58;\nconst A = 97;\nconst Z = 122;\nfunction lower(c) {\n  return c | 0x20;\n}\nexport const STATES = {};\nObject.keys(STATE).forEach(stateName => {\n  STATES[stateName] = STATE[stateName];\n});\nclass MultipartParser extends Transform {\n  constructor(options = {}) {\n    super({\n      readableObjectMode: true\n    });\n    this.boundary = null;\n    this.boundaryChars = null;\n    this.lookbehind = null;\n    this.bufferLength = 0;\n    this.state = STATE.PARSER_UNINITIALIZED;\n    this.globalOptions = {\n      ...options\n    };\n    this.index = null;\n    this.flags = 0;\n  }\n  _endUnexpected() {\n    return new FormidableError(`MultipartParser.end(): stream ended unexpectedly: ${this.explain()}`, errors.malformedMultipart, 400);\n  }\n  _flush(done) {\n    if (this.state === STATE.HEADER_FIELD_START && this.index === 0 || this.state === STATE.PART_DATA && this.index === this.boundary.length) {\n      this._handleCallback('partEnd');\n      this._handleCallback('end');\n      done();\n    } else if (this.state !== STATE.END) {\n      done(this._endUnexpected());\n    } else {\n      done();\n    }\n  }\n  initWithBoundary(str) {\n    this.boundary = Buffer.from(`\\r\\n--${str}`);\n    this.lookbehind = Buffer.alloc(this.boundary.length + 8);\n    this.state = STATE.START;\n    this.boundaryChars = {};\n    for (let i = 0; i < this.boundary.length; i++) {\n      this.boundaryChars[this.boundary[i]] = true;\n    }\n  }\n\n  // eslint-disable-next-line max-params\n  _handleCallback(name, buf, start, end) {\n    if (start !== undefined && start === end) {\n      return;\n    }\n    this.push({\n      name,\n      buffer: buf,\n      start,\n      end\n    });\n  }\n\n  // eslint-disable-next-line max-statements\n  _transform(buffer, _, done) {\n    let i = 0;\n    let prevIndex = this.index;\n    let {\n      index,\n      state,\n      flags\n    } = this;\n    const {\n      lookbehind,\n      boundary,\n      boundaryChars\n    } = this;\n    const boundaryLength = boundary.length;\n    const boundaryEnd = boundaryLength - 1;\n    this.bufferLength = buffer.length;\n    let c = null;\n    let cl = null;\n    const setMark = (name, idx) => {\n      this[`${name}Mark`] = typeof idx === 'number' ? idx : i;\n    };\n    const clearMarkSymbol = name => {\n      delete this[`${name}Mark`];\n    };\n    const dataCallback = (name, shouldClear) => {\n      const markSymbol = `${name}Mark`;\n      if (!(markSymbol in this)) {\n        return;\n      }\n      if (!shouldClear) {\n        this._handleCallback(name, buffer, this[markSymbol], buffer.length);\n        setMark(name, 0);\n      } else {\n        this._handleCallback(name, buffer, this[markSymbol], i);\n        clearMarkSymbol(name);\n      }\n    };\n    for (i = 0; i < this.bufferLength; i++) {\n      c = buffer[i];\n      switch (state) {\n        case STATE.PARSER_UNINITIALIZED:\n          done(this._endUnexpected());\n          return;\n        case STATE.START:\n          index = 0;\n          state = STATE.START_BOUNDARY;\n        case STATE.START_BOUNDARY:\n          if (index === boundary.length - 2) {\n            if (c === HYPHEN) {\n              flags |= FBOUNDARY.LAST_BOUNDARY;\n            } else if (c !== CR) {\n              done(this._endUnexpected());\n              return;\n            }\n            index++;\n            break;\n          } else if (index - 1 === boundary.length - 2) {\n            if (flags & FBOUNDARY.LAST_BOUNDARY && c === HYPHEN) {\n              this._handleCallback('end');\n              state = STATE.END;\n              flags = 0;\n            } else if (!(flags & FBOUNDARY.LAST_BOUNDARY) && c === LF) {\n              index = 0;\n              this._handleCallback('partBegin');\n              state = STATE.HEADER_FIELD_START;\n            } else {\n              done(this._endUnexpected());\n              return;\n            }\n            break;\n          }\n          if (c !== boundary[index + 2]) {\n            index = -2;\n          }\n          if (c === boundary[index + 2]) {\n            index++;\n          }\n          break;\n        case STATE.HEADER_FIELD_START:\n          state = STATE.HEADER_FIELD;\n          setMark('headerField');\n          index = 0;\n        case STATE.HEADER_FIELD:\n          if (c === CR) {\n            clearMarkSymbol('headerField');\n            state = STATE.HEADERS_ALMOST_DONE;\n            break;\n          }\n          index++;\n          if (c === HYPHEN) {\n            break;\n          }\n          if (c === COLON) {\n            if (index === 1) {\n              // empty header field\n              done(this._endUnexpected());\n              return;\n            }\n            dataCallback('headerField', true);\n            state = STATE.HEADER_VALUE_START;\n            break;\n          }\n          cl = lower(c);\n          if (cl < A || cl > Z) {\n            done(this._endUnexpected());\n            return;\n          }\n          break;\n        case STATE.HEADER_VALUE_START:\n          if (c === SPACE) {\n            break;\n          }\n          setMark('headerValue');\n          state = STATE.HEADER_VALUE;\n        case STATE.HEADER_VALUE:\n          if (c === CR) {\n            dataCallback('headerValue', true);\n            this._handleCallback('headerEnd');\n            state = STATE.HEADER_VALUE_ALMOST_DONE;\n          }\n          break;\n        case STATE.HEADER_VALUE_ALMOST_DONE:\n          if (c !== LF) {\n            done(this._endUnexpected());\n            return;\n          }\n          state = STATE.HEADER_FIELD_START;\n          break;\n        case STATE.HEADERS_ALMOST_DONE:\n          if (c !== LF) {\n            done(this._endUnexpected());\n            return;\n          }\n          this._handleCallback('headersEnd');\n          state = STATE.PART_DATA_START;\n          break;\n        case STATE.PART_DATA_START:\n          state = STATE.PART_DATA;\n          setMark('partData');\n        case STATE.PART_DATA:\n          prevIndex = index;\n          if (index === 0) {\n            // boyer-moore derived algorithm to safely skip non-boundary data\n            i += boundaryEnd;\n            while (i < this.bufferLength && !(buffer[i] in boundaryChars)) {\n              i += boundaryLength;\n            }\n            i -= boundaryEnd;\n            c = buffer[i];\n          }\n          if (index < boundary.length) {\n            if (boundary[index] === c) {\n              if (index === 0) {\n                dataCallback('partData', true);\n              }\n              index++;\n            } else {\n              index = 0;\n            }\n          } else if (index === boundary.length) {\n            index++;\n            if (c === CR) {\n              // CR = part boundary\n              flags |= FBOUNDARY.PART_BOUNDARY;\n            } else if (c === HYPHEN) {\n              // HYPHEN = end boundary\n              flags |= FBOUNDARY.LAST_BOUNDARY;\n            } else {\n              index = 0;\n            }\n          } else if (index - 1 === boundary.length) {\n            if (flags & FBOUNDARY.PART_BOUNDARY) {\n              index = 0;\n              if (c === LF) {\n                // unset the PART_BOUNDARY flag\n                flags &= ~FBOUNDARY.PART_BOUNDARY;\n                this._handleCallback('partEnd');\n                this._handleCallback('partBegin');\n                state = STATE.HEADER_FIELD_START;\n                break;\n              }\n            } else if (flags & FBOUNDARY.LAST_BOUNDARY) {\n              if (c === HYPHEN) {\n                this._handleCallback('partEnd');\n                this._handleCallback('end');\n                state = STATE.END;\n                flags = 0;\n              } else {\n                index = 0;\n              }\n            } else {\n              index = 0;\n            }\n          }\n          if (index > 0) {\n            // when matching a possible boundary, keep a lookbehind reference\n            // in case it turns out to be a false lead\n            lookbehind[index - 1] = c;\n          } else if (prevIndex > 0) {\n            // if our boundary turned out to be rubbish, the captured lookbehind\n            // belongs to partData\n            this._handleCallback('partData', lookbehind, 0, prevIndex);\n            prevIndex = 0;\n            setMark('partData');\n\n            // reconsider the current character even so it interrupted the sequence\n            // it could be the beginning of a new sequence\n            i--;\n          }\n          break;\n        case STATE.END:\n          break;\n        default:\n          done(this._endUnexpected());\n          return;\n      }\n    }\n    dataCallback('headerField');\n    dataCallback('headerValue');\n    dataCallback('partData');\n    this.index = index;\n    this.state = state;\n    this.flags = flags;\n    done();\n    return this.bufferLength;\n  }\n  explain() {\n    return `state = ${MultipartParser.stateToString(this.state)}`;\n  }\n}\n\n// eslint-disable-next-line consistent-return\nMultipartParser.stateToString = stateNumber => {\n  // eslint-disable-next-line no-restricted-syntax, guard-for-in\n  for (const stateName in STATE) {\n    const number = STATE[stateName];\n    if (number === stateNumber) return stateName;\n  }\n};\nexport default Object.assign(MultipartParser, {\n  STATES\n});","map":{"version":3,"names":["Transform","errors","FormidableError","s","STATE","PARSER_UNINITIALIZED","START","START_BOUNDARY","HEADER_FIELD_START","HEADER_FIELD","HEADER_VALUE_START","HEADER_VALUE","HEADER_VALUE_ALMOST_DONE","HEADERS_ALMOST_DONE","PART_DATA_START","PART_DATA","PART_END","END","f","FBOUNDARY","PART_BOUNDARY","LAST_BOUNDARY","LF","CR","SPACE","HYPHEN","COLON","A","Z","lower","c","STATES","Object","keys","forEach","stateName","MultipartParser","constructor","options","readableObjectMode","boundary","boundaryChars","lookbehind","bufferLength","state","globalOptions","index","flags","_endUnexpected","explain","malformedMultipart","_flush","done","length","_handleCallback","initWithBoundary","str","Buffer","from","alloc","i","name","buf","start","end","undefined","push","buffer","_transform","_","prevIndex","boundaryLength","boundaryEnd","cl","setMark","idx","clearMarkSymbol","dataCallback","shouldClear","markSymbol","stateToString","stateNumber","number","assign"],"sources":["/Users/soukaina/Desktop/hotel-reservation-management-soap/frontend-soapt/node_modules/formidable/src/parsers/Multipart.js"],"sourcesContent":["/* eslint-disable no-fallthrough */\n/* eslint-disable no-bitwise */\n/* eslint-disable no-plusplus */\n/* eslint-disable no-underscore-dangle */\n\nimport { Transform } from 'node:stream';\nimport * as errors from '../FormidableError.js';\nimport FormidableError from '../FormidableError.js';\n\nlet s = 0;\nconst STATE = {\n  PARSER_UNINITIALIZED: s++,\n  START: s++,\n  START_BOUNDARY: s++,\n  HEADER_FIELD_START: s++,\n  HEADER_FIELD: s++,\n  HEADER_VALUE_START: s++,\n  HEADER_VALUE: s++,\n  HEADER_VALUE_ALMOST_DONE: s++,\n  HEADERS_ALMOST_DONE: s++,\n  PART_DATA_START: s++,\n  PART_DATA: s++,\n  PART_END: s++,\n  END: s++,\n};\n\nlet f = 1;\nconst FBOUNDARY = { PART_BOUNDARY: f, LAST_BOUNDARY: (f *= 2) };\n\nconst LF = 10;\nconst CR = 13;\nconst SPACE = 32;\nconst HYPHEN = 45;\nconst COLON = 58;\nconst A = 97;\nconst Z = 122;\n\nfunction lower(c) {\n  return c | 0x20;\n}\n\nexport const STATES = {};\n\nObject.keys(STATE).forEach((stateName) => {\n  STATES[stateName] = STATE[stateName];\n});\n\nclass MultipartParser extends Transform {\n  constructor(options = {}) {\n    super({ readableObjectMode: true });\n    this.boundary = null;\n    this.boundaryChars = null;\n    this.lookbehind = null;\n    this.bufferLength = 0;\n    this.state = STATE.PARSER_UNINITIALIZED;\n\n    this.globalOptions = { ...options };\n    this.index = null;\n    this.flags = 0;\n  }\n\n  _endUnexpected() {\n    return new FormidableError(\n      `MultipartParser.end(): stream ended unexpectedly: ${this.explain()}`,\n      errors.malformedMultipart,\n      400,\n    );\n  }\n\n  _flush(done) {\n    if (\n      (this.state === STATE.HEADER_FIELD_START && this.index === 0) ||\n      (this.state === STATE.PART_DATA && this.index === this.boundary.length)\n    ) {\n      this._handleCallback('partEnd');\n      this._handleCallback('end');\n      done();\n    } else if (this.state !== STATE.END) {\n      done(this._endUnexpected());\n    } else {\n      done();\n    }\n  }\n\n  initWithBoundary(str) {\n    this.boundary = Buffer.from(`\\r\\n--${str}`);\n    this.lookbehind = Buffer.alloc(this.boundary.length + 8);\n    this.state = STATE.START;\n    this.boundaryChars = {};\n\n    for (let i = 0; i < this.boundary.length; i++) {\n      this.boundaryChars[this.boundary[i]] = true;\n    }\n  }\n\n  // eslint-disable-next-line max-params\n  _handleCallback(name, buf, start, end) {\n    if (start !== undefined && start === end) {\n      return;\n    }\n    this.push({ name, buffer: buf, start, end });\n  }\n\n  // eslint-disable-next-line max-statements\n  _transform(buffer, _, done) {\n    let i = 0;\n    let prevIndex = this.index;\n    let { index, state, flags } = this;\n    const { lookbehind, boundary, boundaryChars } = this;\n    const boundaryLength = boundary.length;\n    const boundaryEnd = boundaryLength - 1;\n    this.bufferLength = buffer.length;\n    let c = null;\n    let cl = null;\n\n    const setMark = (name, idx) => {\n      this[`${name}Mark`] = typeof idx === 'number' ? idx : i;\n    };\n\n    const clearMarkSymbol = (name) => {\n      delete this[`${name}Mark`];\n    };\n\n    const dataCallback = (name, shouldClear) => {\n      const markSymbol = `${name}Mark`;\n      if (!(markSymbol in this)) {\n        return;\n      }\n\n      if (!shouldClear) {\n        this._handleCallback(name, buffer, this[markSymbol], buffer.length);\n        setMark(name, 0);\n      } else {\n        this._handleCallback(name, buffer, this[markSymbol], i);\n        clearMarkSymbol(name);\n      }\n    };\n\n    for (i = 0; i < this.bufferLength; i++) {\n      c = buffer[i];\n      switch (state) {\n        case STATE.PARSER_UNINITIALIZED:\n          done(this._endUnexpected());\n          return;\n        case STATE.START:\n          index = 0;\n          state = STATE.START_BOUNDARY;\n        case STATE.START_BOUNDARY:\n          if (index === boundary.length - 2) {\n            if (c === HYPHEN) {\n              flags |= FBOUNDARY.LAST_BOUNDARY;\n            } else if (c !== CR) {\n              done(this._endUnexpected());\n              return;\n            }\n            index++;\n            break;\n          } else if (index - 1 === boundary.length - 2) {\n            if (flags & FBOUNDARY.LAST_BOUNDARY && c === HYPHEN) {\n              this._handleCallback('end');\n              state = STATE.END;\n              flags = 0;\n            } else if (!(flags & FBOUNDARY.LAST_BOUNDARY) && c === LF) {\n              index = 0;\n              this._handleCallback('partBegin');\n              state = STATE.HEADER_FIELD_START;\n            } else {\n              done(this._endUnexpected());\n              return;\n            }\n            break;\n          }\n\n          if (c !== boundary[index + 2]) {\n            index = -2;\n          }\n          if (c === boundary[index + 2]) {\n            index++;\n          }\n          break;\n        case STATE.HEADER_FIELD_START:\n          state = STATE.HEADER_FIELD;\n          setMark('headerField');\n          index = 0;\n        case STATE.HEADER_FIELD:\n          if (c === CR) {\n            clearMarkSymbol('headerField');\n            state = STATE.HEADERS_ALMOST_DONE;\n            break;\n          }\n\n          index++;\n          if (c === HYPHEN) {\n            break;\n          }\n\n          if (c === COLON) {\n            if (index === 1) {\n              // empty header field\n              done(this._endUnexpected());\n              return;\n            }\n            dataCallback('headerField', true);\n            state = STATE.HEADER_VALUE_START;\n            break;\n          }\n\n          cl = lower(c);\n          if (cl < A || cl > Z) {\n            done(this._endUnexpected());\n            return;\n          }\n          break;\n        case STATE.HEADER_VALUE_START:\n          if (c === SPACE) {\n            break;\n          }\n\n          setMark('headerValue');\n          state = STATE.HEADER_VALUE;\n        case STATE.HEADER_VALUE:\n          if (c === CR) {\n            dataCallback('headerValue', true);\n            this._handleCallback('headerEnd');\n            state = STATE.HEADER_VALUE_ALMOST_DONE;\n          }\n          break;\n        case STATE.HEADER_VALUE_ALMOST_DONE:\n          if (c !== LF) {\n            done(this._endUnexpected());\nreturn;\n          }\n          state = STATE.HEADER_FIELD_START;\n          break;\n        case STATE.HEADERS_ALMOST_DONE:\n          if (c !== LF) {\n            done(this._endUnexpected());\n            return;\n          }\n\n          this._handleCallback('headersEnd');\n          state = STATE.PART_DATA_START;\n          break;\n        case STATE.PART_DATA_START:\n          state = STATE.PART_DATA;\n          setMark('partData');\n        case STATE.PART_DATA:\n          prevIndex = index;\n\n          if (index === 0) {\n            // boyer-moore derived algorithm to safely skip non-boundary data\n            i += boundaryEnd;\n            while (i < this.bufferLength && !(buffer[i] in boundaryChars)) {\n              i += boundaryLength;\n            }\n            i -= boundaryEnd;\n            c = buffer[i];\n          }\n\n          if (index < boundary.length) {\n            if (boundary[index] === c) {\n              if (index === 0) {\n                dataCallback('partData', true);\n              }\n              index++;\n            } else {\n              index = 0;\n            }\n          } else if (index === boundary.length) {\n            index++;\n            if (c === CR) {\n              // CR = part boundary\n              flags |= FBOUNDARY.PART_BOUNDARY;\n            } else if (c === HYPHEN) {\n              // HYPHEN = end boundary\n              flags |= FBOUNDARY.LAST_BOUNDARY;\n            } else {\n              index = 0;\n            }\n          } else if (index - 1 === boundary.length) {\n            if (flags & FBOUNDARY.PART_BOUNDARY) {\n              index = 0;\n              if (c === LF) {\n                // unset the PART_BOUNDARY flag\n                flags &= ~FBOUNDARY.PART_BOUNDARY;\n                this._handleCallback('partEnd');\n                this._handleCallback('partBegin');\n                state = STATE.HEADER_FIELD_START;\n                break;\n              }\n            } else if (flags & FBOUNDARY.LAST_BOUNDARY) {\n              if (c === HYPHEN) {\n                this._handleCallback('partEnd');\n                this._handleCallback('end');\n                state = STATE.END;\n                flags = 0;\n              } else {\n                index = 0;\n              }\n            } else {\n              index = 0;\n            }\n          }\n\n          if (index > 0) {\n            // when matching a possible boundary, keep a lookbehind reference\n            // in case it turns out to be a false lead\n            lookbehind[index - 1] = c;\n          } else if (prevIndex > 0) {\n            // if our boundary turned out to be rubbish, the captured lookbehind\n            // belongs to partData\n            this._handleCallback('partData', lookbehind, 0, prevIndex);\n            prevIndex = 0;\n            setMark('partData');\n\n            // reconsider the current character even so it interrupted the sequence\n            // it could be the beginning of a new sequence\n            i--;\n          }\n\n          break;\n        case STATE.END:\n          break;\n        default:\n          done(this._endUnexpected());\n          return;\n      }\n    }\n\n    dataCallback('headerField');\n    dataCallback('headerValue');\n    dataCallback('partData');\n\n    this.index = index;\n    this.state = state;\n    this.flags = flags;\n\n    done();\n    return this.bufferLength;\n  }\n\n  explain() {\n    return `state = ${MultipartParser.stateToString(this.state)}`;\n  }\n}\n\n// eslint-disable-next-line consistent-return\nMultipartParser.stateToString = (stateNumber) => {\n  // eslint-disable-next-line no-restricted-syntax, guard-for-in\n  for (const stateName in STATE) {\n    const number = STATE[stateName];\n    if (number === stateNumber) return stateName;\n  }\n};\n\nexport default Object.assign(MultipartParser, { STATES });\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}