{"ast":null,"code":"import axios from \"axios\";\nconst API_URL = \"http://localhost:8080/services/ws\";\nconst createSoapEnvelope = (method, params) => `\n  <soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" \n                    xmlns:ser=\"http://controller.hotelgestion.example.com/\">\n    <soapenv:Header/>\n    <soapenv:Body>\n      <ser:${method}>${params}</ser:${method}>\n    </soapenv:Body>\n  </soapenv:Envelope>\n`;\nexport const reservationService = {\n  validateDates(startDate, endDate) {\n    if (!startDate || !endDate) {\n      throw new Error(\"Les dates de début et de fin sont requises\");\n    }\n    const formatDateStr = dateStr => {\n      if (!dateStr) return null;\n      if (/^\\d{4}-\\d{2}-\\d{2}$/.test(dateStr)) {\n        return dateStr;\n      }\n      const date = new Date(dateStr);\n      if (isNaN(date.getTime())) {\n        throw new Error(`Date invalide: ${dateStr}`);\n      }\n      return date.toISOString().split(\"T\")[0];\n    };\n    const formattedStartDate = formatDateStr(startDate);\n    const formattedEndDate = formatDateStr(endDate);\n    if (formattedEndDate < formattedStartDate) {\n      throw new Error(\"La date de fin doit être après la date de début\");\n    }\n    return {\n      formattedStartDate,\n      formattedEndDate\n    };\n  },\n  handleSoapResponse(xmlDoc) {\n    const faultElement = xmlDoc.querySelector(\"soap\\\\:Fault, Fault\");\n    if (faultElement) {\n      var _faultElement$querySe;\n      const faultString = (_faultElement$querySe = faultElement.querySelector(\"faultstring\")) === null || _faultElement$querySe === void 0 ? void 0 : _faultElement$querySe.textContent;\n      throw new Error(faultString || \"Erreur SOAP inconnue\");\n    }\n    return xmlDoc;\n  },\n  async getReservations() {\n    try {\n      const response = await axios.post(API_URL, createSoapEnvelope(\"getAllReservations\", \"\"), {\n        headers: {\n          \"Content-Type\": \"text/xml\",\n          SOAPAction: \"\"\n        }\n      });\n      const parser = new DOMParser();\n      const xmlDoc = parser.parseFromString(response.data, \"text/xml\");\n      this.handleSoapResponse(xmlDoc);\n      console.log(\"Document XML analysé:\", xmlDoc);\n      const reservations = this.transformReservations(xmlDoc);\n      console.log(\"Réservations transformées:\", reservations);\n      return reservations;\n    } catch (error) {\n      var _error$response, _error$response2;\n      console.error(\"Détails de l'erreur:\", {\n        message: error.message,\n        response: (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.data,\n        status: (_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.status\n      });\n      throw new Error(`Erreur lors de la récupération des réservations: ${error.message}`);\n    }\n  },\n  async getReservationById(id) {\n    try {\n      if (!id) {\n        throw new Error(\"L'ID de la réservation est requis\");\n      }\n      const params = `<arg0>${id}</arg0>`;\n      const response = await axios.post(API_URL, createSoapEnvelope(\"getReservationById\", params), {\n        headers: {\n          \"Content-Type\": \"text/xml\",\n          SOAPAction: \"\"\n        }\n      });\n      const parser = new DOMParser();\n      const xmlDoc = parser.parseFromString(response.data, \"text/xml\");\n      this.handleSoapResponse(xmlDoc);\n      const reservation = this.transformReservation(xmlDoc.querySelector(\"return\"));\n      console.log(`Réservation ${id} récupérée:`, reservation);\n      return reservation;\n    } catch (error) {\n      console.error(`Erreur lors de la récupération de la réservation ${id}:`, error);\n      throw new Error(`Erreur lors de la récupération de la réservation: ${error.message}`);\n    }\n  },\n  async createReservation(formData) {\n    try {\n      if (!formData.clientName) {\n        throw new Error(\"Le nom du client est requis\");\n      }\n      if (!formData.email) {\n        throw new Error(\"L'email est requis\");\n      }\n      if (!formData.roomType) {\n        throw new Error(\"Le type de chambre est requis\");\n      }\n      const {\n        formattedStartDate,\n        formattedEndDate\n      } = this.validateDates(formData.startDate, formData.endDate);\n      const [firstName, ...lastNameParts] = formData.clientName.split(\" \");\n      const params = `\n        <arg0>${formattedStartDate}</arg0>\n        <arg1>${formattedEndDate}</arg1>\n        <arg2>\n          <nom>${lastNameParts.join(\" \").trim()}</nom>\n          <prenom>${firstName.trim()}</prenom>\n          <email>${formData.email}</email>\n          <telephone>${formData.phone || \"\"}</telephone>\n        </arg2>\n        <arg3>\n          <type>${formData.roomType}</type>\n          <disponible>true</disponible>\n          <prix>0.0</prix>\n        </arg3>\n      `;\n      console.log(\"Données de la réservation:\", {\n        startDate: formattedStartDate,\n        endDate: formattedEndDate,\n        clientName: formData.clientName,\n        email: formData.email,\n        roomType: formData.roomType\n      });\n      const soapEnvelope = createSoapEnvelope(\"createReservation\", params);\n      console.log(\"Enveloppe SOAP:\", soapEnvelope);\n      const response = await axios.post(API_URL, soapEnvelope, {\n        headers: {\n          \"Content-Type\": \"text/xml\",\n          SOAPAction: \"\"\n        }\n      });\n      const parser = new DOMParser();\n      const xmlDoc = parser.parseFromString(response.data, \"text/xml\");\n      this.handleSoapResponse(xmlDoc);\n      const result = this.transformReservation(xmlDoc.querySelector(\"return\"));\n      console.log(\"Réservation créée avec succès:\", result);\n      return result;\n    } catch (error) {\n      console.error(\"Erreur détaillée:\", {\n        message: error.message,\n        formData,\n        stack: error.stack\n      });\n      throw new Error(`Erreur lors de la création de la réservation: ${error.message}`);\n    }\n  },\n  async updateReservation(id, formData) {\n    try {\n      if (!id) {\n        throw new Error(\"L'ID de la réservation est requis\");\n      }\n      const {\n        formattedStartDate,\n        formattedEndDate\n      } = this.validateDates(formData.startDate, formData.endDate);\n      const [firstName, ...lastNameParts] = formData.clientName.split(\" \");\n      const params = `\n        <arg0>${id}</arg0>\n        <arg1>${formattedStartDate}</arg1>\n        <arg2>${formattedEndDate}</arg2>\n        <arg3>\n          <nom>${lastNameParts.join(\" \").trim()}</nom>\n          <prenom>${firstName.trim()}</prenom>\n          <email>${formData.email}</email>\n          <telephone>${formData.phone || \"\"}</telephone>\n        </arg3>\n        <arg4>\n          <type>${formData.roomType}</type>\n          <disponible>true</disponible>\n          <prix>0.0</prix>\n        </arg4>\n      `;\n      const response = await axios.post(API_URL, createSoapEnvelope(\"updateReservation\", params), {\n        headers: {\n          \"Content-Type\": \"text/xml\",\n          SOAPAction: \"\"\n        }\n      });\n      const parser = new DOMParser();\n      const xmlDoc = parser.parseFromString(response.data, \"text/xml\");\n      this.handleSoapResponse(xmlDoc);\n      const success = xmlDoc.querySelector(\"return\").textContent === \"true\";\n      if (!success) {\n        throw new Error(\"La mise à jour a échoué\");\n      }\n      console.log(`Réservation ${id} mise à jour avec succès`);\n      return success;\n    } catch (error) {\n      console.error(`Erreur lors de la mise à jour de la réservation ${id}:`, error);\n      throw new Error(`Erreur lors de la mise à jour de la réservation: ${error.message}`);\n    }\n  },\n  async deleteReservation(id) {\n    try {\n      if (!id) {\n        throw new Error(\"L'ID de la réservation est requis\");\n      }\n      const params = `<arg0>${id}</arg0>`;\n      const response = await axios.post(API_URL, createSoapEnvelope(\"deleteReservation\", params), {\n        headers: {\n          \"Content-Type\": \"text/xml\",\n          SOAPAction: \"\"\n        }\n      });\n      const parser = new DOMParser();\n      const xmlDoc = parser.parseFromString(response.data, \"text/xml\");\n      this.handleSoapResponse(xmlDoc);\n      const success = xmlDoc.querySelector(\"return\").textContent === \"true\";\n      if (!success) {\n        throw new Error(\"La suppression a échoué\");\n      }\n      console.log(`Réservation ${id} supprimée avec succès`);\n      return success;\n    } catch (error) {\n      console.error(`Erreur lors de la suppression de la réservation ${id}:`, error);\n      throw new Error(`Erreur lors de la suppression de la réservation: ${error.message}`);\n    }\n  },\n  transformReservation(node) {\n    if (!node) {\n      console.warn(\"Node est null dans transformReservation\");\n      return null;\n    }\n    const getNodeValue = path => {\n      const element = node.querySelector(path);\n      if (!element) {\n        console.warn(`Élément non trouvé pour le chemin: ${path}`);\n        return \"\";\n      }\n      return element.textContent;\n    };\n    const reservation = {\n      id: getNodeValue(\"id\"),\n      clientName: `${getNodeValue(\"client/prenom\")} ${getNodeValue(\"client/nom\")}`.trim(),\n      email: getNodeValue(\"client/email\"),\n      phone: getNodeValue(\"client/telephone\"),\n      roomType: getNodeValue(\"chambre/type\"),\n      startDate: getNodeValue(\"dateDebut\"),\n      endDate: getNodeValue(\"dateFin\"),\n      preferences: getNodeValue(\"preferences\") || \"\"\n    };\n    console.log(\"Réservation transformée:\", reservation);\n    return reservation;\n  },\n  transformReservations(xmlDoc) {\n    const returns = xmlDoc.querySelectorAll(\"return\");\n    console.log(`${returns.length} éléments return trouvés`);\n    const reservations = Array.from(returns).map(res => this.transformReservation(res)).filter(res => res !== null);\n    console.log(`${reservations.length} réservations valides transformées`);\n    return reservations;\n  }\n};","map":{"version":3,"names":["axios","API_URL","createSoapEnvelope","method","params","reservationService","validateDates","startDate","endDate","Error","formatDateStr","dateStr","test","date","Date","isNaN","getTime","toISOString","split","formattedStartDate","formattedEndDate","handleSoapResponse","xmlDoc","faultElement","querySelector","_faultElement$querySe","faultString","textContent","getReservations","response","post","headers","SOAPAction","parser","DOMParser","parseFromString","data","console","log","reservations","transformReservations","error","_error$response","_error$response2","message","status","getReservationById","id","reservation","transformReservation","createReservation","formData","clientName","email","roomType","firstName","lastNameParts","join","trim","phone","soapEnvelope","result","stack","updateReservation","success","deleteReservation","node","warn","getNodeValue","path","element","preferences","returns","querySelectorAll","length","Array","from","map","res","filter"],"sources":["/Users/soukaina/Desktop/hotel-reservation-management-soap/frontend-soapt/src/services/reservationService.js"],"sourcesContent":["import axios from \"axios\";\n\nconst API_URL = \"http://localhost:8080/services/ws\";\n\nconst createSoapEnvelope = (method, params) => `\n  <soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" \n                    xmlns:ser=\"http://controller.hotelgestion.example.com/\">\n    <soapenv:Header/>\n    <soapenv:Body>\n      <ser:${method}>${params}</ser:${method}>\n    </soapenv:Body>\n  </soapenv:Envelope>\n`;\n\nexport const reservationService = {\n  validateDates(startDate, endDate) {\n    if (!startDate || !endDate) {\n      throw new Error(\"Les dates de début et de fin sont requises\");\n    }\n\n    const formatDateStr = (dateStr) => {\n      if (!dateStr) return null;\n\n      if (/^\\d{4}-\\d{2}-\\d{2}$/.test(dateStr)) {\n        return dateStr;\n      }\n\n      const date = new Date(dateStr);\n      if (isNaN(date.getTime())) {\n        throw new Error(`Date invalide: ${dateStr}`);\n      }\n\n      return date.toISOString().split(\"T\")[0];\n    };\n\n    const formattedStartDate = formatDateStr(startDate);\n    const formattedEndDate = formatDateStr(endDate);\n\n    if (formattedEndDate < formattedStartDate) {\n      throw new Error(\"La date de fin doit être après la date de début\");\n    }\n\n    return { formattedStartDate, formattedEndDate };\n  },\n\n  handleSoapResponse(xmlDoc) {\n    const faultElement = xmlDoc.querySelector(\"soap\\\\:Fault, Fault\");\n    if (faultElement) {\n      const faultString =\n        faultElement.querySelector(\"faultstring\")?.textContent;\n      throw new Error(faultString || \"Erreur SOAP inconnue\");\n    }\n    return xmlDoc;\n  },\n\n  async getReservations() {\n    try {\n      const response = await axios.post(\n        API_URL,\n        createSoapEnvelope(\"getAllReservations\", \"\"),\n        {\n          headers: {\n            \"Content-Type\": \"text/xml\",\n            SOAPAction: \"\",\n          },\n        }\n      );\n\n      const parser = new DOMParser();\n      const xmlDoc = parser.parseFromString(response.data, \"text/xml\");\n      this.handleSoapResponse(xmlDoc);\n\n      console.log(\"Document XML analysé:\", xmlDoc);\n      const reservations = this.transformReservations(xmlDoc);\n      console.log(\"Réservations transformées:\", reservations);\n\n      return reservations;\n    } catch (error) {\n      console.error(\"Détails de l'erreur:\", {\n        message: error.message,\n        response: error.response?.data,\n        status: error.response?.status,\n      });\n      throw new Error(\n        `Erreur lors de la récupération des réservations: ${error.message}`\n      );\n    }\n  },\n\n  async getReservationById(id) {\n    try {\n      if (!id) {\n        throw new Error(\"L'ID de la réservation est requis\");\n      }\n\n      const params = `<arg0>${id}</arg0>`;\n      const response = await axios.post(\n        API_URL,\n        createSoapEnvelope(\"getReservationById\", params),\n        {\n          headers: {\n            \"Content-Type\": \"text/xml\",\n            SOAPAction: \"\",\n          },\n        }\n      );\n\n      const parser = new DOMParser();\n      const xmlDoc = parser.parseFromString(response.data, \"text/xml\");\n      this.handleSoapResponse(xmlDoc);\n\n      const reservation = this.transformReservation(\n        xmlDoc.querySelector(\"return\")\n      );\n      console.log(`Réservation ${id} récupérée:`, reservation);\n      return reservation;\n    } catch (error) {\n      console.error(\n        `Erreur lors de la récupération de la réservation ${id}:`,\n        error\n      );\n      throw new Error(\n        `Erreur lors de la récupération de la réservation: ${error.message}`\n      );\n    }\n  },\n\n  async createReservation(formData) {\n    try {\n      if (!formData.clientName) {\n        throw new Error(\"Le nom du client est requis\");\n      }\n      if (!formData.email) {\n        throw new Error(\"L'email est requis\");\n      }\n      if (!formData.roomType) {\n        throw new Error(\"Le type de chambre est requis\");\n      }\n\n      const { formattedStartDate, formattedEndDate } = this.validateDates(\n        formData.startDate,\n        formData.endDate\n      );\n\n      const [firstName, ...lastNameParts] = formData.clientName.split(\" \");\n      const params = `\n        <arg0>${formattedStartDate}</arg0>\n        <arg1>${formattedEndDate}</arg1>\n        <arg2>\n          <nom>${lastNameParts.join(\" \").trim()}</nom>\n          <prenom>${firstName.trim()}</prenom>\n          <email>${formData.email}</email>\n          <telephone>${formData.phone || \"\"}</telephone>\n        </arg2>\n        <arg3>\n          <type>${formData.roomType}</type>\n          <disponible>true</disponible>\n          <prix>0.0</prix>\n        </arg3>\n      `;\n\n      console.log(\"Données de la réservation:\", {\n        startDate: formattedStartDate,\n        endDate: formattedEndDate,\n        clientName: formData.clientName,\n        email: formData.email,\n        roomType: formData.roomType,\n      });\n\n      const soapEnvelope = createSoapEnvelope(\"createReservation\", params);\n      console.log(\"Enveloppe SOAP:\", soapEnvelope);\n\n      const response = await axios.post(API_URL, soapEnvelope, {\n        headers: {\n          \"Content-Type\": \"text/xml\",\n          SOAPAction: \"\",\n        },\n      });\n\n      const parser = new DOMParser();\n      const xmlDoc = parser.parseFromString(response.data, \"text/xml\");\n      this.handleSoapResponse(xmlDoc);\n\n      const result = this.transformReservation(xmlDoc.querySelector(\"return\"));\n      console.log(\"Réservation créée avec succès:\", result);\n      return result;\n    } catch (error) {\n      console.error(\"Erreur détaillée:\", {\n        message: error.message,\n        formData,\n        stack: error.stack,\n      });\n      throw new Error(\n        `Erreur lors de la création de la réservation: ${error.message}`\n      );\n    }\n  },\n\n  async updateReservation(id, formData) {\n    try {\n      if (!id) {\n        throw new Error(\"L'ID de la réservation est requis\");\n      }\n\n      const { formattedStartDate, formattedEndDate } = this.validateDates(\n        formData.startDate,\n        formData.endDate\n      );\n\n      const [firstName, ...lastNameParts] = formData.clientName.split(\" \");\n      const params = `\n        <arg0>${id}</arg0>\n        <arg1>${formattedStartDate}</arg1>\n        <arg2>${formattedEndDate}</arg2>\n        <arg3>\n          <nom>${lastNameParts.join(\" \").trim()}</nom>\n          <prenom>${firstName.trim()}</prenom>\n          <email>${formData.email}</email>\n          <telephone>${formData.phone || \"\"}</telephone>\n        </arg3>\n        <arg4>\n          <type>${formData.roomType}</type>\n          <disponible>true</disponible>\n          <prix>0.0</prix>\n        </arg4>\n      `;\n\n      const response = await axios.post(\n        API_URL,\n        createSoapEnvelope(\"updateReservation\", params),\n        {\n          headers: {\n            \"Content-Type\": \"text/xml\",\n            SOAPAction: \"\",\n          },\n        }\n      );\n\n      const parser = new DOMParser();\n      const xmlDoc = parser.parseFromString(response.data, \"text/xml\");\n      this.handleSoapResponse(xmlDoc);\n\n      const success = xmlDoc.querySelector(\"return\").textContent === \"true\";\n      if (!success) {\n        throw new Error(\"La mise à jour a échoué\");\n      }\n\n      console.log(`Réservation ${id} mise à jour avec succès`);\n      return success;\n    } catch (error) {\n      console.error(\n        `Erreur lors de la mise à jour de la réservation ${id}:`,\n        error\n      );\n      throw new Error(\n        `Erreur lors de la mise à jour de la réservation: ${error.message}`\n      );\n    }\n  },\n\n  async deleteReservation(id) {\n    try {\n      if (!id) {\n        throw new Error(\"L'ID de la réservation est requis\");\n      }\n\n      const params = `<arg0>${id}</arg0>`;\n      const response = await axios.post(\n        API_URL,\n        createSoapEnvelope(\"deleteReservation\", params),\n        {\n          headers: {\n            \"Content-Type\": \"text/xml\",\n            SOAPAction: \"\",\n          },\n        }\n      );\n\n      const parser = new DOMParser();\n      const xmlDoc = parser.parseFromString(response.data, \"text/xml\");\n      this.handleSoapResponse(xmlDoc);\n\n      const success = xmlDoc.querySelector(\"return\").textContent === \"true\";\n      if (!success) {\n        throw new Error(\"La suppression a échoué\");\n      }\n\n      console.log(`Réservation ${id} supprimée avec succès`);\n      return success;\n    } catch (error) {\n      console.error(\n        `Erreur lors de la suppression de la réservation ${id}:`,\n        error\n      );\n      throw new Error(\n        `Erreur lors de la suppression de la réservation: ${error.message}`\n      );\n    }\n  },\n\n  transformReservation(node) {\n    if (!node) {\n      console.warn(\"Node est null dans transformReservation\");\n      return null;\n    }\n\n    const getNodeValue = (path) => {\n      const element = node.querySelector(path);\n      if (!element) {\n        console.warn(`Élément non trouvé pour le chemin: ${path}`);\n        return \"\";\n      }\n      return element.textContent;\n    };\n\n    const reservation = {\n      id: getNodeValue(\"id\"),\n      clientName: `${getNodeValue(\"client/prenom\")} ${getNodeValue(\n        \"client/nom\"\n      )}`.trim(),\n      email: getNodeValue(\"client/email\"),\n      phone: getNodeValue(\"client/telephone\"),\n      roomType: getNodeValue(\"chambre/type\"),\n      startDate: getNodeValue(\"dateDebut\"),\n      endDate: getNodeValue(\"dateFin\"),\n      preferences: getNodeValue(\"preferences\") || \"\",\n    };\n\n    console.log(\"Réservation transformée:\", reservation);\n    return reservation;\n  },\n\n  transformReservations(xmlDoc) {\n    const returns = xmlDoc.querySelectorAll(\"return\");\n    console.log(`${returns.length} éléments return trouvés`);\n\n    const reservations = Array.from(returns)\n      .map((res) => this.transformReservation(res))\n      .filter((res) => res !== null);\n\n    console.log(`${reservations.length} réservations valides transformées`);\n    return reservations;\n  },\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}