{"ast":null,"code":"/* eslint-disable no-underscore-dangle */\n\nimport QuerystringParser from '../parsers/Querystring.js';\nexport const querystringType = 'urlencoded';\n// the `options` is also available through the `this.options` / `formidable.options`\nexport default function plugin(formidable, options) {\n  // the `this` context is always formidable, as the first argument of a plugin\n  // but this allows us to customize/test each plugin\n\n  /* istanbul ignore next */\n  const self = this || formidable;\n  if (/urlencoded/i.test(self.headers['content-type'])) {\n    init.call(self, self, options);\n  }\n  return self;\n}\n;\n\n// Note that it's a good practice (but it's up to you) to use the `this.options` instead\n// of the passed `options` (second) param, because when you decide\n// to test the plugin you can pass custom `this` context to it (and so `this.options`)\nfunction init(_self, _opts) {\n  this.type = querystringType;\n  const parser = new QuerystringParser(this.options);\n  parser.on('data', ({\n    key,\n    value\n  }) => {\n    this.emit('field', key, value);\n  });\n  parser.once('end', () => {\n    this.ended = true;\n    this._maybeEnd();\n  });\n  this._parser = parser;\n  return this;\n}","map":{"version":3,"names":["QuerystringParser","querystringType","plugin","formidable","options","self","test","headers","init","call","_self","_opts","type","parser","on","key","value","emit","once","ended","_maybeEnd","_parser"],"sources":["/Users/soukaina/Desktop/hotel-reservation-management-soap/frontend-soapt/node_modules/formidable/src/plugins/querystring.js"],"sourcesContent":["/* eslint-disable no-underscore-dangle */\n\n\nimport QuerystringParser from '../parsers/Querystring.js';\n\nexport const querystringType = 'urlencoded';\n// the `options` is also available through the `this.options` / `formidable.options`\nexport default function plugin(formidable, options) {\n  // the `this` context is always formidable, as the first argument of a plugin\n  // but this allows us to customize/test each plugin\n\n  /* istanbul ignore next */\n  const self = this || formidable;\n\n  if (/urlencoded/i.test(self.headers['content-type'])) {\n    init.call(self, self, options);\n  }\n  return self;\n};\n\n// Note that it's a good practice (but it's up to you) to use the `this.options` instead\n// of the passed `options` (second) param, because when you decide\n// to test the plugin you can pass custom `this` context to it (and so `this.options`)\nfunction init(_self, _opts) {\n  this.type = querystringType;\n\n  const parser = new QuerystringParser(this.options);\n\n  parser.on('data', ({ key, value }) => {\n    this.emit('field', key, value);\n  });\n\n  parser.once('end', () => {\n    this.ended = true;\n    this._maybeEnd();\n  });\n\n  this._parser = parser;\n\n  return this;\n}\n"],"mappings":"AAAA;;AAGA,OAAOA,iBAAiB,MAAM,2BAA2B;AAEzD,OAAO,MAAMC,eAAe,GAAG,YAAY;AAC3C;AACA,eAAe,SAASC,MAAMA,CAACC,UAAU,EAAEC,OAAO,EAAE;EAClD;EACA;;EAEA;EACA,MAAMC,IAAI,GAAG,IAAI,IAAIF,UAAU;EAE/B,IAAI,aAAa,CAACG,IAAI,CAACD,IAAI,CAACE,OAAO,CAAC,cAAc,CAAC,CAAC,EAAE;IACpDC,IAAI,CAACC,IAAI,CAACJ,IAAI,EAAEA,IAAI,EAAED,OAAO,CAAC;EAChC;EACA,OAAOC,IAAI;AACb;AAAC;;AAED;AACA;AACA;AACA,SAASG,IAAIA,CAACE,KAAK,EAAEC,KAAK,EAAE;EAC1B,IAAI,CAACC,IAAI,GAAGX,eAAe;EAE3B,MAAMY,MAAM,GAAG,IAAIb,iBAAiB,CAAC,IAAI,CAACI,OAAO,CAAC;EAElDS,MAAM,CAACC,EAAE,CAAC,MAAM,EAAE,CAAC;IAAEC,GAAG;IAAEC;EAAM,CAAC,KAAK;IACpC,IAAI,CAACC,IAAI,CAAC,OAAO,EAAEF,GAAG,EAAEC,KAAK,CAAC;EAChC,CAAC,CAAC;EAEFH,MAAM,CAACK,IAAI,CAAC,KAAK,EAAE,MAAM;IACvB,IAAI,CAACC,KAAK,GAAG,IAAI;IACjB,IAAI,CAACC,SAAS,CAAC,CAAC;EAClB,CAAC,CAAC;EAEF,IAAI,CAACC,OAAO,GAAGR,MAAM;EAErB,OAAO,IAAI;AACb","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}